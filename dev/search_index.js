var documenterSearchIndex = {"docs":
[{"location":"MultiField/#","page":"Gridap.MultiField","title":"Gridap.MultiField","text":"CurrentModule = Gridap.MultiField","category":"page"},{"location":"MultiField/#Gridap.MultiField-1","page":"Gridap.MultiField","title":"Gridap.MultiField","text":"","category":"section"},{"location":"MultiField/#","page":"Gridap.MultiField","title":"Gridap.MultiField","text":"Modules = [MultiField,]","category":"page"},{"location":"MultiField/#Gridap.MultiField","page":"Gridap.MultiField","title":"Gridap.MultiField","text":"The exported names are\n\nConsecutiveMultiFieldStyle\nMultiFieldCellField\nMultiFieldFEFunction\nMultiFieldFESpace\nMultiFieldStyle\ncompute_field_offsets\ninterpolate\ninterpolate_dirichlet\ninterpolate_everywhere\nnum_fields\nrestrict_to_field\n\n\n\n\n\n","category":"module"},{"location":"MultiField/#Gridap.MultiField.MultiFieldFEFunction","page":"Gridap.MultiField","title":"Gridap.MultiField.MultiFieldFEFunction","text":"struct MultiFieldFEFunction <: CellField\n  # private fields\nend\n\n\n\n\n\n","category":"type"},{"location":"MultiField/#Gridap.MultiField.MultiFieldFESpace","page":"Gridap.MultiField","title":"Gridap.MultiField.MultiFieldFESpace","text":"struct MultiFieldFESpace{S<:MultiFieldStyle,B} <: FESpace\n  spaces::Vector{<:SingleFieldFESpace}\n  multi_field_style::S\n  constraint_style::Val{B}\nend\n\n\n\n\n\n","category":"type"},{"location":"MultiField/#Gridap.MultiField.MultiFieldFESpace-Tuple{Array{var\"#s318\",1} where var\"#s318\"<:Gridap.FESpaces.SingleFieldFESpace}","page":"Gridap.MultiField","title":"Gridap.MultiField.MultiFieldFESpace","text":"MultiFieldFESpace(spaces::Vector{<:SingleFieldFESpace})\n\n\n\n\n\n","category":"method"},{"location":"MultiField/#Gridap.FESpaces.interpolate-Tuple{Any,MultiFieldFESpace}","page":"Gridap.MultiField","title":"Gridap.FESpaces.interpolate","text":"The resulting MultiFieldFEFunction is in the space (in particular it fulfills Dirichlet BCs even in the case that the given cell field does not fulfill them)\n\n\n\n\n\n","category":"method"},{"location":"MultiField/#Gridap.FESpaces.interpolate_dirichlet-Tuple{Any,MultiFieldFESpace}","page":"Gridap.MultiField","title":"Gridap.FESpaces.interpolate_dirichlet","text":"\n\n\n\n","category":"method"},{"location":"MultiField/#Gridap.FESpaces.interpolate_everywhere-Tuple{Any,MultiFieldFESpace}","page":"Gridap.MultiField","title":"Gridap.FESpaces.interpolate_everywhere","text":"like interpolate, but also compute new degrees of freedom for the dirichlet component. The resulting MultiFieldFEFunction does not necessary belongs to the underlying space\n\n\n\n\n\n","category":"method"},{"location":"MultiField/#Gridap.MultiField.compute_field_offsets-Tuple{MultiFieldFESpace}","page":"Gridap.MultiField","title":"Gridap.MultiField.compute_field_offsets","text":"compute_field_offsets(f::MultiFieldFESpace)\n\n\n\n\n\n","category":"method"},{"location":"MultiField/#Gridap.MultiField.num_fields-Tuple{Gridap.MultiField.MultiFieldFEFunction}","page":"Gridap.MultiField","title":"Gridap.MultiField.num_fields","text":"num_fields(m::MultiFieldFEFunction)\n\n\n\n\n\n","category":"method"},{"location":"MultiField/#Gridap.MultiField.num_fields-Tuple{MultiFieldFESpace}","page":"Gridap.MultiField","title":"Gridap.MultiField.num_fields","text":"num_fields(f::MultiFieldFESpace)\n\n\n\n\n\n","category":"method"},{"location":"MultiField/#Gridap.MultiField.restrict_to_field-Tuple{MultiFieldFESpace,AbstractArray{T,1} where T,Integer}","page":"Gridap.MultiField","title":"Gridap.MultiField.restrict_to_field","text":"restrict_to_field(f::MultiFieldFESpace,free_values::AbstractVector,field::Integer)\n\n\n\n\n\n","category":"method"},{"location":"getting-started/#Getting-Started-1","page":"Getting Started","title":"Getting Started","text":"","category":"section"},{"location":"getting-started/#Installation-requirements-1","page":"Getting Started","title":"Installation requirements","text":"","category":"section"},{"location":"getting-started/#","page":"Getting Started","title":"Getting Started","text":"Gridap is tested on Linux, but it should be also possible to use it on Mac OS and Windows since it is written exclusively in Julia and it only depends on registered Julia packages.","category":"page"},{"location":"getting-started/#Installation-1","page":"Getting Started","title":"Installation","text":"","category":"section"},{"location":"getting-started/#","page":"Getting Started","title":"Getting Started","text":"Gridap is a registered package. Thus, the installation should be straight forward using the Julia's package manager Pkg. To this end, open the Julia REPL (i.e., execute the julia binary), type ] to enter package mode, and install Gridap as follows","category":"page"},{"location":"getting-started/#","page":"Getting Started","title":"Getting Started","text":"pkg> add Gridap","category":"page"},{"location":"getting-started/#","page":"Getting Started","title":"Getting Started","text":"That's all.","category":"page"},{"location":"getting-started/#","page":"Getting Started","title":"Getting Started","text":"For further information about how to install and manage Julia packages, see the Pkg documentation.","category":"page"},{"location":"getting-started/#Further-steps-1","page":"Getting Started","title":"Further steps","text":"","category":"section"},{"location":"getting-started/#","page":"Getting Started","title":"Getting Started","text":"We recommend to follow the Gridap Tutorials in order to get familiar with the library.","category":"page"},{"location":"FESpaces/#","page":"Gridap.FESpaces","title":"Gridap.FESpaces","text":"CurrentModule = Gridap.FESpaces","category":"page"},{"location":"FESpaces/#Gridap.FESpaces-1","page":"Gridap.FESpaces","title":"Gridap.FESpaces","text":"","category":"section"},{"location":"FESpaces/#","page":"Gridap.FESpaces","title":"Gridap.FESpaces","text":"Modules = [FESpaces,]","category":"page"},{"location":"FESpaces/#Gridap.FESpaces","page":"Gridap.FESpaces","title":"Gridap.FESpaces","text":"The exported names are\n\nAffineFEOperator\nAffineFETerm\nAffineFETermFromCellMatVec\nAssembler\nAssemblyStrategy\nCLagrangianFESpace\nConformingFESpace\nDefaultAssemblyStrategy\nDirichletFESpace\nDiscontinuousFESpace\nEvaluationFunction\nExtendedFESpace\nFECellBasisStyle\nFEEnergy\nFEFunction\nFEFunctionStyle\nFEOperator\nFEOperatorFromTerms\nFESolver\nFESource\nFESpace\nFESpaceWithConstantFixed\nFESpaceWithLastDofRemoved\nFESpaceWithLinearConstraints\nFETerm\nFETermFromCellJacRes\nGenericSparseMatrixAssembler\nGradConformingFESpace\nHomogeneousTrialFESpace\nHomogeneousTrialFESpace!\nLinearFESolver\nLinearFETerm\nNonlinearFESolver\nSingleFieldFEFunction\nSingleFieldFESpace\nSparseMatrixAssembler\nTestFESpace\nTrialFESpace\nTrialFESpace!\nUnconstrainedFESpace\nZeroMeanFESpace\nallocate_matrix\nallocate_matrix_and_vector\nallocate_vector\nassemble_matrix\nassemble_matrix!\nassemble_matrix_add!\nassemble_matrix_and_vector\nassemble_matrix_and_vector!\nassemble_matrix_and_vector_add!\nassemble_vector\nassemble_vector!\nassemble_vector_add!\nautodiff_cell_jacobian_from_energy\nautodiff_cell_jacobian_from_residual\nautodiff_cell_residual_from_energy\ncol_map\ncol_mask\ncollect_cell_jacobian\ncollect_cell_jacobian_and_residual\ncollect_cell_matrix\ncollect_cell_matrix_and_vector\ncollect_cell_residual\ncollect_cell_vector\ncompute_conforming_cell_dofs\ncompute_dirichlet_values\ncompute_dirichlet_values_for_tags\ncompute_dirichlet_values_for_tags!\ncompute_free_and_dirichlet_values\ncompute_free_values\nconstraint_style\ncount_matrix_and_vector_nnz_coo\ncount_matrix_nnz_coo\nfill_matrix_and_vector_coo_numeric!\nfill_matrix_and_vector_coo_symbolic!\nfill_matrix_coo_numeric!\nfill_matrix_coo_symbolic!\ngather_dirichlet_values\ngather_dirichlet_values!\ngather_free_and_dirichlet_values\ngather_free_and_dirichlet_values!\ngather_free_values\ngather_free_values!\nget_algebraic_operator\nget_cell_axes\nget_cell_axes_with_constraints\nget_cell_basis\nget_cell_constraints\nget_cell_dof_basis\nget_cell_dofs\nget_cell_isconstrained\nget_cell_jacobian\nget_cell_jacobian_and_residual\nget_cell_matrix\nget_cell_residual\nget_cell_values\nget_cell_vector\nget_dirichlet_dof_tag\nget_dirichlet_values\nget_fe_space\nget_free_values\nget_matrix_type\nget_test\nget_trial\nget_vector_type\nhas_constraints\ninterpolate\ninterpolate!\ninterpolate_dirichlet\ninterpolate_dirichlet!\ninterpolate_everywhere\ninterpolate_everywhere!\nis_a_fe_cell_basis\nis_a_fe_function\nnum_dirichlet_dofs\nnum_dirichlet_tags\nnum_free_dofs\nrow_map\nrow_mask\nscatter_free_and_dirichlet_values\ntest_assembler\ntest_fe_function\ntest_fe_operator\ntest_fe_solver\ntest_fe_space\ntest_single_field_fe_space\ntest_sparse_matrix_assembler\nzero_dirichlet_values\nzero_free_values\n\n\n\n\n\n","category":"module"},{"location":"FESpaces/#Gridap.FESpaces.AffineFEOperator","page":"Gridap.FESpaces","title":"Gridap.FESpaces.AffineFEOperator","text":"AffineFEOperator\n\nReprepresent a fully assembled affine (linear) finite element problem. See also FEOperator\n\n\n\n\n\n","category":"type"},{"location":"FESpaces/#Gridap.FESpaces.AffineFEOperator-Tuple{FESpace,FESpace,AbstractArray{T,2} where T,AbstractArray{T,1} where T}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.AffineFEOperator","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.AffineFEOperator-Tuple{FESpace,FESpace,Gridap.FESpaces.Assembler,Vararg{AffineFETerm,N} where N}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.AffineFEOperator","text":"AffineFEOperator(test::FESpace,trial::FESpace,assem::Assembler,terms::AffineFETerm...)    AffineFEOperator(test::FESpace,trial::FESpace,terms::AffineFETerm...)\n\n\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.AffineFETerm","page":"Gridap.FESpaces","title":"Gridap.FESpaces.AffineFETerm","text":"See also FETerm.\n\n\n\n\n\n","category":"type"},{"location":"FESpaces/#Gridap.FESpaces.AffineFETerm-Tuple{Function,Function,Triangulation,CellQuadrature}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.AffineFETerm","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.AffineFETermFromCellMatVec","page":"Gridap.FESpaces","title":"Gridap.FESpaces.AffineFETermFromCellMatVec","text":"\n\n\n\n","category":"type"},{"location":"FESpaces/#Gridap.FESpaces.Assembler","page":"Gridap.FESpaces","title":"Gridap.FESpaces.Assembler","text":"\n\n\n\n","category":"type"},{"location":"FESpaces/#Gridap.FESpaces.AssemblyStrategy","page":"Gridap.FESpaces","title":"Gridap.FESpaces.AssemblyStrategy","text":"\n\n\n\n","category":"type"},{"location":"FESpaces/#Gridap.FESpaces.CLagrangianFESpace","page":"Gridap.FESpaces","title":"Gridap.FESpaces.CLagrangianFESpace","text":"struct CLagrangianFESpace{S} <: SingleFieldFESpace\n  grid::Grid\n  dof_to_node::Vector{Int}\n  dof_to_comp::Vector{Int8}\n  node_and_comp_to_dof::Vector{S}\n  # + private fields\nend\n\n\n\n\n\n","category":"type"},{"location":"FESpaces/#Gridap.FESpaces.CLagrangianFESpace-Union{Tuple{T}, Tuple{Type{T},Gridap.Geometry.Grid}} where T","page":"Gridap.FESpaces","title":"Gridap.FESpaces.CLagrangianFESpace","text":"CLagrangianFESpace(::Type{T},grid::Grid) where T\n\n\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.DirichletFESpace","page":"Gridap.FESpaces","title":"Gridap.FESpaces.DirichletFESpace","text":"struct DirichletFESpace <: SingleFieldFESpace\n  space::SingleFieldFESpace\nend\n\n\n\n\n\n","category":"type"},{"location":"FESpaces/#Gridap.FESpaces.ExtendedFESpace","page":"Gridap.FESpaces","title":"Gridap.FESpaces.ExtendedFESpace","text":"\n\n\n\n","category":"type"},{"location":"FESpaces/#Gridap.FESpaces.FEOperator","page":"Gridap.FESpaces","title":"Gridap.FESpaces.FEOperator","text":"abstract type FEOperator <: GridapType\n\nA FEOperator contains finite element problem, that is assembled as far as possible and ready to be solved. See also FETerm\n\n\n\n\n\n","category":"type"},{"location":"FESpaces/#Gridap.FESpaces.FEOperator-Tuple{FESpace,FESpace,Gridap.FESpaces.Assembler,Vararg{FETerm,N} where N}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.FEOperator","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.FEOperator-Tuple{FESpace,FESpace,Vararg{FETerm,N} where N}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.FEOperator","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.FESolver","page":"Gridap.FESpaces","title":"Gridap.FESpaces.FESolver","text":"\n\n\n\n","category":"type"},{"location":"FESpaces/#Gridap.FESpaces.FESolver-Tuple{Gridap.Algebra.NonlinearSolver}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.FESolver","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.FESource","page":"Gridap.FESpaces","title":"Gridap.FESpaces.FESource","text":"\n\n\n\n","category":"type"},{"location":"FESpaces/#Gridap.FESpaces.FESource-Tuple{Function,Triangulation,CellQuadrature}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.FESource","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.FESpace","page":"Gridap.FESpaces","title":"Gridap.FESpaces.FESpace","text":"\n\n\n\n","category":"type"},{"location":"FESpaces/#Gridap.FESpaces.FESpace-Tuple{}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.FESpace","text":"FESpace(; kwargs...)\n\n\nConstruct a FESpace. Supported keywords are: [:reffe, :conformity, :order, :labels, :valuetype, :model, :triangulation, :dirichlettags, :dirichletmasks, :dofspace, :constraint, :zeromeantrian, :zeromean_quad]\n\n\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.FESpaceWithConstantFixed","page":"Gridap.FESpaces","title":"Gridap.FESpaces.FESpaceWithConstantFixed","text":"FESpaceWithConstantFixed(space::SingleFieldFESpace, fix_constant::Bool,\ndof_to_fix::Int=num_free_dofs(space))\n\n\n\n\n\n","category":"type"},{"location":"FESpaces/#Gridap.FESpaces.FETerm","page":"Gridap.FESpaces","title":"Gridap.FESpaces.FETerm","text":"abstract type FETerm <: GridapType end\n\nA FETerm is a lazy representation of a summand of a finite element problem. It is not assembled. See also FEOperator.\n\n\n\n\n\n","category":"type"},{"location":"FESpaces/#Gridap.FESpaces.FETerm-Tuple{Function,Function,Triangulation,CellQuadrature}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.FETerm","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.FETerm-Tuple{Function,Triangulation,CellQuadrature}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.FETerm","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.FETermFromCellJacRes","page":"Gridap.FESpaces","title":"Gridap.FESpaces.FETermFromCellJacRes","text":"\n\n\n\n","category":"type"},{"location":"FESpaces/#Gridap.FESpaces.LinearFESolver","page":"Gridap.FESpaces","title":"Gridap.FESpaces.LinearFESolver","text":"The solver that solves a LinearFEOperator\n\n\n\n\n\n","category":"type"},{"location":"FESpaces/#Gridap.FESpaces.LinearFESolver-Tuple{}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.LinearFESolver","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.LinearFETerm","page":"Gridap.FESpaces","title":"Gridap.FESpaces.LinearFETerm","text":"See also FETerm.\n\n\n\n\n\n","category":"type"},{"location":"FESpaces/#Gridap.FESpaces.LinearFETerm-Tuple{Function,Triangulation,CellQuadrature}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.LinearFETerm","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.NonlinearFESolver","page":"Gridap.FESpaces","title":"Gridap.FESpaces.NonlinearFESolver","text":"A general NonlinearFESolver\n\n\n\n\n\n","category":"type"},{"location":"FESpaces/#Gridap.FESpaces.NonlinearFESolver-Tuple{}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.NonlinearFESolver","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.SingleFieldFEFunction","page":"Gridap.FESpaces","title":"Gridap.FESpaces.SingleFieldFEFunction","text":"\n\n\n\n","category":"type"},{"location":"FESpaces/#Gridap.FESpaces.SingleFieldFEFunction-Tuple{CellField,AbstractArray{var\"#s317\",N} where N where var\"#s317\"<:AbstractArray,AbstractArray{T,1} where T,AbstractArray{T,1} where T,Gridap.FESpaces.SingleFieldFESpace}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.SingleFieldFEFunction","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.SingleFieldFESpace","page":"Gridap.FESpaces","title":"Gridap.FESpaces.SingleFieldFESpace","text":"\n\n\n\n","category":"type"},{"location":"FESpaces/#Gridap.FESpaces.SparseMatrixAssembler","page":"Gridap.FESpaces","title":"Gridap.FESpaces.SparseMatrixAssembler","text":"\n\n\n\n","category":"type"},{"location":"FESpaces/#Gridap.FESpaces.SparseMatrixAssembler-Tuple{FESpace,FESpace}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.SparseMatrixAssembler","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.TrialFESpace-Tuple{Gridap.FESpaces.SingleFieldFESpace,Any}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.TrialFESpace","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.TrialFESpace-Tuple{Gridap.FESpaces.SingleFieldFESpace}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.TrialFESpace","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.UnconstrainedFESpace","page":"Gridap.FESpaces","title":"Gridap.FESpaces.UnconstrainedFESpace","text":"Generic implementation of an unconstrained single-field FE space Private fields and type parameters\n\n\n\n\n\n","category":"type"},{"location":"FESpaces/#Gridap.FESpaces.ZeroMeanFESpace","page":"Gridap.FESpaces","title":"Gridap.FESpaces.ZeroMeanFESpace","text":"struct ZeroMeanFESpace <: SingleFieldFESpace\n  # private fields\nend\n\n\n\n\n\n","category":"type"},{"location":"FESpaces/#Gridap.FESpaces.ZeroMeanFESpace-Tuple{Gridap.FESpaces.SingleFieldFESpace,Triangulation,CellQuadrature}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.ZeroMeanFESpace","text":"ZeroMeanFESpace(\n  space::SingleFieldFESpace,\n  trian::Triangulation,\n  quad::CellQuadrature)\n\n\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.Algebra.allocate_matrix-Tuple{Gridap.FESpaces.Assembler,Any}","page":"Gridap.FESpaces","title":"Gridap.Algebra.allocate_matrix","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.Algebra.allocate_matrix_and_vector-Tuple{Gridap.FESpaces.Assembler,Any}","page":"Gridap.FESpaces","title":"Gridap.Algebra.allocate_matrix_and_vector","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.Algebra.allocate_vector-Tuple{Gridap.FESpaces.Assembler,Any}","page":"Gridap.FESpaces","title":"Gridap.Algebra.allocate_vector","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.CellData.get_cell_axes-Tuple{FESpace}","page":"Gridap.FESpaces","title":"Gridap.CellData.get_cell_axes","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.ConformingFESpace","page":"Gridap.FESpaces","title":"Gridap.FESpaces.ConformingFESpace","text":"\n\n\n\n","category":"function"},{"location":"FESpaces/#Gridap.FESpaces.DiscontinuousFESpace","page":"Gridap.FESpaces","title":"Gridap.FESpaces.DiscontinuousFESpace","text":"DiscontinuousFESpace(reffes::Vector{<:ReferenceFE}, trian::Triangulation)\n\n\n\n\n\n","category":"function"},{"location":"FESpaces/#Gridap.FESpaces.FEFunction-Tuple{FESpace,Any}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.FEFunction","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.FEFunction-Tuple{Gridap.FESpaces.SingleFieldFESpace,AbstractArray{T,1} where T,AbstractArray{T,1} where T}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.FEFunction","text":"FEFunction(\n  fs::SingleFieldFESpace, free_values::AbstractVector, dirichlet_values::AbstractVector)\n\nThe resulting FEFunction will be in the space if and only if dirichlet_values are the ones provided by get_dirichlet_values(fs)\n\n\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.FEFunctionStyle-Union{Tuple{Type{T}}, Tuple{T}} where T","page":"Gridap.FESpaces","title":"Gridap.FESpaces.FEFunctionStyle","text":"Types marked with this trait need to implement the following queries\n\n[get_free_values(object)]\n[get_fe_space(object)]\n\n\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.GradConformingFESpace","page":"Gridap.FESpaces","title":"Gridap.FESpaces.GradConformingFESpace","text":"\n\n\n\n","category":"function"},{"location":"FESpaces/#Gridap.FESpaces.TestFESpace-Tuple{}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.TestFESpace","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.TrialFESpace!-Tuple{AbstractArray{T,1} where T,Gridap.FESpaces.SingleFieldFESpace,Any}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.TrialFESpace!","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.TrialFESpace!-Tuple{TrialFESpace,Any}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.TrialFESpace!","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.assemble_matrix!-Tuple{Any,Gridap.FESpaces.Assembler,Any}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.assemble_matrix!","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.assemble_matrix-Tuple{Gridap.FESpaces.Assembler,Any}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.assemble_matrix","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.assemble_matrix_add!-Tuple{Any,Gridap.FESpaces.Assembler,Any}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.assemble_matrix_add!","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.assemble_matrix_and_vector!-Tuple{Any,Any,Gridap.FESpaces.Assembler,Any}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.assemble_matrix_and_vector!","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.assemble_matrix_and_vector-Tuple{Gridap.FESpaces.Assembler,Any}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.assemble_matrix_and_vector","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.assemble_vector!-Tuple{Any,Gridap.FESpaces.Assembler,Any}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.assemble_vector!","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.assemble_vector-Tuple{Gridap.FESpaces.Assembler,Any}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.assemble_vector","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.assemble_vector_add!-Tuple{Any,Gridap.FESpaces.Assembler,Any}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.assemble_vector_add!","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.autodiff_cell_jacobian_from_energy","page":"Gridap.FESpaces","title":"Gridap.FESpaces.autodiff_cell_jacobian_from_energy","text":"\n\n\n\n","category":"function"},{"location":"FESpaces/#Gridap.FESpaces.autodiff_cell_jacobian_from_residual","page":"Gridap.FESpaces","title":"Gridap.FESpaces.autodiff_cell_jacobian_from_residual","text":"\n\n\n\n","category":"function"},{"location":"FESpaces/#Gridap.FESpaces.autodiff_cell_residual_from_energy","page":"Gridap.FESpaces","title":"Gridap.FESpaces.autodiff_cell_residual_from_energy","text":"\n\n\n\n","category":"function"},{"location":"FESpaces/#Gridap.FESpaces.col_map-Tuple{Gridap.FESpaces.AssemblyStrategy,Any}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.col_map","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.col_mask-Tuple{Gridap.FESpaces.AssemblyStrategy,Any}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.col_mask","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.collect_cell_jacobian-NTuple{4,Any}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.collect_cell_jacobian","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.collect_cell_jacobian_and_residual-NTuple{4,Any}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.collect_cell_jacobian_and_residual","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.collect_cell_matrix-Tuple{Any,Any,Any}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.collect_cell_matrix","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.collect_cell_matrix_and_vector-NTuple{4,Any}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.collect_cell_matrix_and_vector","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.collect_cell_residual-Tuple{Any,Any,Any}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.collect_cell_residual","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.collect_cell_vector-Tuple{Any,Any,Any}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.collect_cell_vector","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.compute_conforming_cell_dofs","page":"Gridap.FESpaces","title":"Gridap.FESpaces.compute_conforming_cell_dofs","text":"computeconformingcelldofs(     reffes,     conf,     gridtopology,     facelabeling,     dirichlettags)\n\ncomputeconformingcelldofs(     reffes,     conf,     gridtopology,     facelabeling,     dirichlettags,     dirichlet_components)\n\nThe result is the tuple\n\n(cell_dofs, nfree, ndiri, dirichlet_dof_tag, dirichlet_cells)\n\nAssumes that the reffes are aligned with the cell type in the grid_topology and that it is possible to build a conforming space without imposing constraints\n\nIf dirichlet_components  is given, then get_dof_to_comp has to be defined for the reference elements in reffes.\n\n\n\n\n\n","category":"function"},{"location":"FESpaces/#Gridap.FESpaces.compute_dirichlet_values_for_tags-Tuple{Gridap.FESpaces.SingleFieldFESpace,Any}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.compute_dirichlet_values_for_tags","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.constraint_style-Tuple{Type{var\"#s318\"} where var\"#s318\"<:FESpace}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.constraint_style","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.count_matrix_and_vector_nnz_coo-Tuple{Gridap.FESpaces.SparseMatrixAssembler,Any}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.count_matrix_and_vector_nnz_coo","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.count_matrix_nnz_coo-Tuple{Gridap.FESpaces.SparseMatrixAssembler,Any}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.count_matrix_nnz_coo","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.fill_matrix_and_vector_coo_numeric!","page":"Gridap.FESpaces","title":"Gridap.FESpaces.fill_matrix_and_vector_coo_numeric!","text":"\n\n\n\n","category":"function"},{"location":"FESpaces/#Gridap.FESpaces.fill_matrix_coo_numeric!","page":"Gridap.FESpaces","title":"Gridap.FESpaces.fill_matrix_coo_numeric!","text":"\n\n\n\n","category":"function"},{"location":"FESpaces/#Gridap.FESpaces.fill_matrix_coo_symbolic!","page":"Gridap.FESpaces","title":"Gridap.FESpaces.fill_matrix_coo_symbolic!","text":"\n\n\n\n","category":"function"},{"location":"FESpaces/#Gridap.FESpaces.gather_dirichlet_values!-Tuple{Any,Gridap.FESpaces.SingleFieldFESpace,Any}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.gather_dirichlet_values!","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.gather_dirichlet_values-Tuple{Gridap.FESpaces.SingleFieldFESpace,Any}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.gather_dirichlet_values","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.gather_free_and_dirichlet_values!-Tuple{Any,Any,Gridap.FESpaces.SingleFieldFESpace,Any}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.gather_free_and_dirichlet_values!","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.gather_free_and_dirichlet_values-Tuple{Gridap.FESpaces.SingleFieldFESpace,Any}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.gather_free_and_dirichlet_values","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.gather_free_values!-Tuple{Any,Gridap.FESpaces.SingleFieldFESpace,Any}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.gather_free_values!","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.gather_free_values-Tuple{Gridap.FESpaces.SingleFieldFESpace,Any}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.gather_free_values","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.get_algebraic_operator-Tuple{FEOperator}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.get_algebraic_operator","text":"get_algebraic_operator(feop)\n\n\nReturn an \"algebraic view\" of an operator. Algebraic means, that the resulting operator acts on plain arrays, instead of FEFunctions. This can be useful for solving with external tools like NLsolve.jl. See also FEOperator.\n\n\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.get_cell_axes_with_constraints-Tuple{FESpace}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.get_cell_axes_with_constraints","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.get_cell_basis-Tuple{FESpace}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.get_cell_basis","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.get_cell_dof_basis-Tuple{Gridap.FESpaces.SingleFieldFESpace}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.get_cell_dof_basis","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.get_cell_dofs-Tuple{FESpace}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.get_cell_dofs","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.get_cell_jacobian-Tuple{FETerm,Any,Any,Any}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.get_cell_jacobian","text":"Returns an object representing the contribution to the Jacobian of the given term. Returns nothing if the term has not contribution to the Jacobian (typically for source terms)\n\n\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.get_cell_jacobian_and_residual-Tuple{FETerm,Any,Any,Any}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.get_cell_jacobian_and_residual","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.get_cell_matrix-Tuple{AffineFETerm,Any,Any}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.get_cell_matrix","text":"Returns an object representing the contribution to the system matrix of the given term. Returns nothing if the term has not contribution (typically for source terms)\n\n\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.get_cell_residual-Tuple{FETerm,Any,Any}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.get_cell_residual","text":"Returns an object representing the contribution to the residual of the given term. Returns always something.\n\n\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.get_cell_values-Tuple{Any}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.get_cell_values","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.get_cell_vector-Tuple{AffineFETerm,Any,Any}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.get_cell_vector","text":"Returns an object (e.g. a CellVector) representing the contribution to the system rhs of the given term (with Dirichlet bcs included). Returns nothing if the term has not contribution (typically for linear terms)\n\n\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.get_cell_vector-Tuple{AffineFETerm,Any}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.get_cell_vector","text":"Returns an object (e.g. a CellVector) representing the contribution to the system rhs of the given term (without Dirichlet bcs). Returns nothing if the term has not contribution (typically for linear terms)\n\n\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.get_dirichlet_dof_tag-Tuple{Gridap.FESpaces.SingleFieldFESpace}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.get_dirichlet_dof_tag","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.get_dirichlet_values-Tuple{Gridap.FESpaces.SingleFieldFESpace}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.get_dirichlet_values","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.get_fe_space-Tuple{Any}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.get_fe_space","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.get_free_values-Tuple{Any}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.get_free_values","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.get_matrix_type-Tuple{Gridap.FESpaces.SparseMatrixAssembler}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.get_matrix_type","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.get_test-Tuple{FEOperator}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.get_test","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.get_test-Tuple{Gridap.FESpaces.Assembler}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.get_test","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.get_trial-Tuple{FEOperator}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.get_trial","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.get_trial-Tuple{Gridap.FESpaces.Assembler}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.get_trial","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.get_vector_type-Tuple{Gridap.FESpaces.SparseMatrixAssembler}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.get_vector_type","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.has_constraints-Union{Tuple{Type{T}}, Tuple{T}} where T<:FESpace","page":"Gridap.FESpaces","title":"Gridap.FESpaces.has_constraints","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.interpolate!-Tuple{Any,Any,Gridap.FESpaces.SingleFieldFESpace}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.interpolate!","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.interpolate-Tuple{Any,Gridap.FESpaces.SingleFieldFESpace}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.interpolate","text":"The resulting FE function is in the space (in particular it fulfills Dirichlet BCs even in the case that the given cell field does not fulfill them)\n\n\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.interpolate_dirichlet!-Tuple{Any,Any,Any,Gridap.FESpaces.SingleFieldFESpace}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.interpolate_dirichlet!","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.interpolate_dirichlet-Tuple{Any,Gridap.FESpaces.SingleFieldFESpace}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.interpolate_dirichlet","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.interpolate_everywhere!-Tuple{Any,Any,Any,Gridap.FESpaces.SingleFieldFESpace}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.interpolate_everywhere!","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.interpolate_everywhere-Tuple{Any,Gridap.FESpaces.SingleFieldFESpace}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.interpolate_everywhere","text":"like interpolate, but also compute new degrees of freedom for the dirichlet component. The resulting FEFunction does not necessary belongs to the underlying space\n\n\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.is_a_fe_cell_basis-Tuple{Any}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.is_a_fe_cell_basis","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.is_a_fe_function-Tuple{Any}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.is_a_fe_function","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.num_dirichlet_dofs-Tuple{Gridap.FESpaces.SingleFieldFESpace}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.num_dirichlet_dofs","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.num_dirichlet_tags-Tuple{Gridap.FESpaces.SingleFieldFESpace}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.num_dirichlet_tags","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.num_free_dofs-Tuple{FESpace}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.num_free_dofs","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.row_map-Tuple{Gridap.FESpaces.AssemblyStrategy,Any}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.row_map","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.row_mask-Tuple{Gridap.FESpaces.AssemblyStrategy,Any}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.row_mask","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.scatter_free_and_dirichlet_values-Tuple{Gridap.FESpaces.SingleFieldFESpace,Any,Any}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.scatter_free_and_dirichlet_values","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.test_assembler-Tuple{Gridap.FESpaces.Assembler,Any,Any,Any}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.test_assembler","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.test_fe_function-Tuple{Any}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.test_fe_function","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.test_fe_operator-Tuple{FEOperator,Vararg{Any,N} where N}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.test_fe_operator","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.test_fe_solver","page":"Gridap.FESpaces","title":"Gridap.FESpaces.test_fe_solver","text":"\n\n\n\n","category":"function"},{"location":"FESpaces/#Gridap.FESpaces.test_fe_space-Tuple{FESpace}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.test_fe_space","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.test_single_field_fe_space","page":"Gridap.FESpaces","title":"Gridap.FESpaces.test_single_field_fe_space","text":"\n\n\n\n","category":"function"},{"location":"FESpaces/#Gridap.FESpaces.zero_dirichlet_values-Tuple{Gridap.FESpaces.SingleFieldFESpace}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.zero_dirichlet_values","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.zero_free_values-Tuple{FESpace}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.zero_free_values","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Base.zero-Tuple{FESpace}","page":"Gridap.FESpaces","title":"Base.zero","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.Algebra.allocate_jacobian-Tuple{FEOperator,Any}","page":"Gridap.FESpaces","title":"Gridap.Algebra.allocate_jacobian","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.Algebra.allocate_residual-Tuple{FEOperator,Any}","page":"Gridap.FESpaces","title":"Gridap.Algebra.allocate_residual","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.Algebra.get_matrix-Tuple{AffineFEOperator}","page":"Gridap.FESpaces","title":"Gridap.Algebra.get_matrix","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.Algebra.get_vector-Tuple{AffineFEOperator}","page":"Gridap.FESpaces","title":"Gridap.Algebra.get_vector","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.Algebra.jacobian!-Tuple{AbstractArray{T,2} where T,FEOperator,Any}","page":"Gridap.FESpaces","title":"Gridap.Algebra.jacobian!","text":"jacobian!(A, op, u)\n\n\nInplace version of jacobian.\n\n\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.Algebra.jacobian-Tuple{FEOperator,Any}","page":"Gridap.FESpaces","title":"Gridap.Algebra.jacobian","text":"jacobian(op, u)\n\n\nCompute the jacobian of an operator op. See also get_algebraic_operator, residual_and_jacobian!.\n\n\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.Algebra.residual!-Tuple{AbstractArray{T,1} where T,FEOperator,Any}","page":"Gridap.FESpaces","title":"Gridap.Algebra.residual!","text":"residual!(b, op, u)\n\n\nInplace version of residual.\n\n\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.Algebra.residual-Tuple{FEOperator,Any}","page":"Gridap.FESpaces","title":"Gridap.Algebra.residual","text":"residual(op, u)\n\n\nCompute the residual of op at u. See also residual_and_jacobian\n\n\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.Algebra.residual_and_jacobian!-Tuple{AbstractArray{T,1} where T,AbstractArray{T,2} where T,FEOperator,Any}","page":"Gridap.FESpaces","title":"Gridap.Algebra.residual_and_jacobian!","text":"residual_and_jacobian!(b, A, op, u)\n\n\nInplace version of residual_and_jacobian.\n\n\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.Algebra.residual_and_jacobian-Tuple{FEOperator,Any}","page":"Gridap.FESpaces","title":"Gridap.Algebra.residual_and_jacobian","text":"residual, jacobian =\n\nresidual_and_jacobian(op, u)\n\n\nCompute the residual and jacobian of an operator op at a given point u. Depending on the nature of op the point u can either be a plain array or a FEFunction.\n\nSee also jacobian, residual, get_algebraic_operator.\n\n\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.Algebra.solve!-Tuple{Any,FESolver,FEOperator,Any}","page":"Gridap.FESpaces","title":"Gridap.Algebra.solve!","text":"uh, cache = solve!(uh,solver,op,cache)\n\nThis function changes the state of the input and can render it in a corrupted state. It is recommended to rewrite the input uh with the output as illustrated to prevent any issue. If cache===nothing, then it creates a new cache object.\n\n\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.Algebra.solve!-Tuple{Any,FESolver,FEOperator}","page":"Gridap.FESpaces","title":"Gridap.Algebra.solve!","text":"uh, cache = solve!(uh,solver,op)\n\nThis function changes the state of the input and can render it in a corrupted state. It is recommended to rewrite the input uh with the output as illustrated to prevent any issue.\n\n\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.Algebra.solve-Tuple{FEOperator}","page":"Gridap.FESpaces","title":"Gridap.Algebra.solve","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.Algebra.solve-Tuple{FESolver,FEOperator}","page":"Gridap.FESpaces","title":"Gridap.Algebra.solve","text":"Solve that allocates, and sets initial guess to zero and returns the solution\n\n\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.CellData.get_cell_map-Tuple{Gridap.FESpaces.SingleFieldFESpace}","page":"Gridap.FESpaces","title":"Gridap.CellData.get_cell_map","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.compute_cell_space-Tuple{Any,Any,Any}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.compute_cell_space","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.compute_cell_space_physical-Tuple{Any,Any,Any}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.compute_cell_space_physical","text":"It creates the cell-wise DOF basis and shape functions, when the DOFs are evaluated at the physical space. The DOFs (moments) for the prebasis are assumed to be computable at a reference FE space.\n\n\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.compute_discontinuous_cell_dofs-Tuple{Any,Any}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.compute_discontinuous_cell_dofs","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.get_assembly_strategy-Tuple{Gridap.FESpaces.Assembler}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.get_assembly_strategy","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.get_cell_matrix_and_vector-Tuple{AffineFETerm,Any,Any,Any}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.get_cell_matrix_and_vector","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.Geometry.get_cell_id-Tuple{FETerm}","page":"Gridap.FESpaces","title":"Gridap.Geometry.get_cell_id","text":"\n\n\n\n","category":"method"},{"location":"Arrays/#","page":"Gridap.Arrays","title":"Gridap.Arrays","text":"CurrentModule = Gridap.Arrays","category":"page"},{"location":"Arrays/#Gridap.Arrays-1","page":"Gridap.Arrays","title":"Gridap.Arrays","text":"","category":"section"},{"location":"Arrays/#","page":"Gridap.Arrays","title":"Gridap.Arrays","text":"Arrays","category":"page"},{"location":"Arrays/#Gridap.Arrays","page":"Gridap.Arrays","title":"Gridap.Arrays","text":"This module provides:\n\nAn extension of the AbstractArray interface in order to properly deal with mutable caches.\nA mechanism to generate lazy arrays resulting from operations between arrays.\nA collection of concrete implementations of AbstractArray.\n\nThe exported names in this module are:\n\nAppendedArray\nBlockArrayCoo\nBlockMatrixCoo\nBlockVectorCoo\nCachedArray\nCachedMatrix\nCachedVector\nCompressedArray\nFilterKernel\nFilteredCellArray\nKernel\nLocalToGlobalArray\nLocalToGlobalPosNegArray\nMulAddKernel\nMulKernel\nSubVector\nTable\nTwoLevelBlockedUnitRange\nUNSET\nVectorOfBlockArrayCoo\nVectorOfBlockMatrixCoo\nVectorOfBlockVectorCoo\nVectorWithEntryInserted\nVectorWithEntryRemoved\nadd_to_array!\nappend_ptrs\nappend_ptrs!\nappend_tables_globally\nappend_tables_locally\napply\napply_all\napply_kernel\napply_kernel!\napply_kernels!\narray_cache\narray_caches\nautodiff_array_gradient\nautodiff_array_hessian\nautodiff_array_jacobian\nbcast\ncollect1d\ncontract\neachblockindex\nelem\nempty_table\nenumerateblocks\nfind_inverse_index_map\nfind_inverse_index_map!\nfind_local_index\nflatten_partition\ngenerate_data_and_ptrs\nget_array\nget_arrays\nget_data_eltype\nget_local_item\nget_ptrs_eltype\ngetindex!\ngetitems\ngetitems!\nidentity_table\nidentity_vector\nis_nonzero_block\nis_zero_block\nkernel_cache\nkernel_caches\nkernel_return_type\nkernel_return_types\nkernel_testitem\nlazy_append\nlazy_split\nlength_to_ptrs!\npair_arrays\nreindex\nrewind_ptrs!\nsetaxes!\nsetsize!\ntest_array\ntest_kernel\ntestitem\ntestitems\nunpair_arrays\nuses_hash\nzeros_like\n\n\n\n\n\n","category":"module"},{"location":"Arrays/#Extended-AbstractArray-interface-1","page":"Gridap.Arrays","title":"Extended AbstractArray interface","text":"","category":"section"},{"location":"Arrays/#","page":"Gridap.Arrays","title":"Gridap.Arrays","text":"When implementing new array types, it can be needed some scratch data (e.g., allocating the output), when recovering an item from an array (typically if the array elements are non-isbits objects). To circumvent this, the user could provide the scratch data needed when getting an item. However, the Julia array interface does not support this approach. When calling a[i], in order to get the element with index i in array a, there is no extra argument for the scratch data. In order to solve this problem, we add new methods to the AbstractArray interface of Julia. We provide default implementations to the new methods, so that any AbstractArray can be used with the extended interface. New array implementations can overload these default implementations to improve performance. The most important among the new methods is getindex!, which allows to recover an item in the array by passing some scratch data.","category":"page"},{"location":"Arrays/#","page":"Gridap.Arrays","title":"Gridap.Arrays","text":"The new methods are:","category":"page"},{"location":"Arrays/#","page":"Gridap.Arrays","title":"Gridap.Arrays","text":"getindex!(cache,a::AbstractArray,i...)\narray_cache(a::AbstractArray)\nuses_hash(::Type{<:AbstractArray})\ntestitem(a::AbstractArray)","category":"page"},{"location":"Arrays/#","page":"Gridap.Arrays","title":"Gridap.Arrays","text":"These methods can be stressed with the following function","category":"page"},{"location":"Arrays/#","page":"Gridap.Arrays","title":"Gridap.Arrays","text":"test_array","category":"page"},{"location":"Arrays/#","page":"Gridap.Arrays","title":"Gridap.Arrays","text":"getindex!(cache,a::AbstractArray,i...)\narray_cache(a::AbstractArray)\nuses_hash(::Type{<:AbstractArray})\ntestitem(a::AbstractArray)\ntest_array","category":"page"},{"location":"Arrays/#Gridap.Arrays.getindex!-Tuple{Any,AbstractArray,Vararg{Any,N} where N}","page":"Gridap.Arrays","title":"Gridap.Arrays.getindex!","text":"getindex!(cache,a::AbstractArray,i...)\n\nReturns the item of the array a associated with index i by (possibly) using the scratch data passed in the cache object.\n\nIt defaults to\n\ngetindex!(cache,a::AbstractArray,i...) = a[i...]\n\nExamples\n\nIterating over an array using the getindex! function\n\nusing Gridap.Arrays\n\na = collect(10:15)\n\ncache = array_cache(a)\nfor i in eachindex(a)\n  ai = getindex!(cache,a,i)\n  println(\"$i -> $ai\")\nend\n\n# output\n1 -> 10\n2 -> 11\n3 -> 12\n4 -> 13\n5 -> 14\n6 -> 15\n\n\n\n\n\n","category":"method"},{"location":"Arrays/#Gridap.Arrays.array_cache-Tuple{AbstractArray}","page":"Gridap.Arrays","title":"Gridap.Arrays.array_cache","text":"array_cache(a::AbstractArray)\n\nReturns a cache object to be used in the getindex! function. It defaults to\n\narray_cache(a::T) where T = nothing\n\nfor types T such that uses_hash(T) == Val(false), and\n\nfunction array_cache(a::T) where T\n  hash = Dict{UInt,Any}()\n  array_cache(hash,a)\nend\n\nfor types T such that uses_hash(T) == Val(true), see the uses_hash function. In the later case, the type T should implement the following signature:\n\narray_cache(hash::Dict,a::AbstractArray)\n\nwhere we pass a dictionary (i.e., a hash table) in the first argument. This hash table can be used to test if the object a has already built a cache and re-use it as follows\n\nid = objectid(a)\nif haskey(hash,id)\n  cache = hash[id] # Reuse cache\nelse\n  cache = ... # Build a new cache depending on your needs\n  hash[id] = cache # Register the cache in the hash table\nend\n\nThis mechanism is needed, e.g., to re-use intermediate results in complex lazy operation trees. In multi-threading computations, a different hash table per thread has to be used in order to avoid race conditions.\n\n\n\n\n\n","category":"method"},{"location":"Arrays/#Gridap.Arrays.uses_hash-Tuple{Type{var\"#s18\"} where var\"#s18\"<:AbstractArray}","page":"Gridap.Arrays","title":"Gridap.Arrays.uses_hash","text":"uses_hash(::Type{<:AbstractArray})\n\nThis function is used to specify if the type T uses the hash-based mechanism to reuse caches.  It should return either Val(true) or Val(false). It defaults to\n\nuses_hash(::Type{<:AbstractArray}) = Val(false)\n\nOnce this function is defined for the type T it can also be called on instances of T.\n\n\n\n\n\n","category":"method"},{"location":"Arrays/#Gridap.Arrays.testitem-Tuple{AbstractArray}","page":"Gridap.Arrays","title":"Gridap.Arrays.testitem","text":"Returns an arbitrary instance of eltype(a). The default returned value is the first entry in the array if length(a)>0 and testvalue(eltype(a)) if length(a)==0 See the testvalue function.\n\nExamples\n\nusing Gridap.Arrays\n\na = collect(3:10)\nai = testitem(a)\n\nb = Int[]\nbi = testitem(b)\n\n(ai, bi)\n\n# output\n(3, 0)\n\n\n\n\n\n\n","category":"method"},{"location":"Arrays/#Gridap.Arrays.test_array","page":"Gridap.Arrays","title":"Gridap.Arrays.test_array","text":"test_array(\n  a::AbstractArray{T,N}, b::AbstractArray{S,N},cmp=(==)) where {T,S,N}\n\nChecks if the entries in a and b are equal using the comparison function cmp. It also stresses the new methods added to the AbstractArray interface.\n\n\n\n\n\n","category":"function"},{"location":"Arrays/#Working-with-several-arrays-at-once-1","page":"Gridap.Arrays","title":"Working with several arrays at once","text":"","category":"section"},{"location":"Arrays/#","page":"Gridap.Arrays","title":"Gridap.Arrays","text":"getitems!\ngetitems(a::Tuple{Vararg{<:AbstractArray}},i...)\narray_caches\ntestitems","category":"page"},{"location":"Arrays/#Gridap.Arrays.getitems!","page":"Gridap.Arrays","title":"Gridap.Arrays.getitems!","text":"getitems!(c::Tuple,a::Tuple,i...) -> Tuple\n\nExtracts the i-th entry of all arrays in the tuple a using the caches in the tuple c. The results is a tuple containing each one of the extracted entries.\n\nExample\n\nIterating over three different arrays simultaneously using getitems!\n\nusing Gridap.Arrays\n\na = collect(0:5)\nb = collect(10:15)\nc = collect(20:25)\n\ncaches = array_caches(a,b,c)\nfor i in eachindex(a)\n   s = getitems!(caches,(a,b,c),i)\n   println(\"$i -> $s\")\nend\n\n# output\n1 -> (0, 10, 20)\n2 -> (1, 11, 21)\n3 -> (2, 12, 22)\n4 -> (3, 13, 23)\n5 -> (4, 14, 24)\n6 -> (5, 15, 25)\n\n\n\n\n\n","category":"function"},{"location":"Arrays/#Gridap.Arrays.getitems-Tuple{Tuple{Vararg{AbstractArray,N} where N},Vararg{Any,N} where N}","page":"Gridap.Arrays","title":"Gridap.Arrays.getitems","text":"\n\n\n\n","category":"method"},{"location":"Arrays/#Gridap.Arrays.array_caches","page":"Gridap.Arrays","title":"Gridap.Arrays.array_caches","text":"array_caches(a::AbstractArray...) -> Tuple\n\nReturns a tuple with the cache of each array in a.\n\n\n\n\n\n","category":"function"},{"location":"Arrays/#Gridap.Arrays.testitems","page":"Gridap.Arrays","title":"Gridap.Arrays.testitems","text":"testitems(b::AbstractArray...) -> Tuple\n\nReturns a tuple with the result of testitem applied to each of the arrays in b.\n\nExamples\n\nusing Gridap.Arrays\n\na = collect(3:10)\nb = Int[]\nc = Float64[]\nd = ones(10)\n\ntestitems(a,b,c,d)\n\n# output\n(3, 0, 0.0, 1.0)\n\n\n\n\n\n\n","category":"function"},{"location":"Arrays/#Creating-lazy-operation-trees-1","page":"Gridap.Arrays","title":"Creating lazy operation trees","text":"","category":"section"},{"location":"Arrays/#","page":"Gridap.Arrays","title":"Gridap.Arrays","text":"apply(f,a::AbstractArray...)\napply(::Type{T},f,a::AbstractArray...) where T\napply(f::AbstractArray,a::AbstractArray...)\napply(::Type{T},f::AbstractArray,a::AbstractArray...) where T\napply_all","category":"page"},{"location":"Arrays/#Gridap.Arrays.apply-Tuple{Any,Vararg{AbstractArray,N} where N}","page":"Gridap.Arrays","title":"Gridap.Arrays.apply","text":"apply(f,a::AbstractArray...) -> AbstractArray\n\nApplies the kernel f to the entries of the arrays in a (see the definition of Kernel).\n\nThe resulting array r is such that r[i] equals to apply_kernel(f,ai...) where ai is the tuple containing the i-th entry of the arrays in a (see function apply_kernel for more details). In other words, the resulting array is numerically equivalent to:\n\nmap( (x...)->apply_kernel(f,x...), a...)\n\nSee the apply_kernel function for details.\n\nExamples\n\nUsing a function as kernel\n\nusing Gridap.Arrays\n\na = collect(0:5)\nb = collect(10:15)\n\nc = apply(+,a,b)\n\nprintln(c)\n\n# output\n[10, 12, 14, 16, 18, 20]\n\nUsing a user-defined kernel\n\nusing Gridap.Arrays\nimport Gridap.Arrays: apply_kernel!\n\na = collect(0:5)\nb = collect(10:15)\n\nstruct MySum <: Kernel end\n\napply_kernel!(cache,::MySum,x,y) = x + y\n\nk = MySum()\n\nc = apply(k,a,b)\n\nprintln(c)\n\n# output\n[10, 12, 14, 16, 18, 20]\n\n\n\n\n\n","category":"method"},{"location":"Arrays/#Gridap.Arrays.apply-Union{Tuple{T}, Tuple{Type{T},Any,Vararg{AbstractArray,N} where N}} where T","page":"Gridap.Arrays","title":"Gridap.Arrays.apply","text":"apply(::Type{T},f,a::AbstractArray...) where T\n\nLike apply(f,a::AbstractArray...), but the user provides the element type of the resulting array in order to circumvent type inference.\n\n\n\n\n\n","category":"method"},{"location":"Arrays/#Gridap.Arrays.apply-Tuple{AbstractArray,Vararg{AbstractArray,N} where N}","page":"Gridap.Arrays","title":"Gridap.Arrays.apply","text":"apply(f::AbstractArray,a::AbstractArray...) -> AbstractArray\n\nApplies the kernels in the array of kernels f to the entries in the arrays in a.\n\nThe resulting array has the same entries as the one obtained with:\n\nmap( apply_kernel, f, a...)\n\nSee the apply_kernel function for details.\n\nExample\n\n\"Evaluating\" an array of functions\n\nusing Gridap.Arrays\n\nf = [+,-,max,min]\na = [1,2,3,4]\nb = [4,3,2,1]\n\nc = apply(f,a,b)\n\nprintln(c)\n\n# output\n[5, -1, 3, 1]\n\n\n\n\n\n","category":"method"},{"location":"Arrays/#Gridap.Arrays.apply-Union{Tuple{T}, Tuple{Type{T},AbstractArray,Vararg{AbstractArray,N} where N}} where T","page":"Gridap.Arrays","title":"Gridap.Arrays.apply","text":"apply(::Type{T},f::AbstractArray,a::AbstractArray...) where T\n\nLike apply(f::AbstractArray,a::AbstractArray...), but the user provides the element type of the resulting array in order to circumvent type inference.\n\n\n\n\n\n","category":"method"},{"location":"Arrays/#Gridap.Arrays.apply_all","page":"Gridap.Arrays","title":"Gridap.Arrays.apply_all","text":"apply_all(f::Tuple,a::AbstractArray...) -> Tuple\n\nNumerically equivalent to\n\ntuple( ( apply(fi, a...) for fi in f)... )\n\nExamples\n\nusing Gridap.Arrays\n\na = [1,2,3,4]\nb = [4,3,2,1]\n\nc = apply_all( (+,-), a, b)\n\n# Equivalent to\n# c = ( apply(+,a,b), apply(-,a,b) )\n\nprintln(c)\n\n# output\n([5, 5, 5, 5], [-3, -1, 1, 3])\n\n\n\n\n\n\n","category":"function"},{"location":"Arrays/#Operation-kernels-1","page":"Gridap.Arrays","title":"Operation kernels","text":"","category":"section"},{"location":"Arrays/#","page":"Gridap.Arrays","title":"Gridap.Arrays","text":"Kernel\napply_kernel!(cache,f,x...)\nkernel_cache(f,x...)\nkernel_return_type(f,x...)\ntest_kernel","category":"page"},{"location":"Arrays/#Gridap.Arrays.Kernel","page":"Gridap.Arrays","title":"Gridap.Arrays.Kernel","text":"Abstract type representing the operations to be used in the apply function.\n\nDerived types must implement the following method:\n\napply_kernel!(cache,k,x...)\n\nand optionally these ones:\n\nkernel_cache(k,x...)\nkernel_return_type(k,x...)\n\nThe kernel interface can be tested with the test_kernel function.\n\nNote that most of the functionality implemented in terms of this interface relies in duck typing. That is, it is not strictly needed to work with types that inherit from Kernel. This is specially useful in order to accommodate existing types into this framework without the need to implement a wrapper type that inherits from Kernel. For instance, a default implementation is available for Function objects.  However, we recommend that new types inherit from Kernel.\n\n\n\n\n\n","category":"type"},{"location":"Arrays/#Gridap.Arrays.apply_kernel!-Tuple{Any,Any,Vararg{Any,N} where N}","page":"Gridap.Arrays","title":"Gridap.Arrays.apply_kernel!","text":"apply_kernel!(cache,f,x...)\n\nApplies the kernel f at the arguments x... using the scratch data provided in the given cache object. The cache object is built with the kernel_cache function using arguments of the same type as in x. In general, the returned value y can share some part of its state with the cache object. If the result of two or more invocations of this function need to be accessed simultaneously (e.g., in multi-threading), create and use various cache objects (e.g., one cache per thread).\n\n\n\n\n\n","category":"method"},{"location":"Arrays/#Gridap.Arrays.kernel_cache-Tuple{Any,Vararg{Any,N} where N}","page":"Gridap.Arrays","title":"Gridap.Arrays.kernel_cache","text":"kernel_cache(f,x...)\n\nReturns the cache needed to apply kernel f with arguments of the same type as the objects in x. This function returns nothing by default.\n\n\n\n\n\n","category":"method"},{"location":"Arrays/#Gridap.Arrays.kernel_return_type-Tuple{Any,Vararg{Any,N} where N}","page":"Gridap.Arrays","title":"Gridap.Arrays.kernel_return_type","text":"kernel_return_type(f,x...)\n\nReturns the type of the result of calling kernel f with arguments of the types of the objects x.\n\nIt defaults to typeof(kernel_testitem(f,x...))\n\n\n\n\n\n","category":"method"},{"location":"Arrays/#Gridap.Arrays.test_kernel","page":"Gridap.Arrays","title":"Gridap.Arrays.test_kernel","text":"test_kernel(f,x::Tuple,y,cmp=(==))\n\nFunction used to test if the kernel f has been implemented correctly. f is a kernel object, x is a tuple containing the arguments of the kernel, and y is the expected result. Function cmp is used to compare the computed result with the expected one. The checks are done with the @test macro.\n\n\n\n\n\n","category":"function"},{"location":"Arrays/#Other-functions-using-kernels-1","page":"Gridap.Arrays","title":"Other functions using kernels","text":"","category":"section"},{"location":"Arrays/#","page":"Gridap.Arrays","title":"Gridap.Arrays","text":"apply_kernel\napply_kernels!\nkernel_caches\nkernel_return_types","category":"page"},{"location":"Arrays/#Gridap.Arrays.apply_kernel","page":"Gridap.Arrays","title":"Gridap.Arrays.apply_kernel","text":"apply_kernel(f,x...)\n\napply the kernel f at the arguments in x by creating a temporary cache internally. This functions is equivalent to\n\ncache = kernel_cache(f,x...)\napply_kernel!(cache,f,x...)\n\n\n\n\n\n","category":"function"},{"location":"Arrays/#Gridap.Arrays.apply_kernels!","page":"Gridap.Arrays","title":"Gridap.Arrays.apply_kernels!","text":"apply_kernels!(caches::Tuple,fs::Tuple,x...) -> Tuple\n\nApplies the kernels in the tuple fs at the arguments x... by using the corresponding cache objects in the tuple caches. The result is also a tuple containing the result for each kernel in fs.\n\n\n\n\n\n","category":"function"},{"location":"Arrays/#Gridap.Arrays.kernel_caches","page":"Gridap.Arrays","title":"Gridap.Arrays.kernel_caches","text":"kernel_caches(fs::Tuple,x...) -> Tuple\n\nReturns a tuple with the cache corresponding to each kernel in fs for the arguments x....\n\n\n\n\n\n","category":"function"},{"location":"Arrays/#Gridap.Arrays.kernel_return_types","page":"Gridap.Arrays","title":"Gridap.Arrays.kernel_return_types","text":"kernel_return_types(f::Tuple,x...) -> Tuple\n\nComputes the return types of the kernels in f when called with arguments x.\n\n\n\n\n\n","category":"function"},{"location":"Arrays/#Built-in-kernels-1","page":"Gridap.Arrays","title":"Built-in kernels","text":"","category":"section"},{"location":"Arrays/#","page":"Gridap.Arrays","title":"Gridap.Arrays","text":"bcast\nelem\ncontract","category":"page"},{"location":"Arrays/#Gridap.Arrays.bcast","page":"Gridap.Arrays","title":"Gridap.Arrays.bcast","text":"bcast(f::Function)\n\nReturns a kernel object that represents the \"broadcasted\" version of the given function f.\n\n\n\n\n\n","category":"function"},{"location":"Arrays/#Gridap.Arrays.elem","page":"Gridap.Arrays","title":"Gridap.Arrays.elem","text":"elem(f::Function)\n\nReturns a kernel that represents the element-wise version of the operation f It does not broadcast in singleton axes. Thus, allows some performance optimizations with respect to broadcast.\n\n\n\n\n\n","category":"function"},{"location":"Arrays/#Gridap.Arrays.contract","page":"Gridap.Arrays","title":"Gridap.Arrays.contract","text":"contract(f::Function)\n\nLike the dot product between to vectors, but using operation f instead of * between components.\n\nwarning: Warning\nnot needed any more, to be deleted\n\nExamples\n\nusing Gridap.Arrays\nk = contract(-)\napply_kernel(k,[1,2],[2,4]) # Equivalent to (1-2) + (2-4)\n# output\n-3\n\n\n\n\n\n","category":"function"},{"location":"Arrays/#Helper-functions-1","page":"Gridap.Arrays","title":"Helper functions","text":"","category":"section"},{"location":"Arrays/#","page":"Gridap.Arrays","title":"Gridap.Arrays","text":"collect1d\nreindex(i_to_v::AbstractArray, j_to_i::AbstractArray)\nadd_to_array!(a::AbstractArray{Ta,N},b::AbstractArray{Tb,N},combine=+)  where {Ta,Tb,N} \nget_array(a::AbstractArray)\nget_arrays(a,b...)\nmatvec_muladd!(c::AbstractVector,a::AbstractMatrix,b::AbstractVector)\npair_arrays(a::AbstractArray,b::AbstractArray)\nunpair_arrays(pair::AbstractArray{<:Tuple})","category":"page"},{"location":"Arrays/#Gridap.Arrays.collect1d","page":"Gridap.Arrays","title":"Gridap.Arrays.collect1d","text":"collect1d(a)\n\nEquivalent to\n\n[a[i] for in 1:length(a)]\n\n\n\n\n\n","category":"function"},{"location":"Arrays/#Gridap.Arrays.reindex-Tuple{AbstractArray,AbstractArray}","page":"Gridap.Arrays","title":"Gridap.Arrays.reindex","text":"reindex(i_to_v::AbstractArray, j_to_i::AbstractArray)\n\n\n\n\n\n","category":"method"},{"location":"Arrays/#Gridap.Arrays.add_to_array!-Union{Tuple{N}, Tuple{Tb}, Tuple{Ta}, Tuple{AbstractArray{Ta,N},AbstractArray{Tb,N}}, Tuple{AbstractArray{Ta,N},AbstractArray{Tb,N},Any}} where N where Tb where Ta","page":"Gridap.Arrays","title":"Gridap.Arrays.add_to_array!","text":"\n\n\n\n","category":"method"},{"location":"Arrays/#Gridap.Arrays.get_array-Tuple{AbstractArray}","page":"Gridap.Arrays","title":"Gridap.Arrays.get_array","text":"get_array(a::AbstractArray)\n\nReturns a.\n\n\n\n\n\n","category":"method"},{"location":"Arrays/#Gridap.Arrays.get_arrays-Tuple{Any,Vararg{Any,N} where N}","page":"Gridap.Arrays","title":"Gridap.Arrays.get_arrays","text":"\n\n\n\n","category":"method"},{"location":"Arrays/#Gridap.Arrays.pair_arrays-Tuple{AbstractArray,AbstractArray}","page":"Gridap.Arrays","title":"Gridap.Arrays.pair_arrays","text":"\n\n\n\n","category":"method"},{"location":"Arrays/#Gridap.Arrays.unpair_arrays-Tuple{AbstractArray{var\"#s18\",N} where N where var\"#s18\"<:Tuple}","page":"Gridap.Arrays","title":"Gridap.Arrays.unpair_arrays","text":"\n\n\n\n","category":"method"},{"location":"Arrays/#Concrete-array-implementations-1","page":"Gridap.Arrays","title":"Concrete array implementations","text":"","category":"section"},{"location":"Arrays/#CachedArray-1","page":"Gridap.Arrays","title":"CachedArray","text":"","category":"section"},{"location":"Arrays/#","page":"Gridap.Arrays","title":"Gridap.Arrays","text":"CachedArray\nCachedArray(a::AbstractArray)\nCachedArray(T,N)\nsetsize!\nCachedMatrix\nCachedVector","category":"page"},{"location":"Arrays/#Gridap.Arrays.CachedArray","page":"Gridap.Arrays","title":"Gridap.Arrays.CachedArray","text":"mutable struct CachedArray{T, N, A<:AbstractArray{T,N}} <: AbstractArray{T,N}\n\nType providing a re-sizable array.\n\nThe size of a CachedArray is changed via the setsize! function.\n\nA CachedArray can be build with the constructors\n\nCachedArray(a::AbstractArray)\nCachedArray(T,N)\n\nusing Gridap.Arrays\n# Create an empty CachedArray\na = CachedArray(Float64,2)\n# Resize to new shape (2,3)\nsetsize!(a,(2,3))\nsize(a)\n# output\n(2, 3)\n\n\n\n\n\n","category":"type"},{"location":"Arrays/#Gridap.Arrays.CachedArray-Tuple{AbstractArray}","page":"Gridap.Arrays","title":"Gridap.Arrays.CachedArray","text":"CachedArray(a::AbstractArray)\n\nConstructs a CachedArray from a given array.\n\n\n\n\n\n","category":"method"},{"location":"Arrays/#Gridap.Arrays.CachedArray-Tuple{Any,Any}","page":"Gridap.Arrays","title":"Gridap.Arrays.CachedArray","text":"CachedArray(T,N)\n\nConstructs an empty CachedArray of element type T and N dimensions.\n\n\n\n\n\n","category":"method"},{"location":"Arrays/#Gridap.Arrays.setsize!","page":"Gridap.Arrays","title":"Gridap.Arrays.setsize!","text":"setsize!(a, s)\n\n\nChanges the size of the CachedArray a to the size described the the tuple s. After calling setsize!, the array can store uninitialized values.\n\n\n\n\n\n","category":"function"},{"location":"Arrays/#Gridap.Arrays.CachedMatrix","page":"Gridap.Arrays","title":"Gridap.Arrays.CachedMatrix","text":"const CachedMatrix{T,A} = CachedArray{T,2,A}\n\n\n\n\n\n","category":"type"},{"location":"Arrays/#Gridap.Arrays.CachedVector","page":"Gridap.Arrays","title":"Gridap.Arrays.CachedVector","text":"const CachedVector{T,A} = CachedArray{T,1,A}\n\n\n\n\n\n","category":"type"},{"location":"Arrays/#CompressedArray-1","page":"Gridap.Arrays","title":"CompressedArray","text":"","category":"section"},{"location":"Arrays/#","page":"Gridap.Arrays","title":"Gridap.Arrays","text":"CompressedArray\nCompressedArray(::AbstractArray,::AbstractArray)","category":"page"},{"location":"Arrays/#Gridap.Arrays.CompressedArray","page":"Gridap.Arrays","title":"Gridap.Arrays.CompressedArray","text":"struct CompressedArray{T,N,A,P} <: AbstractArray{T,N}\n  values::A\n  ptrs::P\nend\n\nType representing an array with a reduced set of values. The array is represented by a short array of values, namely the field values, and a large array of indices, namely the field ptrs. The i-th component of the resulting array is defined as values[ptrs[i]]. The type parameters A, and P are restricted to be array types by the inner constructor of this struct.\n\n\n\n\n\n","category":"type"},{"location":"Arrays/#Gridap.Arrays.CompressedArray-Tuple{AbstractArray,AbstractArray}","page":"Gridap.Arrays","title":"Gridap.Arrays.CompressedArray","text":"CompressedArray(values::AbstractArray,ptrs::AbstractArray)\n\nCreates a CompressedArray object by the given arrays of values and  ptrs.\n\n\n\n\n\n","category":"method"},{"location":"Arrays/#Table-1","page":"Gridap.Arrays","title":"Table","text":"","category":"section"},{"location":"Arrays/#","page":"Gridap.Arrays","title":"Gridap.Arrays","text":"Table\nTable(data::AbstractVector,ptrs::AbstractVector)\nTable(a::AbstractVector{<:AbstractVector})\nidentity_table(::Type{T},::Type{P},l::Integer) where {T,P}\nempty_table(::Type{T},::Type{P}, l::Integer) where {T,P}\nget_ptrs_eltype(::Table{T,P}) where {T,P}\nget_data_eltype(::Table{T,P}) where {T,P}\nappend_tables_globally(tables::Table{T,P}...) where {T,P}\nappend_tables_locally(offsets::NTuple, tables::NTuple)\nappend_tables_locally(tables::Table...)\nrewind_ptrs!(ptrs::AbstractVector{<:Integer})\ngenerate_data_and_ptrs(vv::AbstractVector{<:AbstractVector{T}}) where T\nlength_to_ptrs!(ptrs::AbstractArray{<:Integer})\nappend_ptrs(pa::AbstractVector{T},pb::AbstractVector{T}) where T\nappend_ptrs!(pa::AbstractVector{T},pb::AbstractVector{T}) where T\nfind_inverse_index_map(a_to_b, nb)\nfind_inverse_index_map!(a_to_b, b_to_a)\nflatten_partition(a_to_bs::Table,nb::Integer)\nfind_local_index(a_to_b, b_to_la_to_a)\nget_local_item(a_to_lb_to_b, lb::Integer)\nUNSET","category":"page"},{"location":"Arrays/#Gridap.Arrays.Table","page":"Gridap.Arrays","title":"Gridap.Arrays.Table","text":" struct Table{T,Vd<:AbstractVector{T},Vp<:AbstractVector} <: AbstractVector{Vector{T}}\n    data::Vd\n    ptrs::Vp\n end\n\nType representing a list of lists (i.e., a table) in compressed format.\n\n\n\n\n\n","category":"type"},{"location":"Arrays/#Gridap.Arrays.Table-Tuple{AbstractArray{var\"#s18\",1} where var\"#s18\"<:(AbstractArray{T,1} where T)}","page":"Gridap.Arrays","title":"Gridap.Arrays.Table","text":"Table(a::AbstractArray{<:AbstractArray})\n\nBuild a table from a vector of vectors. If the inputs are multidimensional arrays instead of vectors, they are flattened.\n\n\n\n\n\n","category":"method"},{"location":"Arrays/#Gridap.Arrays.identity_table-Union{Tuple{P}, Tuple{T}, Tuple{Type{T},Type{P},Integer}} where P where T","page":"Gridap.Arrays","title":"Gridap.Arrays.identity_table","text":"\n\n\n\n","category":"method"},{"location":"Arrays/#Gridap.Arrays.empty_table-Union{Tuple{P}, Tuple{T}, Tuple{Type{T},Type{P},Integer}} where P where T","page":"Gridap.Arrays","title":"Gridap.Arrays.empty_table","text":"empty_table(::Type{T},::Type{P}, l::Integer) where {T,P}\nempty_table(l::Integer)\n\n\n\n\n\n","category":"method"},{"location":"Arrays/#Gridap.Arrays.get_ptrs_eltype-Union{Tuple{Gridap.Arrays.Table{T,P,Vp} where Vp<:(AbstractArray{T,1} where T)}, Tuple{P}, Tuple{T}} where P where T","page":"Gridap.Arrays","title":"Gridap.Arrays.get_ptrs_eltype","text":"\n\n\n\n","category":"method"},{"location":"Arrays/#Gridap.Arrays.get_data_eltype-Union{Tuple{Gridap.Arrays.Table{T,P,Vp} where Vp<:(AbstractArray{T,1} where T)}, Tuple{P}, Tuple{T}} where P where T","page":"Gridap.Arrays","title":"Gridap.Arrays.get_data_eltype","text":"\n\n\n\n","category":"method"},{"location":"Arrays/#Gridap.Arrays.append_tables_locally-Tuple{Tuple{Vararg{T,N}} where T where N,Tuple{Vararg{T,N}} where T where N}","page":"Gridap.Arrays","title":"Gridap.Arrays.append_tables_locally","text":"\n\n\n\n","category":"method"},{"location":"Arrays/#Gridap.Arrays.append_tables_locally-Tuple{Vararg{Gridap.Arrays.Table,N} where N}","page":"Gridap.Arrays","title":"Gridap.Arrays.append_tables_locally","text":"append_tables_locally(tables::Table...)\n\n\n\n\n\n","category":"method"},{"location":"Arrays/#Gridap.Arrays.rewind_ptrs!-Tuple{AbstractArray{var\"#s18\",1} where var\"#s18\"<:Integer}","page":"Gridap.Arrays","title":"Gridap.Arrays.rewind_ptrs!","text":"rewind_ptrs!(ptrs)\n\nRewind the given vector of pointers.\n\n\n\n\n\n","category":"method"},{"location":"Arrays/#Gridap.Arrays.generate_data_and_ptrs-Union{Tuple{AbstractArray{var\"#s18\",1} where var\"#s18\"<:AbstractArray{T,1}}, Tuple{T}} where T","page":"Gridap.Arrays","title":"Gridap.Arrays.generate_data_and_ptrs","text":"data, ptrs = generate_data_and_ptrs(vv)\n\nGiven a vector of vectors, compress it and return the corresponding data and and ptrs\n\n\n\n\n\n","category":"method"},{"location":"Arrays/#Gridap.Arrays.length_to_ptrs!-Tuple{AbstractArray{var\"#s18\",N} where N where var\"#s18\"<:Integer}","page":"Gridap.Arrays","title":"Gridap.Arrays.length_to_ptrs!","text":"length_to_ptrs!(ptrs)\n\nGiven a vector of integers, mutate it from length state to pointer state.\n\n\n\n\n\n","category":"method"},{"location":"Arrays/#Gridap.Arrays.append_ptrs-Union{Tuple{T}, Tuple{AbstractArray{T,1},AbstractArray{T,1}}} where T","page":"Gridap.Arrays","title":"Gridap.Arrays.append_ptrs","text":"append_ptrs(pa,pb)\n\nAppend two vectors of pointers.\n\n\n\n\n\n","category":"method"},{"location":"Arrays/#Gridap.Arrays.append_ptrs!-Union{Tuple{T}, Tuple{AbstractArray{T,1},AbstractArray{T,1}}} where T","page":"Gridap.Arrays","title":"Gridap.Arrays.append_ptrs!","text":"\n\n\n\n","category":"method"},{"location":"Arrays/#Gridap.Arrays.find_inverse_index_map-Tuple{Any,Any}","page":"Gridap.Arrays","title":"Gridap.Arrays.find_inverse_index_map","text":"\n\n\n\n","category":"method"},{"location":"Arrays/#Gridap.Arrays.find_inverse_index_map!-Tuple{Any,Any}","page":"Gridap.Arrays","title":"Gridap.Arrays.find_inverse_index_map!","text":"\n\n\n\n","category":"method"},{"location":"Arrays/#Gridap.Arrays.flatten_partition-Tuple{Gridap.Arrays.Table,Integer}","page":"Gridap.Arrays","title":"Gridap.Arrays.flatten_partition","text":"flatten_partition(a_to_bs::Table,nb::Integer)\nflatten_partition(a_to_bs::Table)\n\n\n\n\n\n","category":"method"},{"location":"Arrays/#Gridap.Arrays.find_local_index-Tuple{Any,Any}","page":"Gridap.Arrays","title":"Gridap.Arrays.find_local_index","text":"find_local_index(a_to_b, b_to_la_to_a)\n\n\n\n\n\n","category":"method"},{"location":"Arrays/#Gridap.Arrays.get_local_item-Tuple{Any,Integer}","page":"Gridap.Arrays","title":"Gridap.Arrays.get_local_item","text":"get_local_item(a_to_lb_to_b, lb::Integer)\n\n\n\n\n\n","category":"method"},{"location":"Arrays/#Gridap.Arrays.UNSET","page":"Gridap.Arrays","title":"Gridap.Arrays.UNSET","text":"\n\n\n\n","category":"constant"},{"location":"Arrays/#LocalToGlobalArray-1","page":"Gridap.Arrays","title":"LocalToGlobalArray","text":"","category":"section"},{"location":"Arrays/#","page":"Gridap.Arrays","title":"Gridap.Arrays","text":"LocalToGlobalArray\nLocalToGlobalArray(::AbstractArray{<:AbstractArray},::AbstractArray)","category":"page"},{"location":"Arrays/#Gridap.Arrays.LocalToGlobalArray","page":"Gridap.Arrays","title":"Gridap.Arrays.LocalToGlobalArray","text":"\n\n\n\n","category":"type"},{"location":"Arrays/#Gridap.Arrays.LocalToGlobalArray-Tuple{AbstractArray{var\"#s18\",N} where N where var\"#s18\"<:AbstractArray,AbstractArray}","page":"Gridap.Arrays","title":"Gridap.Arrays.LocalToGlobalArray","text":"\n\n\n\n","category":"method"},{"location":"Arrays/#LocalToGlobalPosNegArray-1","page":"Gridap.Arrays","title":"LocalToGlobalPosNegArray","text":"","category":"section"},{"location":"Arrays/#","page":"Gridap.Arrays","title":"Gridap.Arrays","text":"LocalToGlobalPosNegArray\nLocalToGlobalPosNegArray(::AbstractArray{<:AbstractArray},::AbstractArray,::AbstractArray)","category":"page"},{"location":"Arrays/#Gridap.Arrays.LocalToGlobalPosNegArray","page":"Gridap.Arrays","title":"Gridap.Arrays.LocalToGlobalPosNegArray","text":"\n\n\n\n","category":"type"},{"location":"Arrays/#Gridap.Arrays.LocalToGlobalPosNegArray-Tuple{AbstractArray{var\"#s18\",N} where N where var\"#s18\"<:AbstractArray,AbstractArray,AbstractArray}","page":"Gridap.Arrays","title":"Gridap.Arrays.LocalToGlobalPosNegArray","text":"\n\n\n\n","category":"method"},{"location":"Arrays/#SubVector-1","page":"Gridap.Arrays","title":"SubVector","text":"","category":"section"},{"location":"Arrays/#","page":"Gridap.Arrays","title":"Gridap.Arrays","text":"SubVector","category":"page"},{"location":"Arrays/#Gridap.Arrays.SubVector","page":"Gridap.Arrays","title":"Gridap.Arrays.SubVector","text":"struct SubVector{T,A<:AbstractVector{T}} <: AbstractVector{T}\n  vector::A\n  pini::Int\n  pend::Int\nend\n\n\n\n\n\n","category":"type"},{"location":"Arrays/#Helpers-1","page":"Gridap.Arrays","title":"Helpers","text":"","category":"section"},{"location":"Arrays/#","page":"Gridap.Arrays","title":"Gridap.Arrays","text":"identity_vector(::Integer)","category":"page"},{"location":"Arrays/#Gridap.Arrays.identity_vector-Tuple{Integer}","page":"Gridap.Arrays","title":"Gridap.Arrays.identity_vector","text":"identity_vector(l::Integer)\n\n\n\n\n\n","category":"method"},{"location":"Inference/#","page":"Gridap.Inference","title":"Gridap.Inference","text":"CurrentModule = Gridap.Inference","category":"page"},{"location":"Inference/#Gridap.Inference-1","page":"Gridap.Inference","title":"Gridap.Inference","text":"","category":"section"},{"location":"Inference/#","page":"Gridap.Inference","title":"Gridap.Inference","text":"Inference\nreturn_type(f::Function,::Any...)\nreturn_type_broadcast\ntestargs\ntestargs_broadcast\ntestvalue\ntestvalues","category":"page"},{"location":"Inference/#Gridap.Inference","page":"Gridap.Inference","title":"Gridap.Inference","text":"This module provides a set of helper function to safely infer return types of functions.\n\nIn Gridap, we rely as less as possible in type inference. But, when needed, we adopt the following mechanism in order to compute returned types. We do not rely on the Base._return_type function.\n\nThis module exports following functions:\n\nreturn_type\nreturn_type_broadcast\ntestargs\ntestargs_broadcast\ntestvalue\ntestvalues\n\n\n\n\n\n","category":"module"},{"location":"Inference/#Gridap.Inference.return_type-Tuple{Function,Vararg{Any,N} where N}","page":"Gridap.Inference","title":"Gridap.Inference.return_type","text":"return_type(f::Function, Ts::Vararg{Any,N} where N) -> DataType\n\n\nReturns the type returned by function f when called with arguments of the types in Ts.\n\nThe underlying implementation uses the function testargs to generate some test values in order to call the function and determine the returned type. This mechanism does not use Base._return_type. One of the advantages is that the given function f is called, and thus, meaningful error messages will be displayed if there is any error in f.\n\n\n\n\n\n","category":"method"},{"location":"Inference/#Gridap.Inference.return_type_broadcast","page":"Gridap.Inference","title":"Gridap.Inference.return_type_broadcast","text":"return_type_broadcast(f::Function,Ts::DataType...) -> DataType\n\nLike return_type, but when function f is used in a broadcast operation.\n\n\n\n\n\n","category":"function"},{"location":"Inference/#Gridap.Inference.testargs","page":"Gridap.Inference","title":"Gridap.Inference.testargs","text":"testargs(f::Function,Ts::DataType...) -> Tuple\n\nReturns a tuple with valid arguments of the types in Ts in order to call function f. It defaults to testvalues(Ts...), see the testvalues function. The user can overload the testargs function for particular functions if the default test arguments are not in the domain of the function and a DomainError is raised.\n\nExamples\n\nFor the following function, the default test argument (which is a zero) is not in the domain. We can overload the testargs function to provide a valid test argument.\n\nusing Gridap.Inference\nimport Gridap.Inference: testargs\nfoo(x) = sqrt(x-1)\ntestargs(::typeof(foo),T::DataType) = (one(T),)\nreturn_type(foo, Int)\n# output\nFloat64\n\n\n\n\n\n","category":"function"},{"location":"Inference/#Gridap.Inference.testargs_broadcast","page":"Gridap.Inference","title":"Gridap.Inference.testargs_broadcast","text":"testargs_broadcast(f, Ts)\n\n\n\n\n\n\n","category":"function"},{"location":"Inference/#Gridap.Inference.testvalue","page":"Gridap.Inference","title":"Gridap.Inference.testvalue","text":"testvalue(::Type{T}) where T\n\nReturns an arbitrary instance of type T. It defaults to zero(T) for non-array types and to an empty array for array types. This function is used to compute the default test arguments in testargs. It can be overloaded for new types T if zero(T) does not makes sense.\n\n\n\n\n\n","category":"function"},{"location":"Inference/#Gridap.Inference.testvalues","page":"Gridap.Inference","title":"Gridap.Inference.testvalues","text":"testvalues(Ts::DataType...) -> Tuple\n\nReturns a tuple with test values for each of the types in Ts. Equivalent to map(testvalue,Ts).\n\n\n\n\n\n","category":"function"},{"location":"Gridap/#Gridap-1","page":"Gridap","title":"Gridap","text":"","category":"section"},{"location":"Gridap/#","page":"Gridap","title":"Gridap","text":"Gridap","category":"page"},{"location":"Gridap/#Gridap","page":"Gridap","title":"Gridap","text":"Gridap, grid-based approximation of PDEs in the Julia programming language\n\nThis module provides rich set of tools for the numerical solution of PDE, mainly based on finite element methods.\n\nThe module is structured in the following sub-modules:\n\nGridap.Helpers\nGridap.Inference\nGridap.Io\nGridap.Algebra\nGridap.TensorValues\nGridap.Arrays\nGridap.Fields\nGridap.Polynomials\nGridap.Integration\nGridap.ReferenceFEs\nGridap.CellData\nGridap.Geometry\nGridap.FESpaces\nGridap.MultiField\nGridap.Visualization\n\nThe exported names are:\n\nAffineFEOperator\nAffineFETerm\nBackslashSolver\nBoundaryTriangulation\nCartesianDiscreteModel\nCartesianGrid\nCellField\nCellQuadrature\nDiscreteModel\nDiscreteModelFromFile\nFEEnergy\nFEFunction\nFEOperator\nFESolver\nFESource\nFESpace\nFETerm\nGridapType\nHEX\nHEX8\nInterfaceTriangulation\nLUSolver\nLagrangianRefFE\nLinearFESolver\nLinearFETerm\nMultiFieldFESpace\nNLSolver\nPYRAMID\nPoint\nPolytope\nQPointCellField\nQUAD\nQUAD4\nRestrictedTriangulation\nSEG2\nSEGMENT\nSerendipityRefFE\nSkeletonTriangulation\nSparseMatrixCSR\nSymSparseMatrixCSR\nTET\nTET4\nTRI\nTRI3\nTensorValue\nTestFESpace\nTrialFESpace\nTriangulation\nVERTEX\nVERTEX1\nVectorValue\nWEDGE\nadd_tag!\nadd_tag_from_tags!\napply\narray_cache\ncreatevtk\ncross\ncurl\ndet\ndiagonal_tensor\ndivergence\ndot\nevaluate\nevaluate!\nget_array\nget_cell_coordinates\nget_cell_map\nget_coordinates\nget_dirichlet_values\nget_face_labeling\nget_free_values\nget_grid\nget_matrix\nget_normal_vector\nget_physical_coordinate\nget_triangulation\nget_vector\nget_weights\ngetindex!\ngradient\ninner\nintegrate\ninterpolate\ninterpolate_dirichlet\ninterpolate_everywhere\ninv\nis_P\nis_Q\nis_S\nis_affine\nis_first_order\nis_n_cube\nis_simplex\njump\nlaplacian\n@law\nmean\nnorm\nnum_cell_dims\nnum_cells\nnum_components\nnum_dims\nnum_dirichlet_dofs\nnum_dirichlet_tags\nnum_entities\nnum_free_dofs\nnum_point_dims\nnum_tags\nnumerical_setup\nnumerical_setup!\noperate\nouter\nprint_op_tree\nreindex\nrestrict\nsimplexify\nsolve\nsolve!\nsymbolic_setup\nsymmetric_gradient\ntr\nupdate_state_variables!\nwritevtk\nzero_initial_guess\n×\nΔ\nε\n∇\n⊗\n⊙\n⋅\n\n\n\n\n\n","category":"module"},{"location":"Algebra/#","page":"Gridap.Algebra","title":"Gridap.Algebra","text":"CurrentModule = Gridap.Algebra","category":"page"},{"location":"Algebra/#Gridap.Algebra-1","page":"Gridap.Algebra","title":"Gridap.Algebra","text":"","category":"section"},{"location":"Algebra/#","page":"Gridap.Algebra","title":"Gridap.Algebra","text":"Modules = [Algebra,]","category":"page"},{"location":"Algebra/#Gridap.Algebra","page":"Gridap.Algebra","title":"Gridap.Algebra","text":"The exported names are\n\nAffineOperator\nBackslashSolver\nLUSolver\nLinearSolver\nNLSolver\nNewtonRaphsonSolver\nNonlinearOperator\nNonlinearSolver\nNumericalSetup\nSparseMatrixCSR\nSymSparseMatrixCSR\nSymbolicSetup\nadd_entries!\nadd_entry!\nallocate_coo_vectors\nallocate_in_domain\nallocate_in_range\nallocate_jacobian\nallocate_matrix\nallocate_matrix_and_vector\nallocate_residual\nallocate_residual_and_jacobian\nallocate_vector\ncolvals\ncopy_entries!\ncreate_coo_vectors\nfill_entries!\nfinalize_coo!\nget_matrix\nget_vector\ngetindices\ngetptr\nhascolmajororder\nhasrowmajororder\nis_entry_stored\njacobian\njacobian!\nmuladd!\nnumerical_setup\nnumerical_setup!\npush_coo!\nresidual\nresidual!\nresidual_and_jacobian\nresidual_and_jacobian!\nscale_entries!\nsolve\nsolve!\nsparse_from_coo\nsparsecsr\nsymbolic_setup\nsymsparsecsr\ntest_linear_solver\ntest_nonlinear_operator\ntest_nonlinear_solver\nzero_initial_guess\n\n\n\n\n\n","category":"module"},{"location":"Algebra/#Gridap.Algebra.AffineOperator","page":"Gridap.Algebra","title":"Gridap.Algebra.AffineOperator","text":"struct AffineOperator{A<:AbstractMatrix,B<:AbstractVector} <: NonlinearOperator\n  matrix::A\n  vector::B\nend\n\n\n\n\n\n","category":"type"},{"location":"Algebra/#Gridap.Algebra.BackslashSolver","page":"Gridap.Algebra","title":"Gridap.Algebra.BackslashSolver","text":"struct BackslashSolver <: LinearSolver end\n\nWrapper of the backslash solver available in julia This is typically faster than LU for a single solve\n\n\n\n\n\n","category":"type"},{"location":"Algebra/#Gridap.Algebra.LUSolver","page":"Gridap.Algebra","title":"Gridap.Algebra.LUSolver","text":"struct LUSolver <: LinearSolver end\n\nWrapper of the LU solver available in julia\n\n\n\n\n\n","category":"type"},{"location":"Algebra/#Gridap.Algebra.LinearSolver","page":"Gridap.Algebra","title":"Gridap.Algebra.LinearSolver","text":"abstract type LinearSolver <: NonlinearSolver end\n\nsymbolic_setup(::LinearSolver,mat::AbstractMatrix)\ntest_linear_solver\n\n\n\n\n\n","category":"type"},{"location":"Algebra/#Gridap.Algebra.NLSolver","page":"Gridap.Algebra","title":"Gridap.Algebra.NLSolver","text":"struct NLSolver <: NonlinearSolver\n  # private fields\nend\n\nThe cache generated when using this solver has a field result that hosts the result object generated by the underlying nlsolve function. It corresponds to the most latest solve.\n\n\n\n\n\n","category":"type"},{"location":"Algebra/#Gridap.Algebra.NLSolver-Tuple{}","page":"Gridap.Algebra","title":"Gridap.Algebra.NLSolver","text":"NLSolver(ls::LinearSolver;kwargs...)\nNLSolver(;kwargs...)\n\nSame kwargs as in nlsolve. If ls is provided, it is not possible to use the linsolve kw-argument.\n\n\n\n\n\n","category":"method"},{"location":"Algebra/#Gridap.Algebra.NewtonRaphsonSolver","page":"Gridap.Algebra","title":"Gridap.Algebra.NewtonRaphsonSolver","text":"struct NewtonRaphsonSolver <:NonlinearSolver\n  # Private fields\nend\n\nVanilla Newton-Raphson method\n\n\n\n\n\n","category":"type"},{"location":"Algebra/#Gridap.Algebra.NonlinearOperator","page":"Gridap.Algebra","title":"Gridap.Algebra.NonlinearOperator","text":"abstract type NonlinearOperator <: GridapType end\n\nresidual!(b::AbstractVector,op::NonlinearOperator,x::AbstractVector)\njacobian!(A::AbstractMatrix,op::NonlinearOperator,x::AbstractVector)\nzero_initial_guess(op::NonlinearOperator)\nallocate_residual(op::NonlinearOperator,x::AbstractVector)\nallocate_jacobian(op::NonlinearOperator,x::AbstractVector)\n\n\n\n\n\n","category":"type"},{"location":"Algebra/#Gridap.Algebra.NonlinearSolver","page":"Gridap.Algebra","title":"Gridap.Algebra.NonlinearSolver","text":"abstract type NonlinearSolver <: GridapType end\n\nsolve!(x::AbstractVector,nls::NonlinearSolver,op::NonlinearOperator)\nsolve!(x::AbstractVector,nls::NonlinearSolver,op::NonlinearOperator, cache)\n\n\n\n\n\n","category":"type"},{"location":"Algebra/#Gridap.Algebra.NumericalSetup","page":"Gridap.Algebra","title":"Gridap.Algebra.NumericalSetup","text":"abstract type NumericalSetup <: GridapType end\n\nnumerical_setup!(::NumericalSetup,mat::AbstractMatrix)\nsolve!(x::AbstractVector,::NumericalSetup,b::AbstractVector)\n\n\n\n\n\n","category":"type"},{"location":"Algebra/#Gridap.Algebra.SparseMatrixCSR","page":"Gridap.Algebra","title":"Gridap.Algebra.SparseMatrixCSR","text":"struct SparseMatrixCSR{Bi,Tv,Ti<:Integer} <: AbstractSparseMatrix{Tv,Ti}\n\nMatrix type for storing Bi-based sparse matrices in the Compressed Sparse Row format. The standard way of constructing SparseMatrixCSR is through the sparsecsr function.\n\n\n\n\n\n","category":"type"},{"location":"Algebra/#Gridap.Algebra.SymSparseMatrixCSR","page":"Gridap.Algebra","title":"Gridap.Algebra.SymSparseMatrixCSR","text":"struct SymSparseMatrixCSR{T,Ti<:Integer} <: AbstractSparseMatrix{T,Ti}\n\nMatrix type for storing symmetric sparse matrices in the Compressed Sparse Row format. The standard way of constructing SparseMatrixCSR is through the  symsparsecsr function.\n\n\n\n\n\n","category":"type"},{"location":"Algebra/#Gridap.Algebra.SymbolicSetup","page":"Gridap.Algebra","title":"Gridap.Algebra.SymbolicSetup","text":"abstract type SymbolicSetup <: GridapType end\n\nnumerical_setup(::SymbolicSetup,mat::AbstractMatrix)\n\n\n\n\n\n","category":"type"},{"location":"Algebra/#Gridap.Algebra.add_entries!","page":"Gridap.Algebra","title":"Gridap.Algebra.add_entries!","text":"add_entries!(a,b,combine=+)\n\nPerform the operation combine element-wise in the entries of arrays a and b and store the result in array a. Returns a.\n\n\n\n\n\n","category":"function"},{"location":"Algebra/#Gridap.Algebra.add_entry!","page":"Gridap.Algebra","title":"Gridap.Algebra.add_entry!","text":"add_entry!(A,v,i,j,combine=+)\n\nAdd an entry given its position and the operation to perform.\n\n\n\n\n\n","category":"function"},{"location":"Algebra/#Gridap.Algebra.add_entry!","page":"Gridap.Algebra","title":"Gridap.Algebra.add_entry!","text":"add_entry!(A,v,i,combine=+)\n\nAdd an entry given its position and the operation to perform.\n\n\n\n\n\n","category":"function"},{"location":"Algebra/#Gridap.Algebra.allocate_coo_vectors-Union{Tuple{M}, Tuple{Type{M},Integer}} where M","page":"Gridap.Algebra","title":"Gridap.Algebra.allocate_coo_vectors","text":"\n\n\n\n","category":"method"},{"location":"Algebra/#Gridap.Algebra.allocate_in_domain-Union{Tuple{V}, Tuple{Type{V},Any}} where V","page":"Gridap.Algebra","title":"Gridap.Algebra.allocate_in_domain","text":"allocate_in_domain(::Type{V},matrix) where V\n\nAllocate a vector of type V in the domain of matrix matrix.\n\n\n\n\n\n","category":"method"},{"location":"Algebra/#Gridap.Algebra.allocate_in_range-Union{Tuple{V}, Tuple{Type{V},Any}} where V","page":"Gridap.Algebra","title":"Gridap.Algebra.allocate_in_range","text":"allocate_in_range(::Type{V},matrix) where V\n\nAllocate a vector of type V in the range of matrix matrix.\n\n\n\n\n\n","category":"method"},{"location":"Algebra/#Gridap.Algebra.allocate_jacobian-Tuple{Gridap.Algebra.NonlinearOperator,AbstractArray{T,1} where T}","page":"Gridap.Algebra","title":"Gridap.Algebra.allocate_jacobian","text":"allocate_jacobian(op::NonlinearOperator,x::AbstractVector)\n\n\n\n\n\n","category":"method"},{"location":"Algebra/#Gridap.Algebra.allocate_residual-Tuple{Gridap.Algebra.NonlinearOperator,AbstractArray{T,1} where T}","page":"Gridap.Algebra","title":"Gridap.Algebra.allocate_residual","text":"allocate_residual(op::NonlinearOperator,x::AbstractVector)\n\n\n\n\n\n","category":"method"},{"location":"Algebra/#Gridap.Algebra.allocate_residual_and_jacobian-Tuple{Gridap.Algebra.NonlinearOperator,AbstractArray{T,1} where T}","page":"Gridap.Algebra","title":"Gridap.Algebra.allocate_residual_and_jacobian","text":"allocate_residual_and_jacobian(op::NonlinearOperator,x::AbstractVector)\n\n\n\n\n\n","category":"method"},{"location":"Algebra/#Gridap.Algebra.allocate_vector-Union{Tuple{V}, Tuple{Type{V},Any}} where V","page":"Gridap.Algebra","title":"Gridap.Algebra.allocate_vector","text":"allocate_vector(::Type{V},indices) where V\n\nAllocate a vector of type V indexable at the indices indices\n\n\n\n\n\n","category":"method"},{"location":"Algebra/#Gridap.Algebra.colvals-Tuple{SparseArrays.AbstractSparseArray{Tv,Ti,2} where Ti where Tv}","page":"Gridap.Algebra","title":"Gridap.Algebra.colvals","text":"colvals(S::AbstractSparseMatrix)\n\nReturn columns indices or raises an error (Depending on the SparseMatrix type)\n\n\n\n\n\n","category":"method"},{"location":"Algebra/#Gridap.Algebra.copy_entries!-Tuple{Any,Any}","page":"Gridap.Algebra","title":"Gridap.Algebra.copy_entries!","text":"copy_entries!(a,b)\n\nCopy the entries of array b into array a. Returns a.\n\n\n\n\n\n","category":"method"},{"location":"Algebra/#Gridap.Algebra.fill_entries!-Tuple{Any,Any}","page":"Gridap.Algebra","title":"Gridap.Algebra.fill_entries!","text":"fill_entries!(a,v)\n\nFill the entries of array a with the value v. Returns a.\n\n\n\n\n\n","category":"method"},{"location":"Algebra/#Gridap.Algebra.fill_entries!-Tuple{SparseArrays.AbstractSparseArray{Tv,Ti,2} where Ti where Tv,Any}","page":"Gridap.Algebra","title":"Gridap.Algebra.fill_entries!","text":"fill_entries!(A::AbstractSparseMatrix,v)\n\nFills the non-zero entries in the sparse matrix A with a given value v.\n\n\n\n\n\n","category":"method"},{"location":"Algebra/#Gridap.Algebra.finalize_coo!-Tuple{Type{T} where T,Any,Any,Any,Any,Any}","page":"Gridap.Algebra","title":"Gridap.Algebra.finalize_coo!","text":"finalize_coo!(::Type{T} where T,I,J,V,m,n)\n\nCheck and insert diagonal entries in COO vectors if needed.\n\n\n\n\n\n","category":"method"},{"location":"Algebra/#Gridap.Algebra.get_matrix-Tuple{Gridap.Algebra.AffineOperator}","page":"Gridap.Algebra","title":"Gridap.Algebra.get_matrix","text":"get_matrix(operator)\n\nReturn the matrix corresponding to the assembled left hand side of the operator. This matrix incorporates all boundary conditions and constraints.\n\n\n\n\n\n","category":"method"},{"location":"Algebra/#Gridap.Algebra.get_vector-Tuple{Gridap.Algebra.AffineOperator}","page":"Gridap.Algebra","title":"Gridap.Algebra.get_vector","text":"get_vector(operator)\n\nReturn the vector corresponding to the assembled right hand side of the operator. This vector includes all boundary conditions and constraints.\n\n\n\n\n\n","category":"method"},{"location":"Algebra/#Gridap.Algebra.getindices-Tuple{SparseArrays.AbstractSparseArray{Tv,Ti,2} where Ti where Tv}","page":"Gridap.Algebra","title":"Gridap.Algebra.getindices","text":"getindices(S::AbstractSparseMatrix)\n\nReturn row indices.\n\n\n\n\n\n","category":"method"},{"location":"Algebra/#Gridap.Algebra.getptr-Tuple{SparseArrays.AbstractSparseArray{Tv,Ti,2} where Ti where Tv}","page":"Gridap.Algebra","title":"Gridap.Algebra.getptr","text":"getptr(S::AbstractSparseMatrix)\n\nReturn columns pointer.\n\n\n\n\n\n","category":"method"},{"location":"Algebra/#Gridap.Algebra.hascolmajororder-Tuple{Type{SparseArrays.AbstractSparseArray{Tv,Ti,2} where Ti where Tv}}","page":"Gridap.Algebra","title":"Gridap.Algebra.hascolmajororder","text":"hascolmajororder(::Type{AbstractSparseMatrix})\n\nCheck if values are stored in col-major order. Return true.\n\n\n\n\n\n","category":"method"},{"location":"Algebra/#Gridap.Algebra.hasrowmajororder-Tuple{Type{SparseArrays.AbstractSparseArray{Tv,Ti,2} where Ti where Tv}}","page":"Gridap.Algebra","title":"Gridap.Algebra.hasrowmajororder","text":"hasrowmajororder(::Type{AbstractSparseMatrix})\n\nCheck if values are stored in row-major order. Return false.\n\n\n\n\n\n","category":"method"},{"location":"Algebra/#Gridap.Algebra.is_entry_stored-Tuple{Type{T} where T,Any,Any}","page":"Gridap.Algebra","title":"Gridap.Algebra.is_entry_stored","text":"is_entry_stored(::Type{T} where T,i,j) -> Bool\n\nTells if the entry with coordinates [i,j] will be stored when calling function push_coo!\n\n\n\n\n\n","category":"method"},{"location":"Algebra/#Gridap.Algebra.jacobian!-Tuple{AbstractArray{T,2} where T,Gridap.Algebra.NonlinearOperator,AbstractArray{T,1} where T}","page":"Gridap.Algebra","title":"Gridap.Algebra.jacobian!","text":"jacobian!(A::AbstractMatrix,op::NonlinearOperator,x::AbstractVector)\n\n\n\n\n\n","category":"method"},{"location":"Algebra/#Gridap.Algebra.jacobian-Tuple{Gridap.Algebra.NonlinearOperator,AbstractArray{T,1} where T}","page":"Gridap.Algebra","title":"Gridap.Algebra.jacobian","text":"jacobian(op::NonlinearOperator,x::AbstractVector)\n\n\n\n\n\n","category":"method"},{"location":"Algebra/#Gridap.Algebra.muladd!-Tuple{Any,Any,Any}","page":"Gridap.Algebra","title":"Gridap.Algebra.muladd!","text":"muladd!(c,a,b)\n\nMatrix multiply a*b and add to result to c. Returns c.\n\n\n\n\n\n","category":"method"},{"location":"Algebra/#Gridap.Algebra.numerical_setup!-Tuple{Gridap.Algebra.NumericalSetup,AbstractArray{T,2} where T}","page":"Gridap.Algebra","title":"Gridap.Algebra.numerical_setup!","text":"numerical_setup!(::NumericalSetup,mat::AbstractMatrix)\n\n\n\n\n\n","category":"method"},{"location":"Algebra/#Gridap.Algebra.numerical_setup-Tuple{Gridap.Algebra.SymbolicSetup,AbstractArray{T,2} where T}","page":"Gridap.Algebra","title":"Gridap.Algebra.numerical_setup","text":"numerical_setup(::SymbolicSetup,mat::AbstractMatrix) -> NumericalSetup\n\n\n\n\n\n","category":"method"},{"location":"Algebra/#Gridap.Algebra.push_coo!-Tuple{Type{T} where T,Any,Any,Any,Any,Any,Any}","page":"Gridap.Algebra","title":"Gridap.Algebra.push_coo!","text":"push_coo!(::Type{T} where T, I,J,V,ik,jk,vk)\n\nInserts entries in COO vectors for further building a sparse matrix of type T.\n\n\n\n\n\n","category":"method"},{"location":"Algebra/#Gridap.Algebra.residual!-Tuple{AbstractArray{T,1} where T,Gridap.Algebra.NonlinearOperator,AbstractArray{T,1} where T}","page":"Gridap.Algebra","title":"Gridap.Algebra.residual!","text":"residual!(b::AbstractVector,op::NonlinearOperator,x::AbstractVector)\n\n\n\n\n\n","category":"method"},{"location":"Algebra/#Gridap.Algebra.residual-Tuple{Gridap.Algebra.NonlinearOperator,AbstractArray{T,1} where T}","page":"Gridap.Algebra","title":"Gridap.Algebra.residual","text":"residual(op::NonlinearOperator,x::AbstractVector)\n\n\n\n\n\n","category":"method"},{"location":"Algebra/#Gridap.Algebra.residual_and_jacobian!-Tuple{AbstractArray{T,1} where T,AbstractArray{T,2} where T,Gridap.Algebra.NonlinearOperator,AbstractArray{T,1} where T}","page":"Gridap.Algebra","title":"Gridap.Algebra.residual_and_jacobian!","text":"residual_and_jacobian!(\n  b::AbstractVector, A::AbstractMatrix,\n  op::NonlinearOperator, x::AbstractVector)\n\n\n\n\n\n","category":"method"},{"location":"Algebra/#Gridap.Algebra.residual_and_jacobian-Tuple{Gridap.Algebra.NonlinearOperator,AbstractArray{T,1} where T}","page":"Gridap.Algebra","title":"Gridap.Algebra.residual_and_jacobian","text":"residual_and_jacobian(op::NonlinearOperator,x::AbstractVector)\n\n\n\n\n\n","category":"method"},{"location":"Algebra/#Gridap.Algebra.scale_entries!-Tuple{Any,Any}","page":"Gridap.Algebra","title":"Gridap.Algebra.scale_entries!","text":"scale_entries!(a,v)\n\nScale the entries of array a with the value v. Returns a.\n\n\n\n\n\n","category":"method"},{"location":"Algebra/#Gridap.Algebra.solve!-Tuple{AbstractArray{T,1} where T,Gridap.Algebra.LinearSolver,Gridap.Algebra.AffineOperator,Any,Bool}","page":"Gridap.Algebra","title":"Gridap.Algebra.solve!","text":"solve!(\n  x::AbstractVector,\n  ls::LinearSolver,\n  op::AffineOperator,\n  cache,\n  newmatrix::Bool)\n\n\n\n\n\n","category":"method"},{"location":"Algebra/#Gridap.Algebra.solve!-Tuple{AbstractArray{T,1} where T,Gridap.Algebra.NonlinearSolver,Gridap.Algebra.NonlinearOperator,Any}","page":"Gridap.Algebra","title":"Gridap.Algebra.solve!","text":"solve!(x::AbstractVector,nls::NonlinearSolver,op::NonlinearOperator,cache)\n\nSolve using the cache object from a previous solve.\n\n\n\n\n\n","category":"method"},{"location":"Algebra/#Gridap.Algebra.solve!-Tuple{AbstractArray{T,1} where T,Gridap.Algebra.NonlinearSolver,Gridap.Algebra.NonlinearOperator}","page":"Gridap.Algebra","title":"Gridap.Algebra.solve!","text":"solve!(x::AbstractVector,nls::NonlinearSolver,op::NonlinearOperator)\n\nUsage:\n\ncache = solve!(x,nls,op)\n\nThe returned cache object can be used in subsequent solves:\n\ncache = solve!(x,nls,op,cache)\n\n\n\n\n\n","category":"method"},{"location":"Algebra/#Gridap.Algebra.solve!-Tuple{AbstractArray{T,1} where T,Gridap.Algebra.NumericalSetup,AbstractArray{T,1} where T}","page":"Gridap.Algebra","title":"Gridap.Algebra.solve!","text":"solve!(x::AbstractVector,::NumericalSetup,b::AbstractVector)\n\n\n\n\n\n","category":"method"},{"location":"Algebra/#Gridap.Algebra.solve-Tuple{Gridap.Algebra.LinearSolver,AbstractArray{T,2} where T,AbstractArray{T,1} where T}","page":"Gridap.Algebra","title":"Gridap.Algebra.solve","text":"solve(ls::LinearSolver,A::AbstractMatrix,b::AbstractVector)\n\n\n\n\n\n","category":"method"},{"location":"Algebra/#Gridap.Algebra.solve-Tuple{Gridap.Algebra.NonlinearSolver,Gridap.Algebra.NonlinearOperator}","page":"Gridap.Algebra","title":"Gridap.Algebra.solve","text":"solve(nls::NonlinearSolver,op::NonlinearOperator)\n\nCreates and uses a zero initial guess.\n\n\n\n\n\n","category":"method"},{"location":"Algebra/#Gridap.Algebra.sparse_from_coo-Tuple{Type{T} where T,Any,Any,Any,Any,Any}","page":"Gridap.Algebra","title":"Gridap.Algebra.sparse_from_coo","text":"sparse_from_coo(::Type{T} where T,I,J,V,m,n)\n\n\n\n\n\n","category":"method"},{"location":"Algebra/#Gridap.Algebra.sparsecsr-Tuple{Any,Any,Any,Any,Any,Vararg{Any,N} where N}","page":"Gridap.Algebra","title":"Gridap.Algebra.sparsecsr","text":"sparsecsr(args...)\n\nSame args than sparse.\n\n\n\n\n\n","category":"method"},{"location":"Algebra/#Gridap.Algebra.symbolic_setup-Tuple{Gridap.Algebra.LinearSolver,AbstractArray{T,2} where T}","page":"Gridap.Algebra","title":"Gridap.Algebra.symbolic_setup","text":"symbolic_setup(::LinearSolver,mat::AbstractMatrix) -> SymbolicSetup\n\n\n\n\n\n","category":"method"},{"location":"Algebra/#Gridap.Algebra.symsparsecsr-Tuple{Any,Any,Any,Vararg{Any,N} where N}","page":"Gridap.Algebra","title":"Gridap.Algebra.symsparsecsr","text":"symsparsecsr(args...)\n\nSame args than sparse.\n\n\n\n\n\n","category":"method"},{"location":"Algebra/#Gridap.Algebra.test_linear_solver-Tuple{Gridap.Algebra.LinearSolver,AbstractArray{T,2} where T,AbstractArray{T,1} where T,AbstractArray{T,1} where T}","page":"Gridap.Algebra","title":"Gridap.Algebra.test_linear_solver","text":"test_linear_solver(\n  ls::LinearSolver,\n  A::AbstractMatrix,\n  b::AbstractVector,\n  x::AbstractVector)\n\n\n\n\n\n","category":"method"},{"location":"Algebra/#Gridap.Algebra.test_nonlinear_operator","page":"Gridap.Algebra","title":"Gridap.Algebra.test_nonlinear_operator","text":"test_nonlinear_operator(\n  op::NonlinearOperator,\n  x::AbstractVector,\n  b::AbstractVector,\n  pred=isapprox;\n  jac=nothing)\n\n\n\n\n\n","category":"function"},{"location":"Algebra/#Gridap.Algebra.test_nonlinear_solver","page":"Gridap.Algebra","title":"Gridap.Algebra.test_nonlinear_solver","text":"test_nonlinear_solver(\n  nls::NonlinearSolver,\n  op::NonlinearOperator,\n  x0::AbstractVector,\n  x::AbstractVector,\n  pred::Function=isapprox)\n\n\n\n\n\n","category":"function"},{"location":"Algebra/#Gridap.Algebra.zero_initial_guess-Tuple{Gridap.Algebra.NonlinearOperator}","page":"Gridap.Algebra","title":"Gridap.Algebra.zero_initial_guess","text":"zero_initial_guess(op::NonlinearOperator)\n\n\n\n\n\n","category":"method"},{"location":"Algebra/#Base.convert-Tuple{Type{SparseArrays.AbstractSparseArray{Tv,Ti,2} where Ti where Tv},SparseArrays.AbstractSparseArray{Tv,Ti,2} where Ti where Tv}","page":"Gridap.Algebra","title":"Base.convert","text":"convert(::Type{AbstractSparseMatrix}, x::AbstractSparseMatrix)\n\nConvert x to a value of the first type given.\n\n\n\n\n\n","category":"method"},{"location":"Algebra/#Base.count-Tuple{Any,SparseArrays.AbstractSparseArray{Tv,Ti,2} where Ti where Tv}","page":"Gridap.Algebra","title":"Base.count","text":"count(pred, S::AbstractSparseMatrix) -> Integer\n\nCount the number of elements in nonzeros(S) for which predicate pred returns true. \n\n\n\n\n\n","category":"method"},{"location":"Algebra/#SparseArrays.findnz-Tuple{SparseArrays.AbstractSparseArray{Tv,Ti,2} where Ti where Tv}","page":"Gridap.Algebra","title":"SparseArrays.findnz","text":"findnz(S::AbstractSparseMatrix)\n\nReturn a tuple (I, J, V) where I and J are the row and column indices  of the stored (\"structurally non-zero\") values in sparse matrix A,  and V is a vector of the values.\n\n\n\n\n\n","category":"method"},{"location":"Algebra/#SparseArrays.nnz-Tuple{SparseArrays.AbstractSparseArray{Tv,Ti,2} where Ti where Tv}","page":"Gridap.Algebra","title":"SparseArrays.nnz","text":"nnz(S::AbstractSparseMatrix)\n\nReturns the number of stored (filled) elements in a sparse array.\n\n\n\n\n\n","category":"method"},{"location":"Algebra/#SparseArrays.nonzeros-Tuple{SparseArrays.AbstractSparseArray{Tv,Ti,2} where Ti where Tv}","page":"Gridap.Algebra","title":"SparseArrays.nonzeros","text":"nonzeros(S::AbstractSparseMatrix)\n\nReturn a vector of the structural nonzero values in sparse array S.  This includes zeros that are explicitly stored in the sparse array.  The returned vector points directly to the internal nonzero storage of S,  and any modifications to the returned vector will mutate S as well.\n\n\n\n\n\n","category":"method"},{"location":"Algebra/#SparseArrays.nzrange-Tuple{SparseArrays.AbstractSparseArray{Tv,Ti,2} where Ti where Tv,Integer}","page":"Gridap.Algebra","title":"SparseArrays.nzrange","text":"nzrange(S::AbstractSparseMatrix, index::Integer) where {Bi}\n\nReturn the range of indices to the structural nonzero values of a  sparse matrix index (Row or column depending on the compression type). \n\n\n\n\n\n","category":"method"},{"location":"Algebra/#SparseArrays.rowvals-Tuple{SparseArrays.AbstractSparseArray{Tv,Ti,2} where Ti where Tv}","page":"Gridap.Algebra","title":"SparseArrays.rowvals","text":"rowvals(S::AbstractSparseMatrix)\n\nReturn row indices or raises an error (Depending on the SparseMatrix type)\n\n\n\n\n\n","category":"method"},{"location":"Io/#","page":"Gridap.Io","title":"Gridap.Io","text":"CurrentModule = Gridap.Io","category":"page"},{"location":"Io/#Gridap.Io-1","page":"Gridap.Io","title":"Gridap.Io","text":"","category":"section"},{"location":"Io/#","page":"Gridap.Io","title":"Gridap.Io","text":"Modules = [Io,]","category":"page"},{"location":"Io/#Gridap.Io","page":"Gridap.Io","title":"Gridap.Io","text":"The exported names in this module are:\n\nfrom_bson_file\nfrom_dict\nfrom_jld2_file\nfrom_json\nfrom_json_file\nto_bson_file\nto_dict\nto_jld2_file\nto_json\nto_json_file\n\n\n\n\n\n","category":"module"},{"location":"Io/#Gridap.Io.from_bson_file-Union{Tuple{T}, Tuple{Type{T},AbstractString}} where T","page":"Gridap.Io","title":"Gridap.Io.from_bson_file","text":"function from_bson_file(::Type{T},s::AbstractString) where T\n\n\n\n\n\n","category":"method"},{"location":"Io/#Gridap.Io.from_dict-Union{Tuple{T}, Tuple{Type{T},Dict}} where T","page":"Gridap.Io","title":"Gridap.Io.from_dict","text":"from_dict(::Type{T},dict::Dict) where T\n\nDe-serialize an object of type T from the dictionary dict. Values stored into this dictionary must be of any native  Julia data type (Real, Integer, String, etc.) Dictionary keys are Symbols.\n\n\n\n\n\n","category":"method"},{"location":"Io/#Gridap.Io.from_jld2_file","page":"Gridap.Io","title":"Gridap.Io.from_jld2_file","text":"function from_jld2_file(filename::AbstractString,dataset::AbstractString=\"data\")\n\nLoads an object from a JLD2 file given its filename and, optionally, the dataset name. The dataset specifies the name and the root location of the data inside the generated JLD2 file.\n\n\n\n\n\n","category":"function"},{"location":"Io/#Gridap.Io.from_jld2_file-Union{Tuple{T}, Tuple{Type{T},AbstractString}, Tuple{Type{T},AbstractString,AbstractString}} where T","page":"Gridap.Io","title":"Gridap.Io.from_jld2_file","text":"function from_jld2_file(::Type{T},filename::AbstractString,dataset::AbstractString=\"data\") where T\n\nLoads an object from a JLD2 file given its filename and, optionally, the dataset name. The dataset specifies the name and the root location of the data inside the generated JLD2 file. Checks if the returned object is of the expected Type{T}, if not return error.\n\n\n\n\n\n","category":"method"},{"location":"Io/#Gridap.Io.from_json-Union{Tuple{T}, Tuple{Type{T},AbstractString}} where T","page":"Gridap.Io","title":"Gridap.Io.from_json","text":"from_json(::Type{T},s::AbstractString) where T\n\n\n\n\n\n","category":"method"},{"location":"Io/#Gridap.Io.from_json_file-Union{Tuple{T}, Tuple{Type{T},AbstractString}} where T","page":"Gridap.Io","title":"Gridap.Io.from_json_file","text":"from_json_file(::Type{T},s::AbstractString) where T\n\n\n\n\n\n","category":"method"},{"location":"Io/#Gridap.Io.to_bson_file-Tuple{Any,Any}","page":"Gridap.Io","title":"Gridap.Io.to_bson_file","text":"to_bson_file(object,filename)\n\n\n\n\n\n","category":"method"},{"location":"Io/#Gridap.Io.to_dict-Tuple{Any}","page":"Gridap.Io","title":"Gridap.Io.to_dict","text":"to_dict(object) -> Dict\n\nSerialize object into a dictionary of type Dict{Symbol,Any}. Values stored into this dictionary must be of any native  Julia data type (Real, Integer, String, etc.) Dictionary keys are Symbols.\n\n\n\n\n\n","category":"method"},{"location":"Io/#Gridap.Io.to_jld2_file","page":"Gridap.Io","title":"Gridap.Io.to_jld2_file","text":"function to_jld2_file(object,filename::AbstractString,dataset::AbstractString=\"data\")\n\nStores an object to a JLD2 file given its filename and, optionally, the dataset name. The dataset specifies the name and the root location of the data inside the JLD2 file.\n\n\n\n\n\n","category":"function"},{"location":"Io/#Gridap.Io.to_json-Tuple{Any}","page":"Gridap.Io","title":"Gridap.Io.to_json","text":"to_json(object)\n\n\n\n\n\n","category":"method"},{"location":"Io/#Gridap.Io.to_json_file-Tuple{Any,Any}","page":"Gridap.Io","title":"Gridap.Io.to_json_file","text":"to_json_file(object,filename)\n\n\n\n\n\n","category":"method"},{"location":"Io/#Gridap.Io.check_dict-Union{Tuple{T}, Tuple{Type{T},Dict}} where T","page":"Gridap.Io","title":"Gridap.Io.check_dict","text":"check_dict(::Type{T},dict::Dict) where T\n\nCheck validity of a dictionary dict for an object of type T. It runs succesfully if the dictionary is valid for a particular  type or throws an error in any other case.\n\n\n\n\n\n","category":"method"},{"location":"Polynomials/#","page":"Gridap.Polynomials","title":"Gridap.Polynomials","text":"CurrentModule = Gridap.Polynomials","category":"page"},{"location":"Polynomials/#Gridap.Polynomials-1","page":"Gridap.Polynomials","title":"Gridap.Polynomials","text":"","category":"section"},{"location":"Polynomials/#","page":"Gridap.Polynomials","title":"Gridap.Polynomials","text":"Modules = [Polynomials,]","category":"page"},{"location":"Polynomials/#Gridap.Polynomials","page":"Gridap.Polynomials","title":"Gridap.Polynomials","text":"This module provides a collection of multivariate polynomial bases.\n\nThe exported names are:\n\nMonomialBasis\nQCurlGradMonomialBasis\nQGradMonomialBasis\nchange_basis\nget_exponents\nget_order\nget_orders\nget_value_type\nnum_terms\n\n\n\n\n\n","category":"module"},{"location":"Polynomials/#Gridap.Polynomials.MonomialBasis","page":"Gridap.Polynomials","title":"Gridap.Polynomials.MonomialBasis","text":"struct MonomialBasis{D,T} <: Field\n\nType representing a basis of multivariate scalar-valued, vector-valued, or tensor-valued, iso- or aniso-tropic monomials. The fields of this struct are not public   This type fully implements the Field interface, with up to second order derivatives.\n\n\n\n\n\n","category":"type"},{"location":"Polynomials/#Gridap.Polynomials.MonomialBasis-Union{Tuple{T}, Tuple{D}, Tuple{Type{T},Int64}, Tuple{Type{T},Int64,Function}} where T where D","page":"Gridap.Polynomials","title":"Gridap.Polynomials.MonomialBasis","text":"MonomialBasis{D}(::Type{T}, order::Int [, filter::Function]) where {D,T}\n\nReturns an instance of MonomialBasis representing a multivariate polynomial basis in D dimensions, of polynomial degree order, whose value is represented by the type T. The type T is typically <:Number, e.g., Float64 for scalar-valued functions and VectorValue{D,Float64} for vector-valued ones.\n\nFilter function\n\nThe filter function is used to select which terms of the tensor product space of order order in D dimensions are to be used. If the filter is not provided, the full tensor-product space is used by default leading to a multivariate polynomial space of type Q. The signature of the filter function is\n\n(e,order) -> Bool\n\nwhere e is a tuple of D integers containing the exponents of a multivariate monomial. The following filters are used to select well known polynomial spaces\n\nQ space: (e,order) -> true\nP space: (e,order) -> sum(e) <= order\n\"Serendipity\" space: (e,order) -> sum( [ i for i in e if i>1 ] ) <= order\n\n\n\n\n\n","category":"method"},{"location":"Polynomials/#Gridap.Polynomials.MonomialBasis-Union{Tuple{T}, Tuple{D}, Tuple{Type{T},Tuple{Vararg{Int64,D}}}, Tuple{Type{T},Tuple{Vararg{Int64,D}},Function}} where T where D","page":"Gridap.Polynomials","title":"Gridap.Polynomials.MonomialBasis","text":"MonomialBasis{D}(::Type{T}, orders::Tuple [, filter::Function]) where {D,T}\n\nThis version of the constructor allows to pass a tuple orders containing the polynomial order to be used in each of the D dimensions in order to  construct and anisotropic tensor-product space.\n\n\n\n\n\n","category":"method"},{"location":"Polynomials/#Gridap.Polynomials.QCurlGradMonomialBasis","page":"Gridap.Polynomials","title":"Gridap.Polynomials.QCurlGradMonomialBasis","text":"struct QCurlGradMonomialBasis{...} <: Field\n\nThis type implements a multivariate vector-valued polynomial basis spanning the space needed for Raviart-Thomas reference elements on n-cubes. The type parameters and fields of this struct are not public. This type fully implements the Field interface, with up to first order derivatives.\n\n\n\n\n\n","category":"type"},{"location":"Polynomials/#Gridap.Polynomials.QCurlGradMonomialBasis-Union{Tuple{T}, Tuple{D}, Tuple{Type{T},Int64}} where T where D","page":"Gridap.Polynomials","title":"Gridap.Polynomials.QCurlGradMonomialBasis","text":"QCurlGradMonomialBasis{D}(::Type{T},order::Int) where {D,T}\n\nReturns a QCurlGradMonomialBasis object. D is the dimension of the coordinate space and T is the type of the components in the vector-value. The order argument has the following meaning: the divergence of the  functions in this basis is in the Q space of degree order.\n\n\n\n\n\n","category":"method"},{"location":"Polynomials/#Gridap.Polynomials.QGradMonomialBasis","page":"Gridap.Polynomials","title":"Gridap.Polynomials.QGradMonomialBasis","text":"struct QGradMonomialBasis{...} <: Field\n\nThis type implements a multivariate vector-valued polynomial basis spanning the space needed for Nedelec reference elements on n-cubes. The type parameters and fields of this struct are not public.   This type fully implements the Field interface, with up to first order derivatives.\n\n\n\n\n\n","category":"type"},{"location":"Polynomials/#Gridap.Polynomials.QGradMonomialBasis-Union{Tuple{T}, Tuple{D}, Tuple{Type{T},Int64}} where T where D","page":"Gridap.Polynomials","title":"Gridap.Polynomials.QGradMonomialBasis","text":"QGradMonomialBasis{D}(::Type{T},order::Int) where {D,T}\n\nReturns a QGradMonomialBasis object. D is the dimension of the coordinate space and T is the type of the components in the vector-value. The order argument has the following meaning: the curl of the  functions in this basis is in the Q space of degree order.\n\n\n\n\n\n","category":"method"},{"location":"Polynomials/#Gridap.Polynomials.change_basis-Tuple{Any,AbstractArray{T,2} where T}","page":"Gridap.Polynomials","title":"Gridap.Polynomials.change_basis","text":"change_basis(basis,changeofbasis::AbstractMatrix)\n\nExamples\n\nCompute the Lagrangian basis associated with a set of nodes\n\nusing LinearAlgebra\nusing Gridap.Fields\nusing Gridap.Polynomials\n\nD = 2\norder = 1\nf = MonomialBasis{D}(Float64,order)\n\nnodes = Point{2,Int}[(0,0),(1,0),(0,1),(1,1)]\nchange = inv(evaluate(f,nodes))\n\ng = change_basis(f,change)\nprintln(evaluate(g,nodes))\n\n# output\n[1.0 0.0 0.0 0.0; 0.0 1.0 0.0 0.0; 0.0 0.0 1.0 0.0; 0.0 0.0 0.0 1.0]\n\n\n\n\n\n\n","category":"method"},{"location":"Polynomials/#Gridap.Polynomials.get_exponents-Tuple{Gridap.Polynomials.MonomialBasis}","page":"Gridap.Polynomials","title":"Gridap.Polynomials.get_exponents","text":"get_exponents(b::MonomialBasis)\n\nGet a vector of tuples with the exponents of all the terms in the monomial basis.\n\nExamples\n\nusing Gridap.Polynomials\n\nb = MonomialBasis{2}(Float64,2)\n\nexponents = get_exponents(b)\n\nprintln(exponents)\n\n# output\nTuple{Int64,Int64}[(0, 0), (1, 0), (2, 0), (0, 1), (1, 1), (2, 1), (0, 2), (1, 2), (2, 2)]\n\n\n\n\n\n","category":"method"},{"location":"Polynomials/#Gridap.Polynomials.get_order-Tuple{Gridap.Polynomials.MonomialBasis}","page":"Gridap.Polynomials","title":"Gridap.Polynomials.get_order","text":"get_order(b::MonomialBasis)\n\n\n\n\n\n","category":"method"},{"location":"Polynomials/#Gridap.Polynomials.get_orders-Tuple{Gridap.Polynomials.MonomialBasis}","page":"Gridap.Polynomials","title":"Gridap.Polynomials.get_orders","text":"get_orders(b::MonomialBasis)\n\n\n\n\n\n","category":"method"},{"location":"Polynomials/#Gridap.Polynomials.get_value_type-Union{Tuple{Gridap.Polynomials.MonomialBasis{D,T}}, Tuple{T}, Tuple{D}} where T where D","page":"Gridap.Polynomials","title":"Gridap.Polynomials.get_value_type","text":"\n\n\n\n","category":"method"},{"location":"Polynomials/#Gridap.Polynomials.num_terms-Union{Tuple{Gridap.Polynomials.QCurlGradMonomialBasis{D,T}}, Tuple{T}, Tuple{D}} where T where D","page":"Gridap.Polynomials","title":"Gridap.Polynomials.num_terms","text":"num_terms(f::QCurlGradMonomialBasis{D,T}) where {D,T}\n\n\n\n\n\n","category":"method"},{"location":"Polynomials/#Gridap.Polynomials.num_terms-Union{Tuple{Gridap.Polynomials.QGradMonomialBasis{D,T}}, Tuple{T}, Tuple{D}} where T where D","page":"Gridap.Polynomials","title":"Gridap.Polynomials.num_terms","text":"num_terms(f::QGradMonomialBasis{D,T}) where {D,T}\n\n\n\n\n\n","category":"method"},{"location":"Integration/#","page":"Gridap.Integration","title":"Gridap.Integration","text":"CurrentModule = Gridap.Integration","category":"page"},{"location":"Integration/#Gridap.Integration-1","page":"Gridap.Integration","title":"Gridap.Integration","text":"","category":"section"},{"location":"Integration/#","page":"Gridap.Integration","title":"Gridap.Integration","text":"Modules = [Integration,]","category":"page"},{"location":"Integration/#Gridap.Integration","page":"Gridap.Integration","title":"Gridap.Integration","text":"The exported names are\n\nDuffyQuadrature\nGenericQuadrature\nQuadrature\nTensorProductQuadrature\nget_coordinates\nget_weights\nnum_dims\nnum_point_dims\nnum_points\ntest_quadrature\n\n\n\n\n\n","category":"module"},{"location":"Integration/#Gridap.Integration.DuffyQuadrature","page":"Gridap.Integration","title":"Gridap.Integration.DuffyQuadrature","text":"struct DuffyQuadrature{D,T} <: Quadrature{D,T}\n  coordinates::Vector{Point{D,T}}\n  weights::Vector{T}\nend\n\nDuffy quadrature for simplices in [0,1]^D\n\n\n\n\n\n","category":"type"},{"location":"Integration/#Gridap.Integration.DuffyQuadrature-Union{Tuple{Integer}, Tuple{D}} where D","page":"Gridap.Integration","title":"Gridap.Integration.DuffyQuadrature","text":"DuffyQuadrature{D}(degree::Integer) where D\n\n\n\n\n\n","category":"method"},{"location":"Integration/#Gridap.Integration.GenericQuadrature","page":"Gridap.Integration","title":"Gridap.Integration.GenericQuadrature","text":"struct GenericQuadrature{D,T} <: Quadrature{D,T}\n  coordinates::Vector{Point{D,T}}\n  weights::Vector{T}\nend\n\n\n\n\n\n","category":"type"},{"location":"Integration/#Gridap.Integration.Quadrature","page":"Gridap.Integration","title":"Gridap.Integration.Quadrature","text":"abstract type Quadrature{D,T} <: GridapType end\n\n-get_coordinates(q::Quadrature) -get_weights(q::Quadrature) -test_quadrature\n\n\n\n\n\n","category":"type"},{"location":"Integration/#Gridap.Integration.TensorProductQuadrature","page":"Gridap.Integration","title":"Gridap.Integration.TensorProductQuadrature","text":"struct TensorProductQuadrature{D,T} <: Quadrature{D,T}\n  coordinates::Vector{Point{D,T}}\n  weights::Vector{T}\nend\n\nTensor product quadrature rule (nodes and weights) on a hyper cube [0,1]^D\n\n\n\n\n\n","category":"type"},{"location":"Integration/#Gridap.Integration.TensorProductQuadrature-Union{Tuple{Any}, Tuple{D}} where D","page":"Gridap.Integration","title":"Gridap.Integration.TensorProductQuadrature","text":"TensorProductQuadrature{D}(degree::Integer) where D\nTensorProductQuadrature{D}(degrees) where D\n\n\n\n\n\n","category":"method"},{"location":"Integration/#Gridap.Integration.TensorProductQuadrature-Union{Tuple{Tuple{Vararg{Int64,D}}}, Tuple{D}} where D","page":"Gridap.Integration","title":"Gridap.Integration.TensorProductQuadrature","text":"TensorProductQuadrature(degrees::NTuple{D}) where D\nTensorProductQuadrature(degrees::Point{D}) where D\n\n\n\n\n\n","category":"method"},{"location":"Integration/#Gridap.Integration.get_coordinates-Tuple{Gridap.Integration.Quadrature}","page":"Gridap.Integration","title":"Gridap.Integration.get_coordinates","text":"get_coordinates(q::Quadrature)\n\n\n\n\n\n","category":"method"},{"location":"Integration/#Gridap.Integration.get_weights-Tuple{Gridap.Integration.Quadrature}","page":"Gridap.Integration","title":"Gridap.Integration.get_weights","text":"get_weights(q::Quadrature)\n\n\n\n\n\n","category":"method"},{"location":"Integration/#Gridap.Integration.num_dims-Union{Tuple{Gridap.Integration.Quadrature{D,T} where T}, Tuple{D}} where D","page":"Gridap.Integration","title":"Gridap.Integration.num_dims","text":"num_dims(::Quadrature{D}) where D where D\nnum_dims(::Type{<:Quadrature{D}}) where D\n\n\n\n\n\n","category":"method"},{"location":"Integration/#Gridap.Integration.num_point_dims-Union{Tuple{Gridap.Integration.Quadrature{D,T} where T}, Tuple{D}} where D","page":"Gridap.Integration","title":"Gridap.Integration.num_point_dims","text":"num_point_dims(::Quadrature{D}) where D\nnum_point_dims(::Type{<:Quadrature{D}}) where D\n\n\n\n\n\n","category":"method"},{"location":"Integration/#Gridap.Integration.num_points-Tuple{Gridap.Integration.Quadrature}","page":"Gridap.Integration","title":"Gridap.Integration.num_points","text":"num_points(q::Quadrature)\n\n\n\n\n\n","category":"method"},{"location":"Integration/#Gridap.Integration.test_quadrature-Union{Tuple{Gridap.Integration.Quadrature{D,T}}, Tuple{T}, Tuple{D}} where T where D","page":"Gridap.Integration","title":"Gridap.Integration.test_quadrature","text":"test_quadrature(q::Quadrature{D,T}) where {D,T}\n\n\n\n\n\n","category":"method"},{"location":"TensorValues/#","page":"Gridap.TensorValues","title":"Gridap.TensorValues","text":"CurrentModule = Gridap.TensorValues","category":"page"},{"location":"TensorValues/#Gridap.TensorValues-1","page":"Gridap.TensorValues","title":"Gridap.TensorValues","text":"","category":"section"},{"location":"TensorValues/#","page":"Gridap.TensorValues","title":"Gridap.TensorValues","text":"TensorValues","category":"page"},{"location":"TensorValues/#Gridap.TensorValues","page":"Gridap.TensorValues","title":"Gridap.TensorValues","text":"This module provides concrete implementations of Number that represent 1st, 2nd and general order tensors.\n\nWhy\n\nThe main feature of this module is that the provided types do not extend from AbstractArray, but from Number!\n\nThis allows one to work with them as if they were scalar values in broadcasted operations on arrays of VectorValue objects (also for TensorValue or MultiValue objects). For instance, one can perform the following manipulations:\n\n# Assing a VectorValue to all the entries of an Array of VectorValues\nA = zeros(VectorValue{2,Int}, (4,5))\nv = VectorValue(12,31)\nA .= v # This is posible since  VectorValue <: Number\n\n# Broadcasting of tensor operations in arrays of TensorValues\nt = TensorValue(13,41,53,17) # creates a 2x2 TensorValue\ng = TensorValue(32,41,3,14) # creates another 2x2 TensorValue\nB = fill(t,(1,5))\nC = inner.(g,B) # inner product of g against all TensorValues in the array B\n@show C\n# C = [2494 2494 2494 2494 2494]\n\nThe exported names are:\n\nMultiValue\nSymFourthOrderTensorValue\nSymTensorValue\nTensorValue\nThirdOrderTensorValue\nVectorValue\nchange_eltype\ncross\ndet\ndiagonal_tensor\ndot\ndouble_contraction\ninner\ninv\nmeas\nmutable\nn_components\nnorm\nnum_components\nouter\nsymmetric_part\ntr\n×\n⊗\n⊙\n⊡\n⋅\n⋅²\n⋅¹\n\n\n\n\n\n","category":"module"},{"location":"TensorValues/#Exported-types-1","page":"Gridap.TensorValues","title":"Exported types","text":"","category":"section"},{"location":"TensorValues/#","page":"Gridap.TensorValues","title":"Gridap.TensorValues","text":"MultiValue\nVectorValue\nTensorValue","category":"page"},{"location":"TensorValues/#Gridap.TensorValues.MultiValue","page":"Gridap.TensorValues","title":"Gridap.TensorValues.MultiValue","text":"Type representing a multi-dimensional value\n\n\n\n\n\n","category":"type"},{"location":"TensorValues/#Gridap.TensorValues.VectorValue","page":"Gridap.TensorValues","title":"Gridap.TensorValues.VectorValue","text":"Type representing a first-order tensor\n\n\n\n\n\n","category":"type"},{"location":"TensorValues/#Gridap.TensorValues.TensorValue","page":"Gridap.TensorValues","title":"Gridap.TensorValues.TensorValue","text":"Type representing a second-order tensor\n\n\n\n\n\n","category":"type"},{"location":"TensorValues/#Constructors-1","page":"Gridap.TensorValues","title":"Constructors","text":"","category":"section"},{"location":"TensorValues/#","page":"Gridap.TensorValues","title":"Gridap.TensorValues","text":"mutable\nchange_eltype\ndiagonal_tensor","category":"page"},{"location":"TensorValues/#Info-getters-1","page":"Gridap.TensorValues","title":"Info getters","text":"","category":"section"},{"location":"TensorValues/#","page":"Gridap.TensorValues","title":"Gridap.TensorValues","text":"n_components","category":"page"},{"location":"TensorValues/#Operations-1","page":"Gridap.TensorValues","title":"Operations","text":"","category":"section"},{"location":"TensorValues/#","page":"Gridap.TensorValues","title":"Gridap.TensorValues","text":"inner\nouter\nmeas\nsymmetric_part","category":"page"},{"location":"TensorValues/#Gridap.TensorValues.outer","page":"Gridap.TensorValues","title":"Gridap.TensorValues.outer","text":"outer(∇,f)\n\nEquivalent to\n\ngradient(f)\n\n\n\n\n\nouter(f,∇)\n\nEquivalent to\n\ntranspose(gradient(f))\n\n\n\n\n\n\n\n\n\n","category":"function"},{"location":"TensorValues/#Gridap.TensorValues.meas","page":"Gridap.TensorValues","title":"Gridap.TensorValues.meas","text":"\n\n\n\n","category":"function"},{"location":"TensorValues/#Gridap.TensorValues.symmetric_part","page":"Gridap.TensorValues","title":"Gridap.TensorValues.symmetric_part","text":"\n\n\n\n","category":"function"},{"location":"Fields/#","page":"Gridap.Fields","title":"Gridap.Fields","text":"CurrentModule = Gridap.Fields","category":"page"},{"location":"Fields/#Gridap.Fields-1","page":"Gridap.Fields","title":"Gridap.Fields","text":"","category":"section"},{"location":"Fields/#","page":"Gridap.Fields","title":"Gridap.Fields","text":"Fields","category":"page"},{"location":"Fields/#Gridap.Fields","page":"Gridap.Fields","title":"Gridap.Fields","text":"This module provides:\n\nAn interface for physical fields, basis of physical fields and related objects.\nHelpers functions to work with fields and arrays of fields.\nHelpers functions to create lazy operation trees from fields and arrays of fields\n\nThe exported names are:\n\nAffineMap\nField\nHomothecy\nPoint\nVectorOfBlockBasisCoo\napply_kernel_to_field\napply_lincomb\napply_to_field_array\nattachmap\ncompose\ncompose_field_arrays\ncompose_fields\ncreate_array_of_blocked_axes\ncurl\ndivergence\nevaluate\nevaluate!\nevaluate_field\nevaluate_field!\nevaluate_field_array\nevaluate_field_arrays\nevaluate_fields\nevaluate_fields!\nfield_array_cache\nfield_array_gradient\nfield_cache\nfield_caches\nfield_gradient\nfield_gradients\nfield_operation_axes\nfield_operation_metasize\nfield_return_type\nfield_return_types\nfunction_field\ngrad2curl\ngradient\ngradient_type\ninsert_array_of_bases_in_block\nintegrate\nlaplacian\nlincomb\noperate_arrays_of_fields\noperate_fields\nsymmetric_gradient\ntest_array_of_fields\ntest_field\ntrialize_array_of_bases\ntrialize_basis\nΔ\nε\n∇\n\n\n\n\n\n","category":"module"},{"location":"Fields/#Interface-1","page":"Gridap.Fields","title":"Interface","text":"","category":"section"},{"location":"Fields/#","page":"Gridap.Fields","title":"Gridap.Fields","text":"Field\nPoint\nevaluate_field!(cache,f,x)\nfield_cache(f,x)\nfield_gradient(f)\nfield_return_type(f,x)\nevaluate_gradient!(cache,f,x)\ngradient_cache(f,x)\nevaluate_hessian!(cache,f,x)\nhessian_cache(f,x)\ntest_field","category":"page"},{"location":"Fields/#Gridap.Fields.Field","page":"Gridap.Fields","title":"Gridap.Fields.Field","text":"abstract type Field <: Kernel\n\nAbstract type representing physical fields, bases of fields, and other related objects.  These different cases are distinguished by the return value obtained when evaluating them. E.g., a physical field returns a vector of values when evaluated at a vector of points, and a basis of nf fields returns a 2d matrix (np x nf) when evaluated at a vector of np points.\n\nThe following functions need to be overloaded:\n\nevaluate_field!(cache,f,x)\nfield_cache(f,x)\n\nThe following functions can be also provided optionally\n\nfield_gradient(f)\nfield_return_type(f,x)\n\nMoreover, if the field_gradient(f) is not provided, a default implementation that uses the following functions will be used.\n\nevaluate_gradient!(cache,f,x)\ngradient_cache(f,x)\n\nIn order to be able to call field_gradient again on the resulting object the following methods have to be provided\n\nevaluate_hessian!(cache,f,x)\nhessian_cache(f,x)\n\nThese four methods are only designed to be called by the default implementation of field_gradient(f) and thus cannot be assumed that they are available for an arbitrary field. For this reason, these functions are not exported. The general way of evaluating a gradient of a field is to build the gradient with field_gradient(f) and evaluating the resulting object. For evaluating the hessian, use two times field_gradient.\n\nThe interface can be tested with\n\ntest_field\n\nMost of the functionality implemented in terms of this interface relies in duck typing (this is why all functions in the interface have the word \"field\").  Thus, it is not strictly needed to work with types that inherit from Field. This is specially useful in order to accommodate existing types into this framework without the need to implement a wrapper type that inherits from Field. For instance, a default implementation is available for numbers, which behave like \"constant\" fields, or arrays of numbers, which behave like \"constant\" bases of fields.  However, we recommend that new types inherit from Field.\n\n\n\n\n\n","category":"type"},{"location":"Fields/#Gridap.Fields.Point","page":"Gridap.Fields","title":"Gridap.Fields.Point","text":"const Point{D,T} = VectorValue{D,T}\n\nType representing a point of D dimensions with coordinates of type T. Fields are evaluated at vectors of Point objects.\n\n\n\n\n\n","category":"type"},{"location":"Fields/#Gridap.Fields.evaluate_field!-Tuple{Any,Any,Any}","page":"Gridap.Fields","title":"Gridap.Fields.evaluate_field!","text":"evaluate_field!(cache, f, x)\n\n\nReturns an array containing the values of evaluating the field f at the vector of points x by (possibly) using the scratch data in the cache object.  The returned value is  an array,  for which the length of the first axis is length(x), i.e., the number of points where the field has been evaluated.E.g., a physical field returns a vector of np values when evaluated at a vector of np points, and a basis of nf fields returns a 2d matrix (np x nf) when evaluated at a vector of np points.\n\nThis choice is made\n\nfor performance reasons when integrating fields (i.e., adding contributions at different points) since the added values are closer in memory with this layout.\nIn order to simplify operations between field objects. E.g., the result of evaluating a physical field and a basis of nffields at a vector of np points (which leads to a vector and a matrix of size (np,) and (np,nf) respectively)  can be conveniently added with the broadcasted sum .+ operator.\n\nThe cache object is computed with the field_cache function.\n\n\n\n\n\n","category":"method"},{"location":"Fields/#Gridap.Fields.field_cache-Tuple{Any,Any}","page":"Gridap.Fields","title":"Gridap.Fields.field_cache","text":"field_cache(f, x)\n\n\nReturns the cache object needed to evaluate field f at the vector of points x.\n\n\n\n\n\n","category":"method"},{"location":"Fields/#Gridap.Fields.field_gradient-Tuple{Any}","page":"Gridap.Fields","title":"Gridap.Fields.field_gradient","text":"field_gradient(f)\n\n\nReturns another field that represents the gradient of the given one\n\n\n\n\n\n","category":"method"},{"location":"Fields/#Gridap.Fields.field_return_type-Tuple{Any,Any}","page":"Gridap.Fields","title":"Gridap.Fields.field_return_type","text":"field_return_type(f, x)\n\n\nComputes the type obtained when evaluating field f at point x. It returns typeof(evaluate_field(f,x)) by default.\n\n\n\n\n\n","category":"method"},{"location":"Fields/#Gridap.Fields.evaluate_gradient!-Tuple{Any,Any,Any}","page":"Gridap.Fields","title":"Gridap.Fields.evaluate_gradient!","text":"evaluate_gradient!(cache, f, x)\n\n\n\n\n\n\n","category":"method"},{"location":"Fields/#Gridap.Fields.gradient_cache-Tuple{Any,Any}","page":"Gridap.Fields","title":"Gridap.Fields.gradient_cache","text":"gradient_cache(f, x)\n\n\n\n\n\n\n","category":"method"},{"location":"Fields/#Gridap.Fields.evaluate_hessian!-Tuple{Any,Any,Any}","page":"Gridap.Fields","title":"Gridap.Fields.evaluate_hessian!","text":"evaluate_hessian!(cache, f, x)\n\n\n\n\n\n\n","category":"method"},{"location":"Fields/#Gridap.Fields.hessian_cache-Tuple{Any,Any}","page":"Gridap.Fields","title":"Gridap.Fields.hessian_cache","text":"hessian_cache(cache, x)\n\n\n\n\n\n\n","category":"method"},{"location":"Fields/#Gridap.Fields.test_field","page":"Gridap.Fields","title":"Gridap.Fields.test_field","text":"test_field(\n  f,\n  x::AbstractVector{<:Point},\n  v::AbstractArray,cmp=(==);\n  grad=nothing,\n  hessian=nothing)\n\nFunction used to test the field interface. v is an array containing the expected result of evaluating the field f at the vector of points x. The comparison is performed using  the cmp function. For fields objects that support the field_gradient function, the key-word argument grad can be used. It should contain the result of evaluating field_gradient(f) at x. Idem for hessian. The checks are performed with the @test macro.\n\n\n\n\n\n","category":"function"},{"location":"Fields/#Helper-functions-using-fields-1","page":"Gridap.Fields","title":"Helper functions using fields","text":"","category":"section"},{"location":"Fields/#","page":"Gridap.Fields","title":"Gridap.Fields","text":"evaluate_field(f,x)\nevaluate(f::Field,x)\nevaluate!(cache,f::Field,x)\ngradient(f::Field)\n∇\ngradient_type","category":"page"},{"location":"Fields/#Gridap.Fields.evaluate_field-Tuple{Any,Any}","page":"Gridap.Fields","title":"Gridap.Fields.evaluate_field","text":"evaluate_field(f, x)\n\n\nEvaluates the field f at the vector of points x by creating a temporary cache internally. Equivalent to \n\nc = field_cache(f,x)\nevaluate_field!(c,f,x)\n\n\n\n\n\n","category":"method"},{"location":"Fields/#Gridap.Fields.evaluate-Tuple{Gridap.Fields.Field,Any}","page":"Gridap.Fields","title":"Gridap.Fields.evaluate","text":"evaluate(f::Field,x)\n\nEquivalent to \n\nevaluate_field(f,x)\n\nBut only for types that inherit from Field. Types that implement the field interface but not inherit from Field (e.g., numbers and arrays of numbers) cannot use this function. Use evaluate_field instead.\n\n\n\n\n\n","category":"method"},{"location":"Fields/#Gridap.Fields.evaluate!-Tuple{Any,Gridap.Fields.Field,Any}","page":"Gridap.Fields","title":"Gridap.Fields.evaluate!","text":"evaluate!(cache,f::Field,x)\n\nEquivalent to \n\nevaluate_field!(cache,f,x)\n\nBut only for types that inherit from Field. Types that implement the field interface but not inherit from Field (e.g., numbers and arrays of numbers) cannot use this function. Use evaluate_field! instead.\n\n\n\n\n\n","category":"method"},{"location":"Fields/#Gridap.Fields.gradient-Tuple{Gridap.Fields.Field}","page":"Gridap.Fields","title":"Gridap.Fields.gradient","text":"gradient(f::Field)\n\nEquivalent to\n\nfield_gradient(f)\n\nBut only for types that inherit from Field. Types that implement the field interface but not inherit from Field (e.g., numbers and arrays of numbers) cannot use this function. Use field_gradient instead.\n\n\n\n\n\n","category":"method"},{"location":"Fields/#Gridap.Fields.∇","page":"Gridap.Fields","title":"Gridap.Fields.∇","text":"const ∇ = gradient\n\nAlias for the gradient function.\n\n\n\n\n\n","category":"function"},{"location":"Fields/#Gridap.Fields.gradient_type","page":"Gridap.Fields","title":"Gridap.Fields.gradient_type","text":"gradient_type(::Type{T},x::Point) where T\n\n\n\n\n\n","category":"function"},{"location":"Fields/#Working-with-several-fields-at-once-1","page":"Gridap.Fields","title":"Working with several fields at once","text":"","category":"section"},{"location":"Fields/#","page":"Gridap.Fields","title":"Gridap.Fields","text":"field_return_types(f::Tuple,x)\nfield_caches(f::Tuple,x)\nevaluate_fields(f::Tuple,x)\nevaluate_fields!(cf::Tuple,f::Tuple,x)\nfield_gradients(a,b...)\ngradient_all(a,b...)\nevaluate_all(f::Tuple,x)","category":"page"},{"location":"Fields/#Gridap.Fields.field_return_types-Tuple{Tuple,Any}","page":"Gridap.Fields","title":"Gridap.Fields.field_return_types","text":"field_return_types(f::Tuple,x) -> Tuple\n\nComputes a tuple with the return types of the fields in the tuple f when evaluated at the vector of points x\n\nEquivalent to\n\ntuple(( field_return_type(fi,x) for fi in f)...)\n\n\n\n\n\n","category":"method"},{"location":"Fields/#Gridap.Fields.field_caches-Tuple{Tuple,Any}","page":"Gridap.Fields","title":"Gridap.Fields.field_caches","text":"field_caches(f::Tuple,x) -> Tuple\n\nEquivalent to\n\ntuple((field_cache(fi,x) for fi in f)...)\n\n\n\n\n\n","category":"method"},{"location":"Fields/#Gridap.Fields.evaluate_fields-Tuple{Tuple,Any}","page":"Gridap.Fields","title":"Gridap.Fields.evaluate_fields","text":"evaluate_fields(f::Tuple,x) -> Tuple\n\nEquivalent to\n\ntuple((evaluate_fields(fi,x) for fi in f)...)\n\n\n\n\n\n","category":"method"},{"location":"Fields/#Gridap.Fields.evaluate_fields!-Tuple{Tuple,Tuple,Any}","page":"Gridap.Fields","title":"Gridap.Fields.evaluate_fields!","text":"evaluate_fields!(cf::Tuple,f::Tuple,x) -> Tuple\n\nEquivalent to\n\ntuple((evaluate_fields!(ci,fi,x) for (ci,fi) in zip(c,f))...)\n\n\n\n\n\n","category":"method"},{"location":"Fields/#Gridap.Fields.field_gradients-Tuple{Any,Vararg{Any,N} where N}","page":"Gridap.Fields","title":"Gridap.Fields.field_gradients","text":"field_gradients(b...) -> Tuple\n\nEquivalent to\n\nmap(field_gradient,b)\n\n\n\n\n\n","category":"method"},{"location":"Fields/#Gridap.Fields.gradient_all-Tuple{Any,Vararg{Any,N} where N}","page":"Gridap.Fields","title":"Gridap.Fields.gradient_all","text":"gradient_all(b...) -> Tuple\n\nEquivalent to\n\nmap(gradient,b)\n\n\n\n\n\n","category":"method"},{"location":"Fields/#Gridap.Fields.evaluate_all-Tuple{Tuple,Any}","page":"Gridap.Fields","title":"Gridap.Fields.evaluate_all","text":"evaluate_all(f::Tuple,x) -> Tuple\n\nEquivalent to\n\ntuple((evaluate(fi,x) for fi in f)...)\n\n\n\n\n\n","category":"method"},{"location":"Fields/#Applying-kernels-to-fields-1","page":"Gridap.Fields","title":"Applying kernels to fields","text":"","category":"section"},{"location":"Fields/#","page":"Gridap.Fields","title":"Gridap.Fields","text":"apply_kernel_to_field(k,f...)\napply_kernel_gradient(k,f...)","category":"page"},{"location":"Fields/#Gridap.Fields.apply_kernel_to_field-Tuple{Any,Vararg{Any,N} where N}","page":"Gridap.Fields","title":"Gridap.Fields.apply_kernel_to_field","text":"apply_kernel_to_field(k,f...) -> Field\n\nReturns a field obtained by applying the kernel k to the  values of the fields in f. That is, the returned field evaluated at a vector of points x provides the value obtained by applying kernel k to the values of the fields f at the vector of points x. Formally, the resulting field at a  vector of points  x is defined as\n\nfx = evaluate_fields(f,x)\napply_kernel(k,fx...)\n\nIn order to be able to call the field_gradient function of the resulting field, one needs to define the gradient operator associated with the underlying kernel. This is done by adding a new method to apply_kernel_gradient(k,f...) for each kernel type.\n\n\n\n\n\n","category":"method"},{"location":"Fields/#Gridap.Fields.apply_kernel_gradient-Tuple{Any,Vararg{Any,N} where N}","page":"Gridap.Fields","title":"Gridap.Fields.apply_kernel_gradient","text":"apply_kernel_gradient(k,f...)\n\nReturns a field representing the gradient of the field obtained with\n\napply_kernel_to_field(k,f...)\n\n\n\n\n\n","category":"method"},{"location":"Fields/#Working-with-arrays-of-fields-1","page":"Gridap.Fields","title":"Working with arrays of fields","text":"","category":"section"},{"location":"Fields/#","page":"Gridap.Fields","title":"Gridap.Fields","text":"evaluate_field_array(a::AbstractArray,x::AbstractArray)\nevaluate(::AbstractArray{<:Field},::AbstractArray)\nfield_array_gradient(a::AbstractArray)\ngradient(::AbstractArray{<:Field})\nfield_array_cache(a::AbstractArray,x::AbstractArray)\ntest_array_of_fields","category":"page"},{"location":"Fields/#Gridap.Fields.evaluate_field_array-Tuple{AbstractArray,AbstractArray}","page":"Gridap.Fields","title":"Gridap.Fields.evaluate_field_array","text":"evaluate_field_array(f::AbstractArray,x::AbstractArray) -> AbstractArray\n\nEvaluates the fields in the array f at all the vector of points in the array of vector of points x and returns the result as a lazy array.\n\nThe result is numerically equivalent to\n\nmap(evaluate_field,f,x)\n\n\n\n\n\n","category":"method"},{"location":"Fields/#Gridap.Fields.evaluate-Tuple{AbstractArray{var\"#s18\",N} where N where var\"#s18\"<:Gridap.Fields.Field,AbstractArray}","page":"Gridap.Fields","title":"Gridap.Fields.evaluate","text":"evaluate(a::AbstractArray{<:Field},x::AbstractArray)\n\nEquivalent to\n\nevaluate_field_array(a,x)\n\nBut only for arrays a whose element type inherits from Field. If this is not the case, use evaluate_field_array(a,x) instead.\n\n\n\n\n\n","category":"method"},{"location":"Fields/#Gridap.Fields.field_array_gradient-Tuple{AbstractArray}","page":"Gridap.Fields","title":"Gridap.Fields.field_array_gradient","text":"field_array_gradient(a::AbstractArray)\n\nReturns an array containing the gradients of the fields in the array a. Numerically equivalent to\n\nmap(field_gradient,a)\n\n\n\n\n\n","category":"method"},{"location":"Fields/#Gridap.Fields.gradient-Tuple{AbstractArray{var\"#s18\",N} where N where var\"#s18\"<:Gridap.Fields.Field}","page":"Gridap.Fields","title":"Gridap.Fields.gradient","text":"gradient(f::AbstractArray{<:Field})\n\nEquivalent to\n\nfield_array_gradient(f)\n\nbut only for arrays whose element type is <:Field. Use function field_array_gradient otherwise.\n\n\n\n\n\n","category":"method"},{"location":"Fields/#Gridap.Fields.field_array_cache-Tuple{AbstractArray,AbstractArray}","page":"Gridap.Fields","title":"Gridap.Fields.field_array_cache","text":"field_array_cache(a::AbstractArray,x::AbstractArray) -> Tuple\n\nReturns the caches needed to perform the following iteration\n\nca, cfi, cx = field_array_cache(a,x)\n\nfor i in length(a)\n  fi = getindex!(ca,a,i)\n  xi = getindex!(cx,x,i)\n  fxi = evaluate!(cfi,fi,xi)\nend\n\n\n\n\n\n","category":"method"},{"location":"Fields/#Gridap.Fields.test_array_of_fields","page":"Gridap.Fields","title":"Gridap.Fields.test_array_of_fields","text":"function test_array_of_fields(\n  a::AbstractArray,\n  x::AbstractArray,\n  v::AbstractArray,\n  cmp::Function=(==);\n  grad = nothing)\n\nFunction to test an array of fields a. The array v is the expected result when calling evaluate_field_array(a,x). The entries in the computed array and the expected one are compared with the cmp function. The key-word argument grad is optional. If present, it should contain the expected result of\n\n∇a = field_array_gradient(a)\nevaluate_field_array(∇a,x)\n\n\n\n\n\n","category":"function"},{"location":"Fields/#Working-with-several-arrays-of-fields-at-once-1","page":"Gridap.Fields","title":"Working with several arrays of fields at once","text":"","category":"section"},{"location":"Fields/#","page":"Gridap.Fields","title":"Gridap.Fields","text":"evaluate_field_arrays(f::Tuple,x::AbstractArray)\nfield_array_gradients(f...)","category":"page"},{"location":"Fields/#Gridap.Fields.evaluate_field_arrays-Tuple{Tuple,AbstractArray}","page":"Gridap.Fields","title":"Gridap.Fields.evaluate_field_arrays","text":"evaluate_field_arrays(f::Tuple,x::AbstractArray) -> Tuple\n\nEquivalent to\n\ntuple((evaluate_field_array(fi,x) for fi in f)...)\n\n\n\n\n\n","category":"method"},{"location":"Fields/#Gridap.Fields.field_array_gradients-Tuple","page":"Gridap.Fields","title":"Gridap.Fields.field_array_gradients","text":"field_array_gradients(f...)\n\nEquivalent to\n\nmap(field_array_gradient,f)\n\n\n\n\n\n","category":"method"},{"location":"Fields/#Applying-kernels-to-arrays-of-fields-1","page":"Gridap.Fields","title":"Applying kernels to arrays of fields","text":"","category":"section"},{"location":"Fields/#","page":"Gridap.Fields","title":"Gridap.Fields","text":"apply_to_field_array(k,f::AbstractArray...)\nkernel_evaluate(k,x,f...)\napply_gradient(k,f...)","category":"page"},{"location":"Fields/#Gridap.Fields.apply_to_field_array-Tuple{Any,Vararg{AbstractArray,N} where N}","page":"Gridap.Fields","title":"Gridap.Fields.apply_to_field_array","text":"apply_to_field_array(k,f::AbstractArray...)\napply_to_field_array(::Type{T},k,f::AbstractArray...) where T\n\nReturns an array of fields numerically equivalent to\n\nmap( (x...) -> apply_kernel_to_field(k,x...), f )\n\n\n\n\n\n","category":"method"},{"location":"Fields/#Gridap.Fields.kernel_evaluate-Tuple{Any,Any,Vararg{Any,N} where N}","page":"Gridap.Fields","title":"Gridap.Fields.kernel_evaluate","text":"kernel_evaluate(k,x,f...)\n\nFunction to control the evaluation of the field resulting from the operation apply(k,f...), where k is a kernel and f... contains several arrays of fields.\n\nBy default, this function is implemented as\n\ng = apply(k,f...)\nevaluate_field_array(g,x)\n\nHowever, it can be rewritten for specific kernels in order to improve performance and simplify the underlying operation tree.\n\n\n\n\n\n","category":"method"},{"location":"Fields/#Gridap.Fields.apply_gradient-Tuple{Any,Vararg{Any,N} where N}","page":"Gridap.Fields","title":"Gridap.Fields.apply_gradient","text":"apply_gradient(k,f...)\n\nFunction to control the generation of the gradient the field resulting from the operation apply(k,f...), where k is a kernel and f... contains several arrays of fields.\n\nBy default, it returns the array obtained as\n\na = apply(k,f...)\nfield_array_gradient(a)\n\nHowever, it can be rewritten for specific kernels in order to improve performance and simplify the underlying operation tree.\n\n\n\n\n\n","category":"method"},{"location":"Fields/#Operations-on-fields-and-arrays-of-fields-1","page":"Gridap.Fields","title":"Operations on fields and arrays of fields","text":"","category":"section"},{"location":"Fields/#","page":"Gridap.Fields","title":"Gridap.Fields","text":"field_operation(op::Function,a,b)\nfield_array_operation(op::Function,a,b)\ncompose_fields(g,f)\ncompose_field_arrays(g,f)\ncompose(g::Field,f::Field)\ncompose(g::AbstractArray{<:Field},f::AbstractArray{<:Field})\ncompose(g::Function,f...)\ncompose(g::Function,f::AbstractArray...)\nlincomb(a::Field,b::AbstractVector)\nlincomb(a::AbstractArray,b::AbstractArray)\napply_lincomb(ax,b)\nattachmap(f,phi)\nattachmap(f::AbstractArray,phi::AbstractArray)\nintegrate(f,x,w,j)\nintegrate(f::AbstractArray,x,w,j)","category":"page"},{"location":"Fields/#Gridap.Fields.compose_fields-Tuple{Any,Any}","page":"Gridap.Fields","title":"Gridap.Fields.compose_fields","text":"compose_fields(g,f)\n\n\n\n\n\n","category":"method"},{"location":"Fields/#Gridap.Fields.compose_field_arrays-Tuple{Any,Any}","page":"Gridap.Fields","title":"Gridap.Fields.compose_field_arrays","text":"compose_field_arrays(g,f)\n\n\n\n\n\n","category":"method"},{"location":"Fields/#Gridap.Fields.compose-Tuple{Gridap.Fields.Field,Gridap.Fields.Field}","page":"Gridap.Fields","title":"Gridap.Fields.compose","text":"compose(g::Field,f::Field)\n\n\n\n\n\n","category":"method"},{"location":"Fields/#Gridap.Fields.compose-Tuple{AbstractArray{var\"#s18\",N} where N where var\"#s18\"<:Gridap.Fields.Field,AbstractArray{var\"#s17\",N} where N where var\"#s17\"<:Gridap.Fields.Field}","page":"Gridap.Fields","title":"Gridap.Fields.compose","text":"compose(g::AbstractArray{<:Field},f::AbstractArray{<:Field})\n\n\n\n\n\n","category":"method"},{"location":"Fields/#Gridap.Fields.compose-Tuple{Function,Vararg{Any,N} where N}","page":"Gridap.Fields","title":"Gridap.Fields.compose","text":"compose(g::Function,f...)\n\nReturns a new field obtained by composition of function g and the fields f. The value of the resulting field at a vector of points x is numerically equivalent to\n\nfx = evaluate_fields(f,x)\napply_kernel(bcast(g), fx...)\n\nThe gradient of the resulting field evaluated at a vector of points x is equivalent to\n\nfx = evaluate_fields(f,x)\napply_kernel(bcast(gradient(g)), fx...)\n\nNote that it is needed to overload gradient(::typeof(g)) for the given function g in order to be able to compute the gradient.\n\nAs in function apply_kernel_to_field if any of the inputs in f is a number or an array instead of a field it will be treated as a \"constant field\".\n\n\n\n\n\n","category":"method"},{"location":"Fields/#Gridap.Fields.compose-Tuple{Function,Vararg{AbstractArray,N} where N}","page":"Gridap.Fields","title":"Gridap.Fields.compose","text":"compose(g::Function,f::AbstractArray...)\n\nReturns an array of fields numerically equivalent to\n\nmap( (x...)->compose(g,x...), f...)\n\n\n\n\n\n","category":"method"},{"location":"Fields/#Gridap.Fields.lincomb-Tuple{Gridap.Fields.Field,AbstractArray{T,1} where T}","page":"Gridap.Fields","title":"Gridap.Fields.lincomb","text":"lincomb(a::Field,b::AbstractVector)\n\nReturns a field obtained by the \"linear combination\" of the value of the field basis a and the coefficient vector b.  The value of the resulting field evaluated at a vector of points x is defined as\n\nax = evaluate(a,x)\nax*b\n\nOn the other hand, the gradient of the resulting field is defined as\n\n∇ax = evaluate(gradient(a),x)\n∇ax*b\n\n\n\n\n\n","category":"method"},{"location":"Fields/#Gridap.Fields.lincomb-Tuple{AbstractArray,AbstractArray}","page":"Gridap.Fields","title":"Gridap.Fields.lincomb","text":"lincomb(a::AbstractArray{<:Field},b::AbstractArray)\n\nReturns an array of fields numerically equivalent to\n\nmap(lincomb,a,b)\n\n\n\n\n\n","category":"method"},{"location":"Fields/#Gridap.Fields.apply_lincomb-Tuple{Any,Any}","page":"Gridap.Fields","title":"Gridap.Fields.apply_lincomb","text":"apply_lincomb(ax,b)\n\n\n\n\n\n","category":"method"},{"location":"Fields/#Gridap.Fields.attachmap-Tuple{Any,Any}","page":"Gridap.Fields","title":"Gridap.Fields.attachmap","text":"attachmap(f,phi)\n\n\n\n\n\n","category":"method"},{"location":"Fields/#Gridap.Fields.attachmap-Tuple{AbstractArray,AbstractArray}","page":"Gridap.Fields","title":"Gridap.Fields.attachmap","text":"attachmap(f::AbstractArray,phi::AbstractArray)\n\n\n\n\n\n","category":"method"},{"location":"Fields/#Gridap.Fields.integrate-NTuple{4,Any}","page":"Gridap.Fields","title":"Gridap.Fields.integrate","text":"integrate(f,x,w,j)\n\n\n\n\n\n","category":"method"},{"location":"Fields/#Gridap.Fields.integrate-Tuple{AbstractArray,Any,Any,Any}","page":"Gridap.Fields","title":"Gridap.Fields.integrate","text":"integrate(f::AbstractArray,x,w,j)\n\n\n\n\n\n","category":"method"},{"location":"Fields/#Differential-operators-1","page":"Gridap.Fields","title":"Differential operators","text":"","category":"section"},{"location":"Fields/#","page":"Gridap.Fields","title":"Gridap.Fields","text":"In addition to the gradient function already discussed, the following differential operators are defined.","category":"page"},{"location":"Fields/#","page":"Gridap.Fields","title":"Gridap.Fields","text":"divergence(f)\nsymmetric_gradient(f)\nε\ncurl(f)\ngrad2curl(f)\nlaplacian(f)\nΔ","category":"page"},{"location":"Fields/#Gridap.Fields.divergence-Tuple{Any}","page":"Gridap.Fields","title":"Gridap.Fields.divergence","text":"divergence(f)\n\n\n\n\n\n","category":"method"},{"location":"Fields/#Gridap.Fields.symmetric_gradient-Tuple{Any}","page":"Gridap.Fields","title":"Gridap.Fields.symmetric_gradient","text":"symmetric_gradient(f)\n\n\n\n\n\n","category":"method"},{"location":"Fields/#Gridap.Fields.ε","page":"Gridap.Fields","title":"Gridap.Fields.ε","text":"const ε = symmetric_gradient\n\nAlias for the symmetric gradient\n\n\n\n\n\n","category":"function"},{"location":"Fields/#Gridap.Fields.curl-Tuple{Any}","page":"Gridap.Fields","title":"Gridap.Fields.curl","text":"curl(f)\n\n\n\n\n\n","category":"method"},{"location":"Fields/#Gridap.Fields.grad2curl-Tuple{Any}","page":"Gridap.Fields","title":"Gridap.Fields.grad2curl","text":"grad2curl(∇f)\n\n\n\n\n\n","category":"method"},{"location":"Fields/#Gridap.Fields.laplacian-Tuple{Any}","page":"Gridap.Fields","title":"Gridap.Fields.laplacian","text":"laplacian(f)\n\n\n\n\n\n","category":"method"},{"location":"Fields/#Gridap.Fields.Δ","page":"Gridap.Fields","title":"Gridap.Fields.Δ","text":"const Δ = laplacian\n\nAlias for the laplacian function\n\n\n\n\n\n","category":"function"},{"location":"Fields/#","page":"Gridap.Fields","title":"Gridap.Fields","text":"A fancy way of typing the differential operators is via the nabla object defined in the library.","category":"page"},{"location":"Fields/#","page":"Gridap.Fields","title":"Gridap.Fields","text":"(*)(::typeof(∇),f)\nouter(::typeof(∇),f)\nouter(f,::typeof(∇))\ncross(::typeof(∇),f)","category":"page"},{"location":"Fields/#Gridap.TensorValues.outer-Tuple{typeof(gradient),Any}","page":"Gridap.Fields","title":"Gridap.TensorValues.outer","text":"outer(∇,f)\n\nEquivalent to\n\ngradient(f)\n\n\n\n\n\n","category":"method"},{"location":"Fields/#Gridap.TensorValues.outer-Tuple{Any,typeof(gradient)}","page":"Gridap.Fields","title":"Gridap.TensorValues.outer","text":"outer(f,∇)\n\nEquivalent to\n\ntranspose(gradient(f))\n\n\n\n\n\n","category":"method"},{"location":"Fields/#LinearAlgebra.cross-Tuple{typeof(gradient),Any}","page":"Gridap.Fields","title":"LinearAlgebra.cross","text":"cross(∇,f)\n\nEquivalent to\n\ncurl(f)\n\n\n\n\n\n","category":"method"},{"location":"Fields/#Concrete-Field-implementations-1","page":"Gridap.Fields","title":"Concrete Field implementations","text":"","category":"section"},{"location":"Fields/#","page":"Gridap.Fields","title":"Gridap.Fields","text":"Homothecy\nAffineMap","category":"page"},{"location":"Fields/#Gridap.Fields.Homothecy","page":"Gridap.Fields","title":"Gridap.Fields.Homothecy","text":"struct Homothecy{D,T} <:Field\n  origin::Point{D,T}\n  scaling::Point{D,T}\nend\n\nThis type is slightly more general than a homothecy since we allow anisotropic scalings.\n\nImplements the Field interface up to first order derivatives\n\n\n\n\n\n","category":"type"},{"location":"Fields/#Gridap.Fields.AffineMap","page":"Gridap.Fields","title":"Gridap.Fields.AffineMap","text":"\n\n\n\n","category":"type"},{"location":"Visualization/#","page":"Gridap.Visualization","title":"Gridap.Visualization","text":"CurrentModule = Gridap.Visualization","category":"page"},{"location":"Visualization/#Gridap.Visualization-1","page":"Gridap.Visualization","title":"Gridap.Visualization","text":"","category":"section"},{"location":"Visualization/#","page":"Gridap.Visualization","title":"Gridap.Visualization","text":"Modules = [Visualization,]","category":"page"},{"location":"Visualization/#Gridap.Visualization","page":"Gridap.Visualization","title":"Gridap.Visualization","text":"The exported names are\n\ncreatevtk\nprint_op_tree\nvisualization_data\nwrite_vtk_file\nwritevtk\n\n\n\n\n\n","category":"module"},{"location":"Visualization/#Gridap.Visualization.createvtk-Tuple{AbstractArray{var\"#s311\",N} where N where var\"#s311\"<:(AbstractArray{var\"#s166\",N} where N where var\"#s166\"<:(VectorValue{D,T} where T where D)),Any}","page":"Gridap.Visualization","title":"Gridap.Visualization.createvtk","text":"createvtk(\n  cell_to_points::AbstractArray{<:AbstractArray{<:Point}},\n  filename;\n  celldata=Dict(),\n  nodaldata=Dict())\n\n\n\n\n\n","category":"method"},{"location":"Visualization/#Gridap.Visualization.createvtk-Tuple{AbstractArray{var\"#s315\",1} where var\"#s315\"<:(VectorValue{D,T} where T where D),Any}","page":"Gridap.Visualization","title":"Gridap.Visualization.createvtk","text":"createvtk(x::AbstractVector{<:Point}, filebase; kwargs...)\n\n\n\n\n\n","category":"method"},{"location":"Visualization/#Gridap.Visualization.createvtk-Tuple{Triangulation,Any}","page":"Gridap.Visualization","title":"Gridap.Visualization.createvtk","text":"\n\n\n\n","category":"method"},{"location":"Visualization/#Gridap.Visualization.visualization_data-Tuple{Triangulation}","page":"Gridap.Visualization","title":"Gridap.Visualization.visualization_data","text":"\n\n\n\n","category":"method"},{"location":"Visualization/#Gridap.Visualization.write_vtk_file-Tuple{Gridap.Geometry.Grid,Any}","page":"Gridap.Visualization","title":"Gridap.Visualization.write_vtk_file","text":"write_vtk_file(\n  trian::Grid,\n  filebase;\n  celldata=Dict(),\n  nodaldata=Dict())\n\nLow level entry point to vtk. Other vtk-related routines in Gridap eventually call this one.\n\n\n\n\n\n","category":"method"},{"location":"Visualization/#Gridap.Visualization.writevtk-Tuple{AbstractArray{var\"#s312\",N} where N where var\"#s312\"<:(AbstractArray{var\"#s311\",N} where N where var\"#s311\"<:(VectorValue{D,T} where T where D)),Any}","page":"Gridap.Visualization","title":"Gridap.Visualization.writevtk","text":"writevtk(\n  cell_to_points::AbstractArray{<:AbstractArray{<:Point}},\n  filename;\n  celldata=Dict(),\n  nodaldata=Dict())\n\n\n\n\n\n","category":"method"},{"location":"Visualization/#Gridap.Visualization.writevtk-Tuple{AbstractArray{var\"#s315\",1} where var\"#s315\"<:(VectorValue{D,T} where T where D),Any}","page":"Gridap.Visualization","title":"Gridap.Visualization.writevtk","text":"writevtk(x::AbstractVector{<:Point}, filebase; kwargs...)\n\n\n\n\n\n","category":"method"},{"location":"Visualization/#Gridap.Visualization.writevtk-Tuple{DiscreteModel,Any}","page":"Gridap.Visualization","title":"Gridap.Visualization.writevtk","text":"writevtk(model::DiscreteModel,filebase)\nwritevtk(model::DiscreteModel, labels::FaceLabeling, filebase)\n\n\n\n\n\n","category":"method"},{"location":"Visualization/#Gridap.Visualization.writevtk-Tuple{LagrangianRefFE,Any}","page":"Gridap.Visualization","title":"Gridap.Visualization.writevtk","text":"writevtk(reffe::LagrangianRefFE,filebase)\n\n\n\n\n\n","category":"method"},{"location":"Visualization/#Gridap.Visualization.writevtk-Tuple{Polytope,Any}","page":"Gridap.Visualization","title":"Gridap.Visualization.writevtk","text":"writevtk(p::Polytope,filebase)\n\n\n\n\n\n","category":"method"},{"location":"Visualization/#Gridap.Visualization.writevtk-Tuple{Triangulation,Any}","page":"Gridap.Visualization","title":"Gridap.Visualization.writevtk","text":"\n\n\n\n","category":"method"},{"location":"Visualization/#Gridap.Visualization.create_vtk_file-Tuple{Gridap.Geometry.Grid,Any}","page":"Gridap.Visualization","title":"Gridap.Visualization.create_vtk_file","text":"create_vtk_file(\n  trian::Grid,\n  filebase;\n  celldata=Dict(),\n  nodaldata=Dict())\n\nLow level entry point to vtk. Other vtk-related routines in Gridap eventually call this one. This function only creates the vtkFile, without writing to disk.\n\n\n\n\n\n","category":"method"},{"location":"Visualization/#Gridap.Visualization.get_vtkid-Tuple{LagrangianRefFE}","page":"Gridap.Visualization","title":"Gridap.Visualization.get_vtkid","text":"\n\n\n\n","category":"method"},{"location":"Visualization/#Gridap.Visualization.get_vtknodes-Tuple{LagrangianRefFE}","page":"Gridap.Visualization","title":"Gridap.Visualization.get_vtknodes","text":"\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs","text":"CurrentModule = Gridap.ReferenceFEs","category":"page"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs-1","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs","text":"","category":"section"},{"location":"ReferenceFEs/#","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs","text":"ReferenceFEs","category":"page"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs","text":"The exported names are\n\nCDConformity\nCONT\nConformity\nCurlConformity\nDISC\nDivConformity\nDof\nExtrusionPolytope\nGenericLagrangianRefFE\nGenericRefFE\nGradConformity\nH1Conformity\nHEX\nHEX8\nHEX_AXIS\nINVALID_PERM\nL2Conformity\nLagrangianDofBasis\nLagrangianRefFE\nMomentBasedDofBasis\nNedelecRefFE\nPYRAMID\nPolytope\nQUAD\nQUAD4\nRaviartThomasRefFE\nReferenceFE\nSEG2\nSEGMENT\nSerendipityRefFE\nTET\nTET4\nTET_AXIS\nTRI\nTRI3\nVERTEX\nVERTEX1\nWEDGE\ncompute_face_orders\ncompute_lagrangian_reffaces\ncompute_monomial_basis\ncompute_nodes\ncompute_own_nodes\ncompute_own_nodes_permutations\ncompute_shapefuns\ndof_cache\ndof_return_type\nevaluate_dof\nevaluate_dof!\nget_bounding_box\nget_default_conformity\nget_dimrange\nget_dimranges\nget_dof_basis\nget_dof_to_comp\nget_dof_to_node\nget_edge_tangents\nget_extrusion\nget_face_coordinates\nget_face_dimranges\nget_face_dofs\nget_face_moments\nget_face_nodes\nget_face_nodes_dofs\nget_face_own_dofs\nget_face_own_dofs_permutations\nget_face_own_nodes\nget_face_own_nodes_permutations\nget_face_type\nget_face_vertex_permutations\nget_face_vertices\nget_facedims\nget_faces\nget_facet_normals\nget_facet_orientations\nget_node_and_comp_to_dof\nget_node_coordinates\nget_nodes\nget_offset\nget_offsets\nget_own_dofs_permutations\nget_own_nodes_permutations\nget_polytope\nget_prebasis\nget_reffaces\nget_shapefuns\nget_vertex_coordinates\nget_vertex_node\nget_vertex_permutations\nis_P\nis_Q\nis_S\nis_affine\nis_first_order\nis_n_cube\nis_simplex\nnum_cell_dims\nnum_dims\nnum_dofs\nnum_edges\nnum_faces\nnum_facets\nnum_nodes\nnum_point_dims\nnum_vertices\nsimplexify\ntest_dof\ntest_lagrangian_reference_fe\ntest_polytope\ntest_reference_fe\n\n\n\n\n\n","category":"module"},{"location":"ReferenceFEs/#Polytopes-1","page":"Gridap.ReferenceFEs","title":"Polytopes","text":"","category":"section"},{"location":"ReferenceFEs/#Interface-1","page":"Gridap.ReferenceFEs","title":"Interface","text":"","category":"section"},{"location":"ReferenceFEs/#","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs","text":"Polytope\nget_faces(p::Polytope)\nget_dimranges(p::Polytope)\nget_dimrange(p::Polytope,d::Integer)\nPolytope{D}(p::Polytope,Dfaceid::Integer) where D\nget_vertex_coordinates(p::Polytope)\n(==)(a::Polytope{D},b::Polytope{D}) where D\nget_edge_tangents(p::Polytope)\nget_facet_normals(p::Polytope)\nget_facet_orientations(p::Polytope)\nget_vertex_permutations(p::Polytope)\nis_simplex(p::Polytope)\nis_n_cube(p::Polytope)\nsimplexify(p::Polytope)\ntest_polytope(p::Polytope{D};optional::Bool) where D\nnum_dims(::Polytope)\nnum_faces(p::Polytope)\nnum_faces(p::Polytope,dim::Integer)\nnum_facets(p::Polytope)\nnum_edges(p::Polytope)\nnum_vertices(p::Polytope)\nget_facedims(p::Polytope)\nget_offsets(p::Polytope)\nget_offset(p::Polytope,d::Integer)\nget_faces(p::Polytope,dimfrom::Integer,dimto::Integer)\nget_face_vertices(p::Polytope,dim::Integer)\nget_face_coordinates(p::Polytope,d::Integer)\nget_face_dimranges(p::Polytope,d::Integer)\nget_reffaces(::Type{Polytope{d}},p::Polytope) where d\nget_face_type(p::Polytope,d::Integer)\nget_bounding_box(p::Polytope{D}) where D\nget_face_vertex_permutations(p::Polytope,d::Integer)","category":"page"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.Polytope","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.Polytope","text":"abstract type Polytope{D} <: GridapType\n\nAbstract type representing a polytope (i.e., a polyhedron in arbitrary dimensions). D is the environment dimension (typically, 0, 1, 2, or 3). This type parameter is needed since there are functions in the  Polytope interface that return containers with Point{D} objects. We adopt the usual nomenclature for polytope-related objects. All objects in a polytope (from vertices to the polytope itself) are called n-faces or simply faces. The notation n-faces is used only when it is needed to refer to the object dimension n. Otherwise we simply use face. In addition, we say\n\nvertex (pl. vertices): for 0-faces\nedge: for 1-faces\nfacet: for (D-1)-faces\n\nThe Polytope interface is defined by overloading the following functions\n\nget_faces(p::Polytope)\nget_dimranges(p::Polytope)\nPolytope{N}(p::Polytope,faceid::Integer) where N\nget_vertex_coordinates(p::Polytope)\n(==)(a::Polytope{D},b::Polytope{D}) where D\n\nAnd optionally these ones:\n\nget_edge_tangents(p::Polytope)\nget_facet_normals(p::Polytope)\nget_facet_orientations(p::Polytope)\nget_vertex_permutations(p::Polytope)\nis_n_cube(p::Polytope)\nis_simplex(p::Polytope)\nsimplexify(p::Polytope)\n\nThe interface can be tested with the function\n\ntest_polytope\n\n\n\n\n\n","category":"type"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.get_faces-Tuple{Polytope}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.get_faces","text":"get_faces(p::Polytope) -> Vector{Vector{Int}}\n\nGiven a polytope p the function returns a vector of vectors defining the incidence relation of the faces in the polytope.\n\nEach face in the polytope receives a unique integer id. The id 1 is assigned to the first 0-face. Consecutive increasing ids are assigned to the other 0-faces, then to 1-faces, and so on. The polytope itself receives the largest id which coincides with num_faces(p). For a face id iface, get_faces(p)[iface] is a vector of face ids, corresponding to the faces that are incident with the face labeled with iface. That is, faces that are either on its boundary or the face itself.  In this vector of incident face ids, faces are ordered by dimension, starting with 0-faces. Within each dimension, the labels are ordered in a consistent way with the polyope object for the face iface itself.\n\nExamples\n\nusing Gridap.ReferenceFEs\n\nfaces = get_faces(SEGMENT)\nprintln(faces)\n\n# output\nArray{Int64,1}[[1], [2], [1, 2, 3]]\n\nThe constant SEGMENT is bound to a predefined instance of polytope that represents a segment. The face labels associated with a segment are [1,2,3], being 1 and 2 for the vertices and  3 for the segment itself. In this case, this function returns the vector of vectors [[1],[2],[1,2,3]] meaning that vertex 1 is incident with vertex 1 (idem for vertex 2), and that  the segment (id 3) is incident with the vertices 1 and 2 and the segment itself.\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.get_dimranges-Tuple{Polytope}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.get_dimranges","text":"get_dimranges(p::Polytope) -> Vector{UnitRange{Int}}\n\nGiven a polytope p it returns a vector of ranges. The entry d+1 in this vector contains the range of face ids for the faces of dimension d.\n\nExamples\n\nusing Gridap.ReferenceFEs\n\nranges = get_dimranges(SEGMENT)\nprintln(ranges)\n\n# output\nUnitRange{Int64}[1:2, 3:3]\n\nFace ids for the vertices in the segment range from 1 to 2 (2 vertices), the face ids for edges in the segment range from 3 to 3 (only one edge with id 3).\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.get_dimrange-Tuple{Polytope,Integer}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.get_dimrange","text":"get_dimrange(p::Polytope,d::Integer)\n\nEquivalent to\n\nget_dimranges(p)[d+1]\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.Polytope-Union{Tuple{D}, Tuple{Polytope,Integer}} where D","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.Polytope","text":"Polytope{N}(p::Polytope,faceid::Integer) where N\n\nReturns a Polytope{N} object representing the \"reference\" polytope of the N-face with id faceid. The value faceid refers to the numeration restricted to the dimension N (it starts with 1 for the first N-face).\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.get_vertex_coordinates-Tuple{Polytope}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.get_vertex_coordinates","text":"get_vertex_coordinates(p::Polytope) -> Vector{Point{D,Float64}}\n\nGiven a polytope p return a vector of points representing containing the coordinates of the vertices.\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Base.:==-Union{Tuple{D}, Tuple{Polytope{D},Polytope{D}}} where D","page":"Gridap.ReferenceFEs","title":"Base.:==","text":"(==)(a::Polytope{D},b::Polytope{D}) where D\n\nReturns true if the polytopes a and b are equivalent. Otherwise, it  returns false. Note that the operator == returns false by default for polytopes of different dimensions. Thus, this function has to be overloaded only for the case of polytopes a and b of same dimension.\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.get_edge_tangents-Tuple{Polytope}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.get_edge_tangents","text":"get_edge_tangents(p::Polytope) -> Vector{VectorValue{D,Float64}}\n\nGiven a polytope p, returns a vector of VectorValue objects representing the unit tangent vectors to the polytope edges.\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.get_facet_normals-Tuple{Polytope}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.get_facet_normals","text":"get_facet_normals(p::Polytope) -> Vector{VectorValue{D,Float64}}\n\nGiven a polytope p, returns a vector of VectorValue objects representing the unit outward normal vectors to the polytope facets.\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.get_facet_orientations-Tuple{Polytope}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.get_facet_orientations","text":"get_facet_orientations(p::Polytope) -> Vector{Int}\n\nGiven a polytope p returns a vector of integers of length num_facets(p). Facets, whose vertices are ordered consistently with the outwards normal vector, receive value 1 in this vector. Otherwise, facets receive value -1.\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.get_vertex_permutations-Tuple{Polytope}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.get_vertex_permutations","text":"get_vertex_permutations(p::Polytope) -> Vector{Vector{Int}}\n\nGiven a polytope p, returns a vector of vectors containing all admissible permutations of the polytope vertices. An admissible permutation is one such that, if the vertices of the polytope are re-labeled according to this permutation, the resulting polytope preserves the shape of the original one.\n\nExamples\n\nusing Gridap.ReferenceFEs\n\nperms = get_vertex_permutations(SEGMENT)\nprintln(perms)\n\n# output\nArray{Int64,1}[[1, 2], [2, 1]]\n\n\nThe first admissible permutation for a segment is [1,2],i.e., the identity. The second one is [2,1], i.e., the first vertex is relabeled as 2 and the second vertex is relabeled as 1.\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.is_simplex-Tuple{Polytope}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.is_simplex","text":"is_simplex(p::Polytope) -> Bool\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.is_n_cube-Tuple{Polytope}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.is_n_cube","text":"is_n_cube(p::Polytope) -> Bool\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.simplexify-Tuple{Polytope}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.simplexify","text":"simplexify(p::Polytope) -> Tuple{Vector{Vector{Int}},Polytope}\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.test_polytope-Union{Tuple{Polytope{D}}, Tuple{D}} where D","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.test_polytope","text":"test_polytope(p::Polytope{D}; optional::Bool=false) where D\n\nFunction that stresses out the functions in the Polytope interface. It tests whether the function in the polytope interface are defined for the given object, and whether they return objects of the expected type. With optional=false (the default), only the mandatory functions are checked. With optional=true, the optional functions are also tested.\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.Integration.num_dims-Tuple{Polytope}","page":"Gridap.ReferenceFEs","title":"Gridap.Integration.num_dims","text":"num_dims(::Type{<:Polytope{D}}) where D\nnum_dims(p::Polytope{D}) where D\n\nReturns D. \n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.num_faces-Tuple{Polytope}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.num_faces","text":"num_faces(p::Polytope)\n\nReturns the total number of faces in polytope p (from vertices to the polytope itself).\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.num_faces-Tuple{Polytope,Integer}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.num_faces","text":"num_faces(p::Polytope,dim::Integer)\n\nReturns the number of faces of dimension dim in polytope p.\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.num_facets-Tuple{Polytope}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.num_facets","text":"num_facets(p::Polytope)\n\nReturns the number of facets in the polytope p.\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.num_edges-Tuple{Polytope}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.num_edges","text":"num_edges(p::Polytope)\n\nReturns the number of edges in the polytope p.\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.num_vertices-Tuple{Polytope}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.num_vertices","text":"num_vertices(p::Polytope)\n\nReturns the number of vertices in the polytope p.\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.get_facedims-Tuple{Polytope}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.get_facedims","text":"get_facedims(p::Polytope) -> Vector{Int}\n\nGiven a polytope p, returns a vector indicating the dimension of each face in the polytope\n\nExamples\n\nusing Gridap.ReferenceFEs\n\ndims = get_facedims(SEGMENT)\nprintln(dims)\n\n# output\n[0, 0, 1]\n\n\nThe first two faces in the segment (the two vertices) have dimension 0 and the  third face (the segment itself) has dimension 1\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.get_offsets-Tuple{Polytope}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.get_offsets","text":"get_offsets(p::Polytope) -> Vector{Int}\n\nGiven a polytope p, it returns a vector of integers. The position in the d+1 entry in this vector is the offset that transforms a face id in the global numeration in the polytope to the numeration restricted to faces to dimension d.\n\nExamples\n\nusing Gridap.ReferenceFEs\n\noffsets = get_offsets(SEGMENT)\nprintln(offsets)\n\n# output\n[0, 2]\n\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.get_offset-Tuple{Polytope,Integer}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.get_offset","text":"get_offset(p::Polytope,d::Integer)\n\nEquivalent to get_offsets(p)[d+1].\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.get_faces-Tuple{Polytope,Integer,Integer}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.get_faces","text":"get_faces(p::Polytope,dimfrom::Integer,dimto::Integer) -> Vector{Vector{Int}}\n\nFor dimfrom >= dimto returns a vector that for each face of dimension dimfrom stores a vector of the ids of faces of dimension dimto on its boundary.\n\nFor dimfrom < dimto returns a vector that for each face of dimfrom stores a vector of the face ids of faces of dimension dimto that touch it.\n\nThe numerations used in this funcitons are the ones restricted to each dimension.\n\nusing Gridap.ReferenceFEs\n\nedge_to_vertices = get_faces(QUAD,1,0)\nprintln(edge_to_vertices)\n\nvertex_to_edges_around = get_faces(QUAD,0,1)\nprintln(vertex_to_edges_around)\n\n# output\nArray{Int64,1}[[1, 2], [3, 4], [1, 3], [2, 4]]\nArray{Int64,1}[[1, 3], [1, 4], [2, 3], [2, 4]]\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.get_face_vertices-Tuple{Polytope,Integer}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.get_face_vertices","text":"get_face_vertices(p::Polytope) -> Vector{Vector{Int}}\nget_face_vertices(p::Polytope,dim::Integer) -> Vector{Vector{Int}}\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.get_face_coordinates-Tuple{Polytope,Integer}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.get_face_coordinates","text":"get_face_coordinates(p::Polytope,d::Integer)\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.get_face_dimranges-Tuple{Polytope,Integer}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.get_face_dimranges","text":"get_face_dimranges(p::Polytope,d::Integer)\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.get_reffaces-Union{Tuple{d}, Tuple{Type{Polytope{d}},Polytope}} where d","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.get_reffaces","text":"get_reffaces(::Type{Polytope{d}},p::Polytope) where d -> Vector{Polytope{d}}\n\nGet a vector of the unique polytopes for the faces of dimension d.\n\nExamples\n\nGet the unique polytopes for the facets of a wedge.\n\nusing Gridap.ReferenceFEs\n\nreffaces = get_reffaces(Polytope{2},WEDGE)\n\nprintln(reffaces)\n\n# output\nGridap.ReferenceFEs.ExtrusionPolytope{2}[TRI, QUAD]\n\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.get_face_type-Tuple{Polytope,Integer}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.get_face_type","text":"get_face_type(p::Polytope,d::Integer) -> Vector{Int}\n\nReturn a vector of integers denoting, for each face of dimension d, an index to the vector get_reffaces(Polytope{d},p) \n\nExamples\n\nGet the unique polytopes for the facets of a wedge and identify of which type each face is.\n\nusing Gridap.ReferenceFEs\n\nreffaces = get_reffaces(Polytope{2},WEDGE)\n\nface_types = get_face_type(WEDGE,2)\n\nprintln(reffaces)\nprintln(face_types)\n\n# output\nGridap.ReferenceFEs.ExtrusionPolytope{2}[TRI, QUAD]\n[1, 1, 2, 2, 2]\n\n\nThe three first facets are of type 1, i.e, QUAD, and the last ones of type 2, i.e., TRI.\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.get_bounding_box-Union{Tuple{Polytope{D}}, Tuple{D}} where D","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.get_bounding_box","text":"get_bounding_box(p::Polytope{D}) where D\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.get_face_vertex_permutations-Tuple{Polytope,Integer}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.get_face_vertex_permutations","text":"get_face_vertex_permutations(p::Polytope)\nget_face_vertex_permutations(p::Polytope,d::Integer)\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Extrusion-polytopes-1","page":"Gridap.ReferenceFEs","title":"Extrusion polytopes","text":"","category":"section"},{"location":"ReferenceFEs/#","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs","text":"ExtrusionPolytope\nExtrusionPolytope(extrusion::Int...)\nPolytope(extrusion::Int...)\nHEX_AXIS\nTET_AXIS\nget_extrusion(p::ExtrusionPolytope)","category":"page"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.ExtrusionPolytope","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.ExtrusionPolytope","text":"struct ExtrusionPolytope{D} <: Polytope{D}\n  extrusion::Point{D,Int}\n  # + private fields\nend\n\nConcrete type for polytopes that can be represented with an \"extrusion\" tuple. The underlying extrusion is available in the field extrusion. Instances of this type can be obtained with the constructors\n\nPolytope(extrusion::Int...)\nExtrusionPolytope(extrusion::Int...)\n\n\n\n\n\n","category":"type"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.ExtrusionPolytope-Tuple{Vararg{Int64,N} where N}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.ExtrusionPolytope","text":"ExtrusionPolytope(extrusion::Int...)\n\nGenerates an ExtrusionPolytope from the tuple extrusion. The values in extrusion are either equal to the constant HEX_AXIS or the constant TET_AXIS.\n\nExamples\n\nCreating a quadrilateral, a triangle, and a wedge\n\nusing Gridap.ReferenceFEs\n\nquad = ExtrusionPolytope(HEX_AXIS,HEX_AXIS)\n\ntri = ExtrusionPolytope(TET_AXIS,TET_AXIS)\n\nwedge = ExtrusionPolytope(TET_AXIS,TET_AXIS,HEX_AXIS)\n\nprintln(quad == QUAD)\nprintln(tri == TRI)\nprintln(wedge == WEDGE)\n\n# output\ntrue\ntrue\ntrue\n\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.Polytope-Tuple{Vararg{Int64,N} where N}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.Polytope","text":"Polytope(extrusion::Int...)\n\nEquivalent to ExtrusionPolytope(extrusion...)\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.HEX_AXIS","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.HEX_AXIS","text":"Constant to be used in order to indicate a hex-like extrusion axis.\n\n\n\n\n\n","category":"constant"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.TET_AXIS","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.TET_AXIS","text":"Constant to be used in order to indicate a tet-like extrusion axis.\n\n\n\n\n\n","category":"constant"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.get_extrusion-Tuple{Gridap.ReferenceFEs.ExtrusionPolytope}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.get_extrusion","text":"get_extrusion(p::ExtrusionPolytope)\n\nEquivalent to p.extrusion.\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Pre-defined-polytope-instances-1","page":"Gridap.ReferenceFEs","title":"Pre-defined polytope instances","text":"","category":"section"},{"location":"ReferenceFEs/#","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs","text":"VERTEX\nSEGMENT\nTRI\nQUAD\nTET\nHEX\nWEDGE\nPYRAMID","category":"page"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.VERTEX","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.VERTEX","text":"const VERTEX = Polytope()\n\n\n\n\n\n","category":"constant"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.SEGMENT","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.SEGMENT","text":"const SEGMENT = Polytope(HEX_AXIS)\n\n\n\n\n\n","category":"constant"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.TRI","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.TRI","text":"const TRI = Polytope(TET_AXIS,TET_AXIS)\n\n\n\n\n\n","category":"constant"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.QUAD","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.QUAD","text":"const QUAD = Polytope(HEX_AXIS,HEX_AXIS)\n\n\n\n\n\n","category":"constant"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.TET","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.TET","text":"const TET = Polytope(TET_AXIS,TET_AXIS,TET_AXIS)\n\n\n\n\n\n","category":"constant"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.HEX","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.HEX","text":"const HEX = Polytope(HEX_AXIS,HEX_AXIS,HEX_AXIS)\n\n\n\n\n\n","category":"constant"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.WEDGE","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.WEDGE","text":"const WEDGE = Polytope(TET_AXIS,TET_AXIS,HEX_AXIS)\n\n\n\n\n\n","category":"constant"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.PYRAMID","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.PYRAMID","text":"const PYRAMID = Polytope(HEX_AXIS,HEX_AXIS,TET_AXIS)\n\n\n\n\n\n","category":"constant"},{"location":"ReferenceFEs/#Degrees-of-freedom-1","page":"Gridap.ReferenceFEs","title":"Degrees of freedom","text":"","category":"section"},{"location":"ReferenceFEs/#Interface-2","page":"Gridap.ReferenceFEs","title":"Interface","text":"","category":"section"},{"location":"ReferenceFEs/#","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs","text":"Dof\nevaluate_dof!(cache,dof,field)\ndof_cache(dof,field)\ndof_return_type(dof,field)\ntest_dof(dof,field,v,comp::Function)\nevaluate_dof(dof,field)\nevaluate(dof::Dof,field)","category":"page"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.Dof","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.Dof","text":"abstract type Dof <: Kernel\n\nAbstract type representing a degree of freedom (DOF), a basis of DOFs, and related objects. These different cases are distinguished by the return type obtained when evaluating the Dof object on a Field object. See function evaluate_dof! for more details.\n\nThe following functions needs to be overloaded\n\ndof_cache\nevaluate_dof!\n\nThe following functions can be overloaded optionally\n\ndof_return_type\n\nThe interface is tested with\n\ntest_dof\n\nIn most of the cases it is not strictly needed that types that implement this interface inherit from Dof. However, we recommend to inherit from Dof, when possible.\n\n\n\n\n\n","category":"type"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.evaluate_dof!-Tuple{Any,Any,Any}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.evaluate_dof!","text":"evaluate_dof!(cache,dof,field)\n\nEvaluates the dof dof with the field field. It can return either an scalar value or an array of scalar values depending the case. The cache object is computed with function dof_cache.\n\nWhen a mathematical dof is evaluated on a physical field, a scalar number is returned. If either the Dof object is a basis of DOFs, or the Field object is a basis of fields, or both objects are bases, then the returned object is an array of scalar numbers. The first dimensions in the resulting array are for the Dof object and the last ones for the Field object. E.g, a basis of nd DOFs evaluated at physical field returns a vector of nd entries. A basis of nd DOFs evaluated at a basis of nf fields returns a matrix of size (nd,nf).\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.dof_cache-Tuple{Any,Any}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.dof_cache","text":"dof_cache(dof,field)\n\nReturns the cache needed to call evaluate_dof!(cache,dof,field)\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.dof_return_type-Tuple{Any,Any}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.dof_return_type","text":"dof_return_type(dof,field)\n\nReturns the type for the value obtained with evaluating dof with field.\n\nIt defaults to\n\ntypeof(evaluate_dof(dof,field))\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.test_dof-Tuple{Any,Any,Any,Function}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.test_dof","text":"test_dof(dof,field,v,comp::Function=(==))\n\nTest that the Dof interface is properly implemented for object dof. It also checks if the object dof when evaluated at the field field returns the same value as v. Comparison is made with the comp function.\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.evaluate_dof-Tuple{Any,Any}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.evaluate_dof","text":"evaluate_dof(dof,field)\n\nEquivalent to\n\ncache = dof_cache(dof,field)\nevaluate_dof!(cache,dof,field)\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.Fields.evaluate-Tuple{Gridap.ReferenceFEs.Dof,Any}","page":"Gridap.ReferenceFEs","title":"Gridap.Fields.evaluate","text":"evaluate(dof::Dof,field)\n\nEquivalent to evaluate_dof(dof,field).\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Working-with-arrays-of-DOFs-1","page":"Gridap.ReferenceFEs","title":"Working with arrays of DOFs","text":"","category":"section"},{"location":"ReferenceFEs/#","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs","text":"evaluate_dof_array(dof::AbstractArray,field::AbstractArray)\nevaluate(dof::AbstractArray{<:Dof},field::AbstractArray)","category":"page"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.evaluate_dof_array-Tuple{AbstractArray,AbstractArray}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.evaluate_dof_array","text":"evaluate_dof_array(dof::AbstractArray,field::AbstractArray)\n\nEvaluates the Dof objects in the array dof at the Field objects at the array field element by element.\n\nThe result is numerically equivalent to\n\nmap(evaluate_dof, dof, field)\n\nbut it is described with a more memory-friendly lazy type.\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.Fields.evaluate-Tuple{AbstractArray{var\"#s18\",N} where N where var\"#s18\"<:Gridap.ReferenceFEs.Dof,AbstractArray}","page":"Gridap.ReferenceFEs","title":"Gridap.Fields.evaluate","text":"evaluate(dof::AbstractArray{<:Dof},field::AbstractArray)\n\nEquivalent to evaluate_dof_array(dof,field)\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Lagrangian-dof-bases-1","page":"Gridap.ReferenceFEs","title":"Lagrangian dof bases","text":"","category":"section"},{"location":"ReferenceFEs/#","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs","text":"LagrangianDofBasis\nLagrangianDofBasis(::Type{T},nodes::Vector{<:Point}) where T","category":"page"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.LagrangianDofBasis","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.LagrangianDofBasis","text":"struct LagrangianDofBasis{P,V} <: Dof\n  nodes::Vector{P}\n  dof_to_node::Vector{Int}\n  dof_to_comp::Vector{Int}\n  node_and_comp_to_dof::Vector{V}\nend\n\nType that implements a Lagrangian dof basis.\n\nFields:\n\nnodes::Vector{P} vector of points (P<:Point) storing the nodal coordinates\nnode_and_comp_to_dof::Vector{V} vector such that node_and_comp_to_dof[node][comp] returns the dof associated with node node and the component comp in the type V.\ndof_to_node::Vector{Int} vector of integers such that dof_to_node[dof] returns the node id associated with dof id dof.\ndof_to_comp::Vector{Int} vector of integers such that dof_to_comp[dof] returns the component id associated with dof id dof.\n\n\n\n\n\n","category":"type"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.LagrangianDofBasis-Union{Tuple{T}, Tuple{Type{T},Array{var\"#s18\",1} where var\"#s18\"<:(VectorValue{D,T} where T where D)}} where T","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.LagrangianDofBasis","text":"LagrangianDofBasis(::Type{T},nodes::Vector{<:Point}) where T\n\nCreates a LagrangianDofBasis for fields of value type T associated with the vector of nodal coordinates nodes.\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Reference-Finite-Elements-1","page":"Gridap.ReferenceFEs","title":"Reference Finite Elements","text":"","category":"section"},{"location":"ReferenceFEs/#Interface-3","page":"Gridap.ReferenceFEs","title":"Interface","text":"","category":"section"},{"location":"ReferenceFEs/#","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs","text":"ReferenceFE\nnum_dofs(reffe::ReferenceFE)\nget_polytope(reffe::ReferenceFE)\nget_prebasis(reffe::ReferenceFE)\nget_dof_basis(reffe::ReferenceFE)\nget_face_own_dofs(reffe::ReferenceFE)\nget_face_own_dofs_permutations(reffe::ReferenceFE)\nget_face_dofs(reffe::ReferenceFE)\nINVALID_PERM\ntest_reference_fe(reffe::ReferenceFE{D}) where D\nnum_dims(reffe::ReferenceFE)\nnum_cell_dims(reffe::ReferenceFE)\nnum_point_dims(reffe::ReferenceFE)\nnum_faces(reffe::ReferenceFE)\nnum_vertices(reffe::ReferenceFE)\nnum_edges(reffe::ReferenceFE)\nnum_facets(reffe::ReferenceFE)\nget_face_own_dofs(reffe::ReferenceFE,d::Integer)\nget_face_own_dofs_permutations(reffe::ReferenceFE,d::Integer)\nget_own_dofs_permutations(reffe::ReferenceFE)\nget_face_dofs(reffe::ReferenceFE,d::Integer)\nget_shapefuns(reffe::ReferenceFE)\ncompute_shapefuns(dofs,prebasis)","category":"page"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.ReferenceFE","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.ReferenceFE","text":"abstract type ReferenceFE{D} <: GridapType\n\nAbstract type representing a Reference finite element. D is the underlying coordinate space dimension. We follow the Ciarlet definition. A reference finite element is defined by a polytope (cell topology), a basis of an interpolation space of top of this polytope (denoted here as the prebasis), and a basis of the dual of this space (i.e. the degrees of freedom). From this information one can compute the shape functions (i.e, the canonical basis of w.r.t. the degrees of freedom) with a simple change of basis. In addition, we also encode in this type information about how the interpolation space in a reference finite element is \"glued\" with neighbors in order to build conforming cell-wise spaces.\n\nThe ReferenceFE interface is defined by overloading these methods:\n\nnum_dofs(reffe::ReferenceFE)\nget_polytope(reffe::ReferenceFE)\nget_prebasis(reffe::ReferenceFE)\nget_dof_basis(reffe::ReferenceFE)\nget_default_conformity(reffe::ReferenceFE)\nget_face_own_dofs(reffe::ReferenceFE,conf::Conformity)\nget_face_own_dofs_permutations(reffe::ReferenceFE,conf::Conformity)\nget_face_dofs(reffe::ReferenceFE)\n\nThe interface is tested with\n\ntest_reference_fe(reffe::ReferenceFE)\n\n\n\n\n\n","category":"type"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.num_dofs-Tuple{Gridap.ReferenceFEs.ReferenceFE}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.num_dofs","text":"num_dofs(reffe::ReferenceFE) -> Int\n\nReturns the number of DOFs.\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.get_polytope-Tuple{Gridap.ReferenceFEs.ReferenceFE}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.get_polytope","text":"get_polytope(reffe::ReferenceFE) -> Polytope\n\nReturns the underlying polytope object.\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.get_prebasis-Tuple{Gridap.ReferenceFEs.ReferenceFE}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.get_prebasis","text":"get_prebasis(reffe::ReferenceFE) -> Field\n\nReturns the underlying prebasis encoded as a Field object.\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.get_dof_basis-Tuple{Gridap.ReferenceFEs.ReferenceFE}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.get_dof_basis","text":"get_dof_basis(reffe::ReferenceFE) -> Dof\n\nReturns the underlying dof basis encoded in a Dof object. \n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.get_face_own_dofs-Tuple{Gridap.ReferenceFEs.ReferenceFE}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.get_face_own_dofs","text":"get_face_own_dofs(reffe::ReferenceFE) -> Vector{Vector{Int}}\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.get_face_own_dofs_permutations-Tuple{Gridap.ReferenceFEs.ReferenceFE}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.get_face_own_dofs_permutations","text":"get_face_own_dofs_permutations(reffe::ReferenceFE) -> Vector{Vector{Vector{Int}}}\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.get_face_dofs-Tuple{Gridap.ReferenceFEs.ReferenceFE}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.get_face_dofs","text":"get_face_dofs(reffe::ReferenceFE) -> Vector{Vector{Int}}\n\nReturns a vector of vector that, for each face, stores the dofids in the closure of the face.\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.INVALID_PERM","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.INVALID_PERM","text":"Constant of type Int  used to signal that a permutation is not valid.\n\n\n\n\n\n","category":"constant"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.test_reference_fe-Union{Tuple{Gridap.ReferenceFEs.ReferenceFE{D}}, Tuple{D}} where D","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.test_reference_fe","text":"test_reference_fe(reffe::ReferenceFE{D}) where D\n\nTest if the methods in the ReferenceFE interface are defined for the object reffe.\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.Integration.num_dims-Tuple{Gridap.ReferenceFEs.ReferenceFE}","page":"Gridap.ReferenceFEs","title":"Gridap.Integration.num_dims","text":"num_dims(::Type{<:ReferenceFE{D}}) where D\nnum_dims(reffe::ReferenceFE{D}) where D\n\nReturns D.\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.num_cell_dims-Tuple{Gridap.ReferenceFEs.ReferenceFE}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.num_cell_dims","text":"num_cell_dims(::Type{<:ReferenceFE{D}}) where D\nnum_cell_dims(reffe::ReferenceFE{D}) where D\n\nReturns D.\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.Integration.num_point_dims-Tuple{Gridap.ReferenceFEs.ReferenceFE}","page":"Gridap.ReferenceFEs","title":"Gridap.Integration.num_point_dims","text":"num_point_dims(::Type{<:ReferenceFE{D}}) where D\nnum_point_dims(reffe::ReferenceFE{D}) where D\n\nReturns D.\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.num_faces-Tuple{Gridap.ReferenceFEs.ReferenceFE}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.num_faces","text":"num_faces(reffe::ReferenceFE)\nnum_faces(reffe::ReferenceFE,d::Integer)\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.num_vertices-Tuple{Gridap.ReferenceFEs.ReferenceFE}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.num_vertices","text":"num_vertices(reffe::ReferenceFE)\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.num_edges-Tuple{Gridap.ReferenceFEs.ReferenceFE}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.num_edges","text":"num_edges(reffe::ReferenceFE)\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.num_facets-Tuple{Gridap.ReferenceFEs.ReferenceFE}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.num_facets","text":"num_facets(reffe::ReferenceFE)\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.get_face_own_dofs-Tuple{Gridap.ReferenceFEs.ReferenceFE,Integer}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.get_face_own_dofs","text":"get_face_own_dofs(reffe::ReferenceFE,d::Integer)\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.get_face_own_dofs_permutations-Tuple{Gridap.ReferenceFEs.ReferenceFE,Integer}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.get_face_own_dofs_permutations","text":"get_face_own_dofs_permutations(reffe::ReferenceFE,d::Integer)\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.get_own_dofs_permutations-Tuple{Gridap.ReferenceFEs.ReferenceFE}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.get_own_dofs_permutations","text":"get_own_dofs_permutations(reffe::ReferenceFE)\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.get_face_dofs-Tuple{Gridap.ReferenceFEs.ReferenceFE,Integer}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.get_face_dofs","text":"get_face_dofs(reffe::ReferenceFE,d::Integer)\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.get_shapefuns-Tuple{Gridap.ReferenceFEs.ReferenceFE}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.get_shapefuns","text":"get_shapefuns(reffe::ReferenceFE) -> Field\n\nReturns the basis of shape functions (i.e. the canonical basis) associated with the reference FE. The result is encoded as a Field object.\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.compute_shapefuns-Tuple{Any,Any}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.compute_shapefuns","text":"compute_shapefuns(dofs,prebasis)\n\nHelper function used to compute the shape function basis associated with the dof basis dofs and the basis prebasis.\n\nIt is equivalent to\n\nchange = inv(evaluate(dofs,prebasis))\nchange_basis(prebasis,change)\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Generic-reference-elements-1","page":"Gridap.ReferenceFEs","title":"Generic reference elements","text":"","category":"section"},{"location":"ReferenceFEs/#","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs","text":"GenericRefFE\nGenericRefFE(\n  ndofs::Int,\n  polytope::Polytope{D},\n  prebasis::Field,\n  dofs::Dof,\n  face_own_dofs::Vector{Vector{Int}},\n  face_own_dofs_permutations::Vector{Vector{Vector{Int}}},\n  face_dofs::Vector{Vector{Int}},\n  shapefuns::Field=compute_shapefuns(dofs,prebasis)) where D","category":"page"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.GenericRefFE","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.GenericRefFE","text":"struct GenericRefFE{C<:Conformity,D} <: ReferenceFE{D}\n  # + private fields\nend\n\nThis type is a materialization of the ReferenceFE interface. That is, it is a  struct that stores the values of all abstract methods in the ReferenceFE interface. This type is useful to build reference FEs from the underlying ingredients without the need to create a new type.\n\nNote that some fields in this struct are type unstable deliberately in order to simplify the type signature. Don't access them in computationally expensive functions, instead extract the required fields before and pass them to the computationally expensive function.\n\n\n\n\n\n","category":"type"},{"location":"ReferenceFEs/#Node-based-reference-Finite-Elements-1","page":"Gridap.ReferenceFEs","title":"Node-based reference Finite Elements","text":"","category":"section"},{"location":"ReferenceFEs/#Interface-4","page":"Gridap.ReferenceFEs","title":"Interface","text":"","category":"section"},{"location":"ReferenceFEs/#","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs","text":"LagrangianRefFE\nget_node_coordinates(reffe::LagrangianRefFE)\nget_node_and_comp_to_dof(reffe::LagrangianRefFE)\nget_face_own_nodes(reffe::LagrangianRefFE)\nget_face_own_nodes_permutations(reffe::LagrangianRefFE)\nget_face_nodes(reffe::LagrangianRefFE)\ntest_nodal_reference_fe\nnum_nodes(reffe::LagrangianRefFE)\nget_dof_to_node(reffe::LagrangianRefFE)\nget_own_nodes_permutations(reffe::LagrangianRefFE)\nget_vertex_node(reffe::LagrangianRefFE)\nget_face_own_nodes(reffe::LagrangianRefFE,d::Integer)\nget_face_own_nodes_permutations(reffe::LagrangianRefFE,d::Integer)\nget_face_nodes(reffe::LagrangianRefFE,d::Integer)","category":"page"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.LagrangianRefFE","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.LagrangianRefFE","text":"abstract type LagrangianRefFE{D} <: ReferenceFE{D}\n\nAbstract type representing a Lagrangian reference FE. Lagrangian in the sense that get_dof_basis returns an instance of LagrangianDofBasis. The interface for this type is defined with the methods of ReferenceFE plus the following ones\n\nget_face_own_nodes(reffe::LagrangianRefFE,conf::Conformity)\nget_face_own_nodes_permutations(reffe::LagrangianRefFE,conf::Conformity)\nget_face_nodes(reffe::LagrangianRefFE)\n\n\n\n\n\n","category":"type"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.get_node_coordinates-Tuple{LagrangianRefFE}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.get_node_coordinates","text":"get_node_coordinates(reffe::LagrangianRefFE)\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.get_node_and_comp_to_dof-Tuple{LagrangianRefFE}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.get_node_and_comp_to_dof","text":"get_node_and_comp_to_dof(reffe::LagrangianRefFE)\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.get_face_own_nodes-Tuple{LagrangianRefFE}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.get_face_own_nodes","text":"get_face_own_nodes(reffe::LagrangianRefFE)\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.get_face_own_nodes_permutations-Tuple{LagrangianRefFE}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.get_face_own_nodes_permutations","text":"get_face_own_nodes_permutations(reffe::LagrangianRefFE)\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.get_face_nodes-Tuple{LagrangianRefFE}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.get_face_nodes","text":"get_face_nodes(reffe::LagrangianRefFE)\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.num_nodes-Tuple{LagrangianRefFE}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.num_nodes","text":"num_nodes(reffe::LagrangianRefFE)\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.get_dof_to_node-Tuple{LagrangianRefFE}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.get_dof_to_node","text":"get_dof_to_node(reffe::LagrangianRefFE)\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.get_own_nodes_permutations-Tuple{LagrangianRefFE}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.get_own_nodes_permutations","text":"get_own_nodes_permutations(reffe::LagrangianRefFE)\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.get_vertex_node-Tuple{LagrangianRefFE}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.get_vertex_node","text":"get_vertex_node(reffe::LagrangianRefFE) -> Vector{Int}\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.get_face_own_nodes-Tuple{LagrangianRefFE,Integer}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.get_face_own_nodes","text":"get_face_own_nodes(reffe::LagrangianRefFE,d::Integer)\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.get_face_own_nodes_permutations-Tuple{LagrangianRefFE,Integer}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.get_face_own_nodes_permutations","text":"get_face_own_nodes_permutations(reffe::LagrangianRefFE,d::Integer)\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.get_face_nodes-Tuple{LagrangianRefFE,Integer}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.get_face_nodes","text":"get_face_nodes(reffe::LagrangianRefFE,d::Integer)\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#GenericNodalCartesianRefFE-1","page":"Gridap.ReferenceFEs","title":"GenericNodalCartesianRefFE","text":"","category":"section"},{"location":"ReferenceFEs/#","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs","text":"GenericNodalCartesianRefFE","category":"page"},{"location":"ReferenceFEs/#Lagrangian-reference-elements-1","page":"Gridap.ReferenceFEs","title":"Lagrangian reference elements","text":"","category":"section"},{"location":"ReferenceFEs/#","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs","text":"LagrangianRefFE\nLagrangianRefFE(\n  polytope::Polytope{D},\n  prebasis::MonomialBasis,\n  dofs::LagrangianDofBasis,\n  face_own_nodes::Vector{Vector{Int}},\n  own_nodes_permutations::Vector{Vector{Int}},\n  reffaces) where D\nLagrangianRefFE(::Type{T},p::Polytope{D},orders) where {T,D}\ncompute_monomial_basis(::Type{T},p::Polytope,orders) where T\ncompute_own_nodes(p::Polytope,orders)\ncompute_face_orders(p::Polytope,face::Polytope,iface::Int,orders)\ncompute_nodes(p::Polytope,orders)\ncompute_own_nodes_permutations(p::Polytope, interior_nodes)\ncompute_lagrangian_reffaces(::Type{T},p::Polytope,orders) where T\nget_dof_to_comp(reffe::LagrangianRefFE)\nReferenceFE{N}(reffe::LagrangianRefFE,nfaceid::Integer) where N\n(==)(a::LagrangianRefFE{D},b::LagrangianRefFE{D}) where D\nget_reffaces(::Type{ReferenceFE{d}},reffe::LagrangianRefFE) where d\nget_face_type(reffe::LagrangianRefFE, d::Integer)\nis_first_order(reffe::LagrangianRefFE)\nis_affine(reffe::LagrangianRefFE)\nis_P(reffe::LagrangianRefFE)\nis_Q(reffe::LagrangianRefFE)\nis_S(reffe::LagrangianRefFE)","category":"page"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.LagrangianRefFE-Union{Tuple{D}, Tuple{T}, Tuple{Type{T},Polytope{D},Any}} where D where T","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.LagrangianRefFE","text":"LagrangianRefFE(::Type{T},p::Polytope,orders) where T\nLagrangianRefFE(::Type{T},p::Polytope,order::Int) where T\n\nBuilds a LagrangianRefFE object on top of the given polytope. T is the type of the value of the approximation space (e.g., T=Float64 for scalar-valued problems, T=VectorValue{N,Float64} for vector-valued problems with N components). The arguments order or orders are for the polynomial order of the resulting space, which allows isotropic or anisotropic orders respectively (provided that the cell topology allows the given anisotropic order). The argument orders should be an indexable collection of D integers (e.g., a tuple or a vector), being D the number of space dimensions.\n\nIn order to be able to use this function, the type of the provided polytope p has to implement the following additional methods. They have been implemented for ExtrusionPolytope in the library. They need to be implemented for new polytope types in order to build Lagangian reference elements on top of them.\n\ncompute_monomial_basis(::Type{T},p::Polytope,orders) where T\ncompute_own_nodes(p::Polytope,orders)\ncompute_face_orders(p::Polytope,face::Polytope,iface::Int,orders)\n\nThe following methods are also used in the construction of the LagrangianRefFE object. A default implementation of them is available in terms of the three previous methods. However, the user can also implement them for new polytope types increasing customization possibilities.\n\ncompute_nodes(p::Polytope,orders)\ncompute_own_nodes_permutations(p::Polytope, interior_nodes)\ncompute_lagrangian_reffaces(::Type{T},p::Polytope,orders) where T\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.compute_monomial_basis-Union{Tuple{T}, Tuple{Type{T},Polytope,Any}} where T","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.compute_monomial_basis","text":"compute_monomial_basis(::Type{T},p::Polytope,orders) where T -> MonomialBasis\n\nReturns the monomial basis of value type T and order per direction described by orders on top of the polytope p.\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.compute_own_nodes-Tuple{Polytope,Any}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.compute_own_nodes","text":"compute_own_nodes(p::Polytope{D},orders) where D -> Vector{Point{D,Float64}}\n\nReturns the coordinates of the nodes owned by the interior of the polytope associated with a Lagrangian space with the order per direction described by orders.\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.compute_face_orders-Tuple{Polytope,Polytope,Int64,Any}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.compute_face_orders","text":"compute_face_orders(p::Polytope,face::Polytope,iface::Int,orders)\n\nReturns a vector or a tuple with the order per direction at the face face of the polytope p when restricting the order per direction orders to this face. iface is the face id of face in the numeration restricted to the face dimension.\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.compute_nodes-Tuple{Polytope,Any}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.compute_nodes","text":"compute_nodes(p::Polytope,orders)\n\nWhen called\n\nnode_coords, face_own_nodes = compute_nodes(p,orders)\n\nReturns node_coords, the nodal coordinates of all the Lagrangian nodes associated with the order per direction orders, and face_own_nodes, being a vector of vectors indicating which nodes are owned by each of the faces of the polytope p.\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.compute_own_nodes_permutations-Tuple{Polytope,Any}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.compute_own_nodes_permutations","text":"compute_own_nodes_permutations(\n  p::Polytope, own_nodes_coordinates) -> Vector{Vector{Int}}\n\nReturns a vector of vectors with the permutations of the nodes owned by the interior of the polytope.\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.compute_lagrangian_reffaces-Union{Tuple{T}, Tuple{Type{T},Polytope,Any}} where T","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.compute_lagrangian_reffaces","text":"compute_lagrangian_reffaces(::Type{T},p::Polytope,orders) where T\n\nReturns a tuple of length D being the number of space dimensions. The entry d+1 of this tuple contains a vector of LagrangianRefFE one for each face of dimension d on the boundary of the polytope.\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.get_dof_to_comp-Tuple{LagrangianRefFE}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.get_dof_to_comp","text":"get_dof_to_comp(reffe::LagrangianRefFE)\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Base.:==-Union{Tuple{D}, Tuple{LagrangianRefFE{D},LagrangianRefFE{D}}} where D","page":"Gridap.ReferenceFEs","title":"Base.:==","text":"(==)(a::LagrangianRefFE{D}, b::LagrangianRefFE{D}) where D\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Serendipity-reference-elements-1","page":"Gridap.ReferenceFEs","title":"Serendipity reference elements","text":"","category":"section"},{"location":"ReferenceFEs/#","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs","text":"SerendipityRefFE","category":"page"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.SerendipityRefFE","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.SerendipityRefFE","text":"SerendipityRefFE(::Type{T},p::Polytope,order::Int) where T\nSerendipityRefFE(::Type{T},p::Polytope,orders::Tuple) where T\n\nReturns an instance of LagrangianRefFE, whose underlying approximation space is the serendipity space of order order. Implemented for order from 1 to 4. The type of the polytope p has to implement all the queries detailed in the constructor LagrangianRefFE(::Type{T},p::Polytope{D},orders) where {T,D}.\n\nExamples\n\nusing Gridap.ReferenceFEs\n\norder = 2\nreffe = SerendipityRefFE(Float64,QUAD,order)\n\nprintln( num_dofs(reffe) )\n\n# output\n8\n\n\n\n\n\n\n","category":"function"},{"location":"ReferenceFEs/#PDiscRefFE-1","page":"Gridap.ReferenceFEs","title":"PDiscRefFE","text":"","category":"section"},{"location":"ReferenceFEs/#","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs","text":"PDiscRefFE","category":"page"},{"location":"ReferenceFEs/#RaviartThomasRefFE-1","page":"Gridap.ReferenceFEs","title":"RaviartThomasRefFE","text":"","category":"section"},{"location":"ReferenceFEs/#","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs","text":"RaviartThomasRefFE","category":"page"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.RaviartThomasRefFE","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.RaviartThomasRefFE","text":"RaviartThomasRefFE(::Type{et},p::Polytope,order::Integer) where et\n\nThe order argument has the following meaning: the divergence of the  functions in this basis is in the Q space of degree order.\n\n\n\n\n\n","category":"function"},{"location":"ReferenceFEs/#NedelecRefFE-1","page":"Gridap.ReferenceFEs","title":"NedelecRefFE","text":"","category":"section"},{"location":"ReferenceFEs/#","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs","text":"NedelecRefFE","category":"page"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.NedelecRefFE","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.NedelecRefFE","text":"NedelecRefFE(::Type{et},p::Polytope,order::Integer) where et\n\nThe order argument has the following meaning: the curl of the  functions in this basis is in the Q space of degree order.\n\n\n\n\n\n","category":"function"},{"location":"ReferenceFEs/#Pre-defined-ReferenceFE-instances-1","page":"Gridap.ReferenceFEs","title":"Pre-defined ReferenceFE instances","text":"","category":"section"},{"location":"ReferenceFEs/#","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs","text":"VERTEX1\nSEG2\nTRI3\nQUAD4\nTET4\nHEX8","category":"page"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.VERTEX1","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.VERTEX1","text":"const VERTEX1 = LagrangianRefFE(Float64,VERTEX,1)\n\n\n\n\n\n","category":"constant"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.SEG2","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.SEG2","text":"const SEG2 = LagrangianRefFE(Float64,SEGMENT,1)\n\n\n\n\n\n","category":"constant"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.TRI3","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.TRI3","text":"const TRI3 = LagrangianRefFE(Float64,TRI,1)\n\n\n\n\n\n","category":"constant"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.QUAD4","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.QUAD4","text":"const QUAD4 = LagrangianRefFE(Float64,QUAD,1)\n\n\n\n\n\n","category":"constant"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.TET4","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.TET4","text":"const TET4 = LagrangianRefFE(Float64,TET,1)\n\n\n\n\n\n","category":"constant"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.HEX8","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.HEX8","text":"const HEX8 = LagrangianRefFE(Float64,HEX,1)\n\n\n\n\n\n","category":"constant"},{"location":"Helpers/#","page":"Gridap.Helpers","title":"Gridap.Helpers","text":"CurrentModule = Gridap.Helpers","category":"page"},{"location":"Helpers/#Gridap.Helpers-1","page":"Gridap.Helpers","title":"Gridap.Helpers","text":"","category":"section"},{"location":"Helpers/#","page":"Gridap.Helpers","title":"Gridap.Helpers","text":"Modules = [Helpers,]","category":"page"},{"location":"Helpers/#Gridap.Helpers","page":"Gridap.Helpers","title":"Gridap.Helpers","text":"This module provides a set of helper macros and helper functions\n\nThe exported macros are:\n\nGridapType\n@abstractmethod\nget_val_parameter\n@notimplemented\n@notimplementedif\noperate\ntfill\n@unreachable\n\n\n\n\n\n","category":"module"},{"location":"Helpers/#Gridap.Helpers.GridapType","page":"Gridap.Helpers","title":"Gridap.Helpers.GridapType","text":"abstract type GridapType end\n\n\n\n\n\n","category":"type"},{"location":"Helpers/#Gridap.Helpers.get_val_parameter-Union{Tuple{Val{T}}, Tuple{T}} where T","page":"Gridap.Helpers","title":"Gridap.Helpers.get_val_parameter","text":"get_val_parameter(::Val{T}) where T\nget_val_parameter(::Type{Val{T}}) where T\n\nReturns T.\n\n\n\n\n\n","category":"method"},{"location":"Helpers/#Gridap.Helpers.operate-Tuple{Any,Any,Any}","page":"Gridap.Helpers","title":"Gridap.Helpers.operate","text":"\n\n\n\n","category":"method"},{"location":"Helpers/#Gridap.Helpers.operate-Tuple{Any,Any}","page":"Gridap.Helpers","title":"Gridap.Helpers.operate","text":"\n\n\n\n","category":"method"},{"location":"Helpers/#Gridap.Helpers.tfill-Union{Tuple{D}, Tuple{Any,Val{D}}} where D","page":"Gridap.Helpers","title":"Gridap.Helpers.tfill","text":"tfill(v, ::Val{D}) where D\n\nReturns a tuple of length D that contains D times the object v. In contrast to tuple(fill(v,D)...) which returns the same result, this function is type-stable.\n\n\n\n\n\n","category":"method"},{"location":"Helpers/#Gridap.Helpers.@abstractmethod-Tuple{}","page":"Gridap.Helpers","title":"Gridap.Helpers.@abstractmethod","text":"@abstractmethod\n\nMacro used in generic functions that must be overloaded by derived types.\n\n\n\n\n\n","category":"macro"},{"location":"Helpers/#Gridap.Helpers.@notimplemented","page":"Gridap.Helpers","title":"Gridap.Helpers.@notimplemented","text":"@notimplemented\n@notimplemented \"Error message\"\n\nMacro used to raise an error, when something is not implemented.\n\n\n\n\n\n","category":"macro"},{"location":"Helpers/#Gridap.Helpers.@notimplementedif","page":"Gridap.Helpers","title":"Gridap.Helpers.@notimplementedif","text":"@notimplementedif condition\n@notimplementedif condition \"Error message\"\n\nMacro used to raise an error if the condition is true\n\n\n\n\n\n","category":"macro"},{"location":"Helpers/#Gridap.Helpers.@unreachable","page":"Gridap.Helpers","title":"Gridap.Helpers.@unreachable","text":"@unreachable\n@unreachable \"Error message\"\n\nMacro used to make sure that a line of code is never reached.\n\n\n\n\n\n","category":"macro"},{"location":"#Gridap.jl-1","page":"Home","title":"Gridap.jl","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Documentation of the Gridap library.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"note: Note\nThese documentation pages are under construction.","category":"page"},{"location":"#Introduction-1","page":"Home","title":"Introduction","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Gridap provides a set of tools for the grid-based approximation of partial differential equations (PDEs) written in the Julia programming language. The main motivation behind the development of this library is to provide an easy-to-use framework for the development of complex PDE solvers in a dynamically typed style without sacrificing the performance of statically typed languages. The library currently supports linear and nonlinear PDE systems for scalar and vector fields, single and multi-field problems, conforming and nonconforming finite element discretizations, on structured and unstructured meshes of simplices and hexahedra.","category":"page"},{"location":"#How-to-use-this-documentation-1","page":"Home","title":"How to use this documentation","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"The first step for new users is to visit the Getting Started page.\nA set of tutorials written as Jupyter notebooks and html pages are available here.\nThe detailed documentation is in the Manual section.\nGuidelines for developers of the Gridap project is found in the Gridap wiki page.","category":"page"},{"location":"#Julia-educational-resources-1","page":"Home","title":"Julia educational resources","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"A basic knowledge of the Julia programming language is needed to use the Gridap package. Here, one can find a list of resources to get started with this programming language.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"First steps to learn Julia form the Gridap wiki page.\nOfficial webpage docs.julialang.org\nOfficial list of learning resources julialang.org/learning","category":"page"},{"location":"#Manual-1","page":"Home","title":"Manual","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Pages = [\n  \"Gridap.md\",\n  \"Helpers.md\",\n  \"Inference.md\",\n  \"Io.md\",\n  \"Algebra.md\",\n  \"TensorValues.md\",\n  \"Arrays.md\",\n  \"Fields.md\",\n  \"Polynomials.md\",\n  \"Integration.md\",\n  \"ReferenceFEs.md\",\n  \"Geometry.md\",\n  \"FESpaces.md\",\n  \"MultiField.md\",\n  \"Visualization.md\",\n  ]","category":"page"},{"location":"Geometry/#","page":"Gridap.Geometry","title":"Gridap.Geometry","text":"CurrentModule = Gridap.Geometry","category":"page"},{"location":"Geometry/#Gridap.Geometry-1","page":"Gridap.Geometry","title":"Gridap.Geometry","text":"","category":"section"},{"location":"Geometry/#","page":"Gridap.Geometry","title":"Gridap.Geometry","text":"Geometry","category":"page"},{"location":"Geometry/#Gridap.Geometry","page":"Gridap.Geometry","title":"Gridap.Geometry","text":"Exported names are\n\nAppendedTriangulation\nBoundaryTriangulation\nCartesianDescriptor\nCartesianDiscreteModel\nCartesianGrid\nDiscreteModel\nDiscreteModelFromFile\nDiscreteModelPortion\nFaceLabeling\nGenericBoundaryTriangulation\nGrid\nGridPortion\nGridTopology\nInterfaceTriangulation\nOrientationStyle\nRegularityStyle\nRestrictedDiscreteModel\nRestrictedTriangulation\nSkeletonPair\nSkeletonTriangulation\nTriangulation\nTriangulationPortion\nUnstructuredDiscreteModel\nUnstructuredGrid\nUnstructuredGridTopology\nadd_tag!\nadd_tag_from_tags!\ncell_measure\ncompute_cell_faces\ncompute_cell_permutations\ncompute_face_nodes\ncompute_face_own_nodes\ncompute_face_vertices\ncompute_isboundary_face\ncompute_linear_grid\ncompute_node_face_owner\ncompute_reference_grid\ncompute_reffaces\ncompute_vertex_node\nget_cartesian_descriptor\nget_cell_around\nget_cell_coordinates\nget_cell_entity\nget_cell_faces\nget_cell_id\nget_cell_map\nget_cell_nodes\nget_cell_permutations\nget_cell_reffes\nget_cell_shapefuns\nget_cell_type\nget_cell_vertices\nget_face_entity\nget_face_labeling\nget_face_mask\nget_face_tag\nget_face_tag_index\nget_face_to_cell\nget_face_to_cell_map\nget_face_to_face\nget_face_to_lface\nget_grid\nget_grid_topology\nget_isboundary_face\nget_left_boundary\nget_node_face_owner\nget_normal_vector\nget_physical_coordinate\nget_polytopes\nget_reffaces_offsets\nget_reffes\nget_right_boundary\nget_tag_entities\nget_tag_from_name\nget_tag_name\nget_tags_from_names\nget_triangulation\nget_volume_triangulation\nis_oriented\nis_regular\nnum_cells\nnum_entities\nnum_tags\nrestrict\ntest_boundary_triangulation\ntest_discrete_model\ntest_grid\ntest_grid_topology\ntest_triangulation\n\n\n\n\n\n","category":"module"},{"location":"Geometry/#Triangulations-1","page":"Gridap.Geometry","title":"Triangulations","text":"","category":"section"},{"location":"Geometry/#Interface-1","page":"Gridap.Geometry","title":"Interface","text":"","category":"section"},{"location":"Geometry/#","page":"Gridap.Geometry","title":"Gridap.Geometry","text":"Triangulation\nget_cell_coordinates(trian::Triangulation)\nget_reffes(trian::Triangulation)\nget_cell_type(trian::Triangulation)\nget_normal_vector(trian::Triangulation)\nrestrict(f::AbstractArray, trian::Triangulation)\nreindex(f::AbstractArray,trian::Triangulation)\ntest_triangulation\nnum_cells(trian::Triangulation)\nnum_cell_dims(::Triangulation{Dc,Dp}) where {Dc,Dp}\nnum_point_dims(::Triangulation{Dc,Dp}) where {Dc,Dp}\nnum_dims(g::Triangulation{Dc}) where Dc\nis_affine(trian::Triangulation)\nis_first_order(trian::Triangulation)\nget_cell_reffes(trian::Triangulation)\nget_cell_shapefuns(trian::Triangulation)\nget_cell_map(trian::Triangulation)\nget_physical_coordinate(trian::Triangulation)","category":"page"},{"location":"Geometry/#Gridap.Geometry.Triangulation","page":"Gridap.Geometry","title":"Gridap.Geometry.Triangulation","text":"abstract type Triangulation{Dc,Dp}\n\nAbstract type representing an arbitrary tiling, tessellation, or triangulation of a domain of parametric dimension Dc and physical dimension Dp.\n\nWe define a triangulation from two basic ingredients: \n\nthe cell-wise nodal coordinates of the cells in the triangulation, plus\nan interpolation of this cell-wise coordinates into the cells interior.\n\nNote that this type represents general triangulations (not necessarily conforming), which is the minimum geometrical information needed to perform cell-wise numerical integration.\n\nThe Triangulation interface is defined by overloading these methods:\n\nget_cell_coordinates(trian::Triangulation)\nget_reffes(trian::Triangulation)\nget_cell_type(trian::Triangulation)\n\nOptional interface:\n\nFor triangulations living in a space of co-dimension 1, the following method can be defined:\n\n[get_normal_vector(trian::Triangulation)]\n\nIn some cases, concrete implementations want to override the default implementation of the following methods:\n\n[restrict(f::AbstractArray, trian::Triangulation)]\n[get_cell_id(f::AbstractArray, trian::Triangulation)]\n\nThe (mandatory) Triangulation interface can be tested with\n\ntest_triangulation\n\n\n\n\n\n","category":"type"},{"location":"Geometry/#Gridap.Geometry.get_cell_coordinates-Tuple{Triangulation}","page":"Gridap.Geometry","title":"Gridap.Geometry.get_cell_coordinates","text":"get_cell_coordinates(trian::Triangulation) -> AbstractArray{Vector{<:Point{Dp}}}\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.get_reffes-Tuple{Triangulation}","page":"Gridap.Geometry","title":"Gridap.Geometry.get_reffes","text":"get_reffes(trian::Triangulation) -> Vector{LagrangianRefFE}\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.get_cell_type-Tuple{Triangulation}","page":"Gridap.Geometry","title":"Gridap.Geometry.get_cell_type","text":"get_cell_type(trian::Triangulation) -> AbstractVector{<:Integer}\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.get_normal_vector-Tuple{Triangulation}","page":"Gridap.Geometry","title":"Gridap.Geometry.get_normal_vector","text":"get_normal_vector(trian::Triangulation)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.restrict-Tuple{AbstractArray,Triangulation}","page":"Gridap.Geometry","title":"Gridap.Geometry.restrict","text":"restrict(f::AbstractArray, trian::Triangulation)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Arrays.reindex-Tuple{AbstractArray,Triangulation}","page":"Gridap.Geometry","title":"Gridap.Arrays.reindex","text":"reindex(a::AbstractArray, trian::Triangulation)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.test_triangulation","page":"Gridap.Geometry","title":"Gridap.Geometry.test_triangulation","text":"test_triangulation(trian::Triangulation)\n\n\n\n\n\n","category":"function"},{"location":"Geometry/#Gridap.Geometry.num_cells-Tuple{Triangulation}","page":"Gridap.Geometry","title":"Gridap.Geometry.num_cells","text":"num_cells(trian::Triangulation) -> Int\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.ReferenceFEs.num_cell_dims-Union{Tuple{Triangulation{Dc,Dp}}, Tuple{Dp}, Tuple{Dc}} where Dp where Dc","page":"Gridap.Geometry","title":"Gridap.ReferenceFEs.num_cell_dims","text":"num_cell_dims(::GridTopology) -> Int\nnum_cell_dims(::Type{<:GridTopology}) -> Int\n\n\n\n\n\nnum_cell_dims(::Triangulation) -> Int\nnum_cell_dims(::Type{<:Triangulation}) -> Int\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Integration.num_point_dims-Union{Tuple{Triangulation{Dc,Dp}}, Tuple{Dp}, Tuple{Dc}} where Dp where Dc","page":"Gridap.Geometry","title":"Gridap.Integration.num_point_dims","text":"num_point_dims(::GridTopology) -> Int\nnum_point_dims(::Type{<:GridTopology}) -> Int\n\n\n\n\n\nnum_point_dims(::Triangulation) -> Int\nnum_point_dims(::Type{<:Triangulation}) -> Int\n\n\n\n\n\nnum_point_dims(::Quadrature{D}) where D\nnum_point_dims(::Type{<:Quadrature{D}}) where D\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Integration.num_dims-Union{Tuple{Triangulation{Dc,Dp} where Dp}, Tuple{Dc}} where Dc","page":"Gridap.Geometry","title":"Gridap.Integration.num_dims","text":"num_dims(::GridTopology) -> Int\nnum_dims(::Type{<:GridTopology}) -> Int\n\nEquivalent to num_cell_dims.\n\n\n\n\n\nnum_dims(::Triangulation) -> Int\nnum_dims(::Type{<:Triangulation}) -> Int\n\nEquivalent to num_cell_dims.\n\n\n\n\n\nnum_dims(::Quadrature{D}) where D where D\nnum_dims(::Type{<:Quadrature{D}}) where D\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.ReferenceFEs.is_affine-Tuple{Triangulation}","page":"Gridap.Geometry","title":"Gridap.ReferenceFEs.is_affine","text":"is_affine(trian::Triangulation) -> Bool\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.ReferenceFEs.is_first_order-Tuple{Triangulation}","page":"Gridap.Geometry","title":"Gridap.ReferenceFEs.is_first_order","text":"is_first_order(trian::Triangulation) -> Bool\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.get_cell_reffes-Tuple{Triangulation}","page":"Gridap.Geometry","title":"Gridap.Geometry.get_cell_reffes","text":"get_cell_reffes(trian::Triangulation) -> Vector{<:LagrangianRefFE}\n\nIt is not desirable to iterate over the resulting array for large number of cells if the underlying reference FEs are of different Julia type.\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.get_cell_shapefuns-Tuple{Triangulation}","page":"Gridap.Geometry","title":"Gridap.Geometry.get_cell_shapefuns","text":"get_cell_shapefuns(trian::Triangulation) -> Vector{<:Field}\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.CellData.get_cell_map-Tuple{Triangulation}","page":"Gridap.Geometry","title":"Gridap.CellData.get_cell_map","text":"get_cell_map(trian::Triangulation) -> Vector{<:Field}\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.get_physical_coordinate-Tuple{Triangulation}","page":"Gridap.Geometry","title":"Gridap.Geometry.get_physical_coordinate","text":"get_physical_coordinate(trian::Triangulation)\n\nIn contrast to getcellmap, the returned object:\n\nis a CellField\nits gradient is the identity tensor\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Integrating-on-a-triangulation-1","page":"Gridap.Geometry","title":"Integrating on a triangulation","text":"","category":"section"},{"location":"Geometry/#","page":"Gridap.Geometry","title":"Gridap.Geometry","text":"CellQuadrature\nCellQuadrature(array::AbstractArray{<:Quadrature})\nCellQuadrature(trian::Triangulation, degree::Integer)\nCellQuadrature(degree,polytopes::Vector{<:Polytope}, cell_types::AbstractVector)\nget_coordinates(quad::CellQuadrature)\nget_weights(quad::CellQuadrature)\nget_array(quad::CellQuadrature)\nintegrate(cell_field,trian::Triangulation,quad::CellQuadrature)","category":"page"},{"location":"Geometry/#Gridap.CellData.CellQuadrature","page":"Gridap.Geometry","title":"Gridap.CellData.CellQuadrature","text":"struct CellQuadrature <: GridapType\n  array\nend\n\n\n\n\n\n","category":"type"},{"location":"Geometry/#Gridap.CellData.CellQuadrature-Tuple{AbstractArray{var\"#s18\",N} where N where var\"#s18\"<:Gridap.Integration.Quadrature}","page":"Gridap.Geometry","title":"Gridap.CellData.CellQuadrature","text":"CellQuadrature(array::AbstractArray{<:Quadrature})\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.CellData.CellQuadrature-Tuple{Triangulation,Integer}","page":"Gridap.Geometry","title":"Gridap.CellData.CellQuadrature","text":"CellQuadrature(trian::Triangulation, degree::Integer)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.CellData.CellQuadrature-Tuple{Any,Array{var\"#s18\",1} where var\"#s18\"<:Polytope,AbstractArray{T,1} where T}","page":"Gridap.Geometry","title":"Gridap.CellData.CellQuadrature","text":"CellQuadrature(degree,polytopes::Vector{<:Polytope}, cell_types::AbstractVector)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Integration.get_coordinates-Tuple{CellQuadrature}","page":"Gridap.Geometry","title":"Gridap.Integration.get_coordinates","text":"get_coordinates(q::CellQuadrature)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Integration.get_weights-Tuple{CellQuadrature}","page":"Gridap.Geometry","title":"Gridap.Integration.get_weights","text":"get_weights(q::CellQuadrature)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Arrays.get_array-Tuple{CellQuadrature}","page":"Gridap.Geometry","title":"Gridap.Arrays.get_array","text":"get_array(quad::CellQuadrature)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Fields.integrate-Tuple{Any,Triangulation,CellQuadrature}","page":"Gridap.Geometry","title":"Gridap.Fields.integrate","text":"integrate(cell_field,trian::Triangulation,quad::CellQuadrature)\n\nThe cell_field is aligned with the cells in trian\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#TriangulationPortion-1","page":"Gridap.Geometry","title":"TriangulationPortion","text":"","category":"section"},{"location":"Geometry/#","page":"Gridap.Geometry","title":"Gridap.Geometry","text":"TriangulationPortion\nTriangulationPortion(oldtrian::Triangulation{Dc,Dp},cell_to_oldcell::Vector{Int}) where {Dc,Dp}","category":"page"},{"location":"Geometry/#Gridap.Geometry.TriangulationPortion","page":"Gridap.Geometry","title":"Gridap.Geometry.TriangulationPortion","text":"\n\n\n\n","category":"type"},{"location":"Geometry/#Gridap.Geometry.TriangulationPortion-Union{Tuple{Dp}, Tuple{Dc}, Tuple{Triangulation{Dc,Dp},Array{Int64,1}}} where Dp where Dc","page":"Gridap.Geometry","title":"Gridap.Geometry.TriangulationPortion","text":"\n\n\n\n","category":"method"},{"location":"Geometry/#RestrictedTriangulation-1","page":"Gridap.Geometry","title":"RestrictedTriangulation","text":"","category":"section"},{"location":"Geometry/#","page":"Gridap.Geometry","title":"Gridap.Geometry","text":"RestrictedTriangulation","category":"page"},{"location":"Geometry/#Gridap.Geometry.RestrictedTriangulation","page":"Gridap.Geometry","title":"Gridap.Geometry.RestrictedTriangulation","text":"\n\n\n\n","category":"type"},{"location":"Geometry/#BoundaryTriangulations-1","page":"Gridap.Geometry","title":"BoundaryTriangulations","text":"","category":"section"},{"location":"Geometry/#Interface-2","page":"Gridap.Geometry","title":"Interface","text":"","category":"section"},{"location":"Geometry/#","page":"Gridap.Geometry","title":"Gridap.Geometry","text":"BoundaryTriangulation\nBoundaryTriangulation(model::DiscreteModel,face_to_mask::Vector{Bool})\nBoundaryTriangulation(model::DiscreteModel,tags::Vector{Int})\nget_volume_triangulation(trian::BoundaryTriangulation)\nget_face_to_cell(trian::BoundaryTriangulation)\nget_face_to_lface(trian::BoundaryTriangulation)\nget_face_to_cell_map(trian::BoundaryTriangulation)\nget_normal_vector(trian::BoundaryTriangulation)\ntest_boundary_triangulation","category":"page"},{"location":"Geometry/#Gridap.Geometry.BoundaryTriangulation","page":"Gridap.Geometry","title":"Gridap.Geometry.BoundaryTriangulation","text":"abstract type BoundaryTriangulation{Dc,Dp} <: Triangulation{Dc,Dp}\n\n\n\n\n\n","category":"type"},{"location":"Geometry/#Gridap.Geometry.BoundaryTriangulation-Tuple{DiscreteModel,Array{Bool,1}}","page":"Gridap.Geometry","title":"Gridap.Geometry.BoundaryTriangulation","text":"BoundaryTriangulation(model::DiscreteModel,tags::Vector{Int})\nBoundaryTriangulation(model::DiscreteModel,tags::Vector{String})\nBoundaryTriangulation(model::DiscreteModel,tag::Int)\nBoundaryTriangulation(model::DiscreteModel,tag::String)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.BoundaryTriangulation-Tuple{DiscreteModel,Array{Int64,1}}","page":"Gridap.Geometry","title":"Gridap.Geometry.BoundaryTriangulation","text":"BoundaryTriangulation(model::DiscreteModel,tags::Vector{Int})\nBoundaryTriangulation(model::DiscreteModel,tags::Vector{String})\nBoundaryTriangulation(model::DiscreteModel,tag::Int)\nBoundaryTriangulation(model::DiscreteModel,tag::String)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.get_volume_triangulation-Tuple{BoundaryTriangulation}","page":"Gridap.Geometry","title":"Gridap.Geometry.get_volume_triangulation","text":"get_volume_triangulation(trian::BoundaryTriangulation)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.get_face_to_cell-Tuple{BoundaryTriangulation}","page":"Gridap.Geometry","title":"Gridap.Geometry.get_face_to_cell","text":"\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.get_face_to_lface-Tuple{BoundaryTriangulation}","page":"Gridap.Geometry","title":"Gridap.Geometry.get_face_to_lface","text":"\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.get_face_to_cell_map-Tuple{BoundaryTriangulation}","page":"Gridap.Geometry","title":"Gridap.Geometry.get_face_to_cell_map","text":"\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.get_normal_vector-Tuple{BoundaryTriangulation}","page":"Gridap.Geometry","title":"Gridap.Geometry.get_normal_vector","text":"\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.test_boundary_triangulation","page":"Gridap.Geometry","title":"Gridap.Geometry.test_boundary_triangulation","text":"test_boundary_triangulation(trian::BoundaryTriangulation)\n\n\n\n\n\n","category":"function"},{"location":"Geometry/#GenericBoundaryTriangulations-1","page":"Gridap.Geometry","title":"GenericBoundaryTriangulations","text":"","category":"section"},{"location":"Geometry/#","page":"Gridap.Geometry","title":"Gridap.Geometry","text":"GenericBoundaryTriangulation\nGenericBoundaryTriangulation(model::DiscreteModel,face_to_mask::Vector{Bool})","category":"page"},{"location":"Geometry/#Gridap.Geometry.GenericBoundaryTriangulation","page":"Gridap.Geometry","title":"Gridap.Geometry.GenericBoundaryTriangulation","text":"struct GenericBoundaryTriangulation{Dc,Dp,Gf,Gc,O} <: BoundaryTriangulation{Dc,Dp}\n  face_trian::Gf\n  cell_trian::Gc\n  # + private fields\nend\n\n\n\n\n\n","category":"type"},{"location":"Geometry/#Gridap.Geometry.GenericBoundaryTriangulation-Tuple{DiscreteModel,Array{Bool,1}}","page":"Gridap.Geometry","title":"Gridap.Geometry.GenericBoundaryTriangulation","text":"GenericBoundaryTriangulation(model::DiscreteModel,face_to_mask::Vector{Bool})\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#SkeletonTriangulations-1","page":"Gridap.Geometry","title":"SkeletonTriangulations","text":"","category":"section"},{"location":"Geometry/#","page":"Gridap.Geometry","title":"Gridap.Geometry","text":"SkeletonTriangulation\nSkeletonTriangulation(model::DiscreteModel,face_to_mask::Vector{Bool})\nInterfaceTriangulation(model::DiscreteModel,cell_to_is_in::Vector{Bool})\nget_volume_triangulation(trian::SkeletonTriangulation)\nget_normal_vector(trian::SkeletonTriangulation)\nget_left_boundary(trian::SkeletonTriangulation)\nget_right_boundary(trian::SkeletonTriangulation)","category":"page"},{"location":"Geometry/#Gridap.Geometry.SkeletonTriangulation","page":"Gridap.Geometry","title":"Gridap.Geometry.SkeletonTriangulation","text":"struct SkeletonTriangulation{Dc,Dp,B} <: Triangulation{Dc,Dp}\n  left::B\n  right::B\nend\n\nThe inner constructor enforces B<:BoundaryTriangulation\n\n\n\n\n\n","category":"type"},{"location":"Geometry/#Gridap.Geometry.SkeletonTriangulation-Tuple{DiscreteModel,Array{Bool,1}}","page":"Gridap.Geometry","title":"Gridap.Geometry.SkeletonTriangulation","text":"SkeletonTriangulation(model::DiscreteModel,face_to_mask::Vector{Bool})\nSkeletonTriangulation(model::DiscreteModel)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.InterfaceTriangulation-Tuple{DiscreteModel,Array{Bool,1}}","page":"Gridap.Geometry","title":"Gridap.Geometry.InterfaceTriangulation","text":"\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.get_volume_triangulation-Tuple{SkeletonTriangulation}","page":"Gridap.Geometry","title":"Gridap.Geometry.get_volume_triangulation","text":"get_volume_triangulation(trian::SkeletonTriangulation)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.get_normal_vector-Tuple{SkeletonTriangulation}","page":"Gridap.Geometry","title":"Gridap.Geometry.get_normal_vector","text":"get_normal_vector(trian::SkeletonTriangulation)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.get_left_boundary-Tuple{SkeletonTriangulation}","page":"Gridap.Geometry","title":"Gridap.Geometry.get_left_boundary","text":"\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.get_right_boundary-Tuple{SkeletonTriangulation}","page":"Gridap.Geometry","title":"Gridap.Geometry.get_right_boundary","text":"\n\n\n\n","category":"method"},{"location":"Geometry/#SkeletonPairs-1","page":"Gridap.Geometry","title":"SkeletonPairs","text":"","category":"section"},{"location":"Geometry/#","page":"Gridap.Geometry","title":"Gridap.Geometry","text":"SkeletonPair","category":"page"},{"location":"Geometry/#Gridap.Geometry.SkeletonPair","page":"Gridap.Geometry","title":"Gridap.Geometry.SkeletonPair","text":"struct SkeletonPair{L,R} <: GridapType\n  left::L\n  right::R\nend\n\n\n\n\n\n","category":"type"},{"location":"Geometry/#Grids-1","page":"Gridap.Geometry","title":"Grids","text":"","category":"section"},{"location":"Geometry/#Interface-3","page":"Gridap.Geometry","title":"Interface","text":"","category":"section"},{"location":"Geometry/#","page":"Gridap.Geometry","title":"Gridap.Geometry","text":"Grid\nOrientationStyle(a::Grid)\nRegularityStyle(a::Grid)\nget_node_coordinates(trian::Grid)\nget_cell_nodes(trian::Grid)\ntest_grid\nnum_nodes(trian::Grid)\nis_oriented(a::Grid)\nis_regular(a::Grid)\nGrid(reffe::LagrangianRefFE)\ncompute_linear_grid(reffe::LagrangianRefFE)\ncompute_reference_grid(reffe::LagrangianRefFE, nelems::Integer)\nGrid(::Type{ReferenceFE{d}},p::Polytope) where d\nGridTopology(grid::Grid)\nsimplexify(grid::Grid)","category":"page"},{"location":"Geometry/#Gridap.Geometry.Grid","page":"Gridap.Geometry","title":"Gridap.Geometry.Grid","text":"abstract type Grid{Dc,Dp} <: Triangulation{Dc,Dp}\n\nAbstract type that represents conforming triangulations, whose cell-wise nodal coordinates are defined with a vector of nodal coordinates, plus a cell-wise vector of node ids.\n\nThe interface of Grid is defined by overloading the methods in Triangulation plus the following ones:\n\nget_node_coordinates(trian::Grid)\nget_cell_nodes(trian::Grid)\n\nFrom these two methods a default implementation of get_cell_coordinates(trian::Triangulation) is available.\n\nThe Grid  interface has the following traits\n\nOrientationStyle(::Type{<:Grid})\nRegularityStyle(::Type{<:Grid})\n\nThe interface of Grid is tested with\n\ntest_grid\n\n\n\n\n\n","category":"type"},{"location":"Geometry/#Gridap.Geometry.OrientationStyle-Tuple{Gridap.Geometry.Grid}","page":"Gridap.Geometry","title":"Gridap.Geometry.OrientationStyle","text":"OrientationStyle(::Type{<:Grid}) -> Val{Bool}\nOrientationStyle(::Grid) -> Val{Bool}\n\nVal{true}() if has oriented faces, Val{false}() otherwise (default).\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.RegularityStyle-Tuple{Gridap.Geometry.Grid}","page":"Gridap.Geometry","title":"Gridap.Geometry.RegularityStyle","text":"RegularityStyle(::Type{<:Grid}) -> Val{Bool}\nRegularityStyle(::Grid) -> Val{Bool}\n\nVal{true}() if no hanging-nodes (refault), Val{false}() otherwise.\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.ReferenceFEs.get_node_coordinates-Tuple{Gridap.Geometry.Grid}","page":"Gridap.Geometry","title":"Gridap.ReferenceFEs.get_node_coordinates","text":"get_node_coordinates(trian::Grid) -> AbstractArray{<:Point{Dp}}\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.get_cell_nodes-Tuple{Gridap.Geometry.Grid}","page":"Gridap.Geometry","title":"Gridap.Geometry.get_cell_nodes","text":"get_cell_nodes(trian::Grid)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.test_grid","page":"Gridap.Geometry","title":"Gridap.Geometry.test_grid","text":"test_grid(trian::Grid)\n\n\n\n\n\n","category":"function"},{"location":"Geometry/#Gridap.ReferenceFEs.num_nodes-Tuple{Gridap.Geometry.Grid}","page":"Gridap.Geometry","title":"Gridap.ReferenceFEs.num_nodes","text":"num_nodes(trian::Grid) -> Int\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.is_oriented-Tuple{Gridap.Geometry.Grid}","page":"Gridap.Geometry","title":"Gridap.Geometry.is_oriented","text":"is_oriented(::Type{<:Grid}) -> Bool\nis_oriented(a::Grid) -> Bool\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.is_regular-Tuple{Gridap.Geometry.Grid}","page":"Gridap.Geometry","title":"Gridap.Geometry.is_regular","text":"is_regular(::Type{<:Grid}) -> Bool\nis_regular(a::Grid) -> Bool\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.Grid-Tuple{LagrangianRefFE}","page":"Gridap.Geometry","title":"Gridap.Geometry.Grid","text":"Grid(reffe::LagrangianRefFE)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.compute_linear_grid-Tuple{LagrangianRefFE}","page":"Gridap.Geometry","title":"Gridap.Geometry.compute_linear_grid","text":"compute_linear_grid(reffe::LagrangianRefFE)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.compute_reference_grid-Tuple{LagrangianRefFE,Integer}","page":"Gridap.Geometry","title":"Gridap.Geometry.compute_reference_grid","text":"compute_reference_grid(p::LagrangianRefFE, nelems::Integer)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.Grid-Union{Tuple{d}, Tuple{Type{Gridap.ReferenceFEs.ReferenceFE{d}},Polytope}} where d","page":"Gridap.Geometry","title":"Gridap.Geometry.Grid","text":"Grid(::Type{ReferenceFE{d}},p::Polytope) where d\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.GridTopology-Tuple{Gridap.Geometry.Grid}","page":"Gridap.Geometry","title":"Gridap.Geometry.GridTopology","text":"GridTopology(grid::Grid)\nGridTopology(grid::Grid, cell_to_vertices::Table, vertex_to_node::Vector)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.ReferenceFEs.simplexify-Tuple{Gridap.Geometry.Grid}","page":"Gridap.Geometry","title":"Gridap.ReferenceFEs.simplexify","text":"simplexify(grid::Grid)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#UnstructuredGrids-1","page":"Gridap.Geometry","title":"UnstructuredGrids","text":"","category":"section"},{"location":"Geometry/#","page":"Gridap.Geometry","title":"Gridap.Geometry","text":"UnstructuredGrid\nUnstructuredGrid(\n  node_coordinates::Vector{Point{Dp,Tp}},\n  cell_nodes::Table{Ti},\n  reffes::Vector{<:LagrangianRefFE{Dc}},\n  cell_types::Vector,\n  ::Val{B}=Val{false}()) where {Dc,Dp,Tp,Ti,B}\nUnstructuredGrid(trian::Grid)\nUnstructuredGrid(reffe::LagrangianRefFE)\nUnstructuredGrid(::Type{ReferenceFE{d}},p::Polytope) where d\nUnstructuredGrid(x::AbstractArray{<:Point})\nUnstructuredGridTopology(grid::UnstructuredGrid)","category":"page"},{"location":"Geometry/#Gridap.Geometry.UnstructuredGrid","page":"Gridap.Geometry","title":"Gridap.Geometry.UnstructuredGrid","text":"struct UnstructuredGrid{Dc,Dp,Tp,Ti,O} <: Grid{Dc,Dp}\n  node_coordinates::Vector{Point{Dp,Tp}}\n  cell_nodes::Table{Ti,Int32}\n  reffes::Vector{<:LagrangianRefFE{Dc}}\n  cell_types::Vector{Int8}\nend\n\n\n\n\n\n","category":"type"},{"location":"Geometry/#Gridap.Geometry.UnstructuredGrid-Union{Tuple{B}, Tuple{Ti}, Tuple{Tp}, Tuple{Dp}, Tuple{Dc}, Tuple{Array{VectorValue{Dp,Tp},1},Gridap.Arrays.Table{Ti,Vd,Vp} where Vp<:(AbstractArray{T,1} where T) where Vd<:AbstractArray{Ti,1},Array{var\"#s18\",1} where var\"#s18\"<:LagrangianRefFE{Dc},Array{T,1} where T}, Tuple{Array{VectorValue{Dp,Tp},1},Gridap.Arrays.Table{Ti,Vd,Vp} where Vp<:(AbstractArray{T,1} where T) where Vd<:AbstractArray{Ti,1},Array{var\"#s17\",1} where var\"#s17\"<:LagrangianRefFE{Dc},Array{T,1} where T,Val{B}}} where B where Ti where Tp where Dp where Dc","page":"Gridap.Geometry","title":"Gridap.Geometry.UnstructuredGrid","text":"function UnstructuredGrid(\n  node_coordinates::Vector{Point{Dp,Tp}},\n  cell_nodes::Table{Ti},\n  reffes::Vector{<:LagrangianRefFE{Dc}},\n  cell_types::Vector,\n  ::Val{B}=Val{false}()) where {Dc,Dp,Tp,Ti,B}\nend\n\nLow-level inner constructor.\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.UnstructuredGrid-Tuple{Gridap.Geometry.Grid}","page":"Gridap.Geometry","title":"Gridap.Geometry.UnstructuredGrid","text":"UnstructuredGrid(trian::Grid)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.UnstructuredGrid-Tuple{LagrangianRefFE}","page":"Gridap.Geometry","title":"Gridap.Geometry.UnstructuredGrid","text":"UnstructuredGrid(reffe::LagrangianRefFE)\n\nBuild a grid with a single cell that is the given reference FE itself\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.UnstructuredGrid-Union{Tuple{d}, Tuple{Type{Gridap.ReferenceFEs.ReferenceFE{d}},Polytope}} where d","page":"Gridap.Geometry","title":"Gridap.Geometry.UnstructuredGrid","text":"UnstructuredGrid(::Type{ReferenceFE{d}},p::Polytope) where d\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.UnstructuredGrid-Tuple{AbstractArray{var\"#s18\",N} where N where var\"#s18\"<:(VectorValue{D,T} where T where D)}","page":"Gridap.Geometry","title":"Gridap.Geometry.UnstructuredGrid","text":"UnstructuredGrid(x::AbstractArray{<:Point})\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.UnstructuredGridTopology-Tuple{Gridap.Geometry.UnstructuredGrid}","page":"Gridap.Geometry","title":"Gridap.Geometry.UnstructuredGridTopology","text":"UnstructuredGridTopology(grid::UnstructuredGrid)\n\nUnstructuredGridTopology(\n  grid::UnstructuredGrid,\n  cell_to_vertices::Table,\n  vertex_to_node::AbstractVector)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#CartesianGrids-1","page":"Gridap.Geometry","title":"CartesianGrids","text":"","category":"section"},{"location":"Geometry/#","page":"Gridap.Geometry","title":"Gridap.Geometry","text":"CartesianGrid\nCartesianGrid(desc::CartesianDescriptor{D,T,F}) where {D,T,F}\nCartesianGrid(domain,partition,map::Function)\nget_cartesian_descriptor(a::CartesianGrid)\nCartesianDescriptor\nCartesianDescriptor(origin,sizes,partition,map::Function)\nCartesianDescriptor(domain,partition,map::Function=identity)","category":"page"},{"location":"Geometry/#Gridap.Geometry.CartesianGrid","page":"Gridap.Geometry","title":"Gridap.Geometry.CartesianGrid","text":"struct CartesianGrid{D,T,F} <: Grid{D,D}\n  # private fields\nend\n\n\n\n\n\n","category":"type"},{"location":"Geometry/#Gridap.Geometry.CartesianGrid-Union{Tuple{Gridap.Geometry.CartesianDescriptor{D,T,F}}, Tuple{F}, Tuple{T}, Tuple{D}} where F where T where D","page":"Gridap.Geometry","title":"Gridap.Geometry.CartesianGrid","text":"CartesianGrid(desc::CartesianDescriptor)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.CartesianGrid-Tuple{Any,Any,Function}","page":"Gridap.Geometry","title":"Gridap.Geometry.CartesianGrid","text":"CartesianGrid(args...;kwargs...)\n\nSame args needed to construct a CartesianDescriptor\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.get_cartesian_descriptor-Tuple{CartesianGrid}","page":"Gridap.Geometry","title":"Gridap.Geometry.get_cartesian_descriptor","text":"get_cartesian_descriptor(grid::CartesianGrid)\n\nGet the descriptor of the Cartesian grid\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.CartesianDescriptor","page":"Gridap.Geometry","title":"Gridap.Geometry.CartesianDescriptor","text":"struct CartesianDescriptor{D,T,F<:Function}\n  origin::Point{D,T}\n  sizes::NTuple{D,T}\n  partition::NTuple{D,Int}\n  map::F\nend\n\nStruct that stores the data defining a Cartesian grid.\n\n\n\n\n\n","category":"type"},{"location":"Geometry/#GridPortion-1","page":"Gridap.Geometry","title":"GridPortion","text":"","category":"section"},{"location":"Geometry/#","page":"Gridap.Geometry","title":"Gridap.Geometry","text":"GridPortion\nGridPortion(oldgrid::Grid{Dc,Dp},cell_to_oldcell::Vector{Int}) where {Dc,Dp}","category":"page"},{"location":"Geometry/#Gridap.Geometry.GridPortion","page":"Gridap.Geometry","title":"Gridap.Geometry.GridPortion","text":"struct GridPortion{Dc,Dp,G} <: Grid{Dc,Dp}\n  oldgrid::G\n  cell_to_oldcell::Vector{Int}\n  node_to_oldnode::Vector{Int}\nend\n\n\n\n\n\n","category":"type"},{"location":"Geometry/#Gridap.Geometry.GridPortion-Union{Tuple{Dp}, Tuple{Dc}, Tuple{Gridap.Geometry.Grid{Dc,Dp},Array{Int64,1}}} where Dp where Dc","page":"Gridap.Geometry","title":"Gridap.Geometry.GridPortion","text":"GridPortion(oldgrid::Grid{Dc,Dp},cell_to_oldcell::Vector{Int}) where {Dc,Dp}\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#FaceLabeling-1","page":"Gridap.Geometry","title":"FaceLabeling","text":"","category":"section"},{"location":"Geometry/#","page":"Gridap.Geometry","title":"Gridap.Geometry","text":"FaceLabeling\nFaceLabeling(d_to_num_dfaces::Vector{Int})\nnum_dims(lab::FaceLabeling)\nnum_cell_dims(lab::FaceLabeling)\nnum_tags(lab::FaceLabeling)\nnum_entities(lab::FaceLabeling)\nnum_faces(lab::FaceLabeling,d::Integer)\nnum_faces(lab::FaceLabeling)\nnum_vertices(lab::FaceLabeling)\nnum_edges(lab::FaceLabeling)\nnum_facets(lab::FaceLabeling)\nnum_cells(lab::FaceLabeling)\nget_face_entity(lab::FaceLabeling,d::Integer)\nget_face_entity(lab::FaceLabeling)\nget_cell_entity(lab::FaceLabeling)\nget_tag_entities(lab::FaceLabeling,tag::Integer)\nget_tag_entities(lab::FaceLabeling)\nget_tag_name(lab::FaceLabeling,tag::Integer)\nget_tag_name(lab::FaceLabeling)\nget_tag_from_name(lab::FaceLabeling,name::String)\nget_tag_from_name(lab::FaceLabeling)\nget_tags_from_names(lab::FaceLabeling,names::Vector{String})\nget_face_mask(labeling::FaceLabeling,tags::Vector{Int},d::Integer)\nadd_tag!(lab::FaceLabeling,name::String,entities::Vector{<:Integer})\nadd_tag_from_tags!(lab::FaceLabeling, name::String, tags::Vector{Int})\nget_face_tag(labeling::FaceLabeling,tags,d::Integer)\nget_face_tag_index(labeling::FaceLabeling,tags,d::Integer)","category":"page"},{"location":"Geometry/#Gridap.Geometry.FaceLabeling","page":"Gridap.Geometry","title":"Gridap.Geometry.FaceLabeling","text":"struct FaceLabeling <: GridapType\n  d_to_dface_to_entity::Vector{Vector{Int32}}\n  tag_to_entities::Vector{Vector{Int32}}\n  tag_to_name::Vector{String}\nend\n\n\n\n\n\n","category":"type"},{"location":"Geometry/#Gridap.Geometry.FaceLabeling-Tuple{Array{Int64,1}}","page":"Gridap.Geometry","title":"Gridap.Geometry.FaceLabeling","text":"FaceLabeling(d_to_num_dfaces::Vector{Int})\nFaceLabeling(topo::GridTopology)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Integration.num_dims-Tuple{Gridap.Geometry.FaceLabeling}","page":"Gridap.Geometry","title":"Gridap.Integration.num_dims","text":"num_dims(lab::FaceLabeling)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.ReferenceFEs.num_cell_dims-Tuple{Gridap.Geometry.FaceLabeling}","page":"Gridap.Geometry","title":"Gridap.ReferenceFEs.num_cell_dims","text":"num_cell_dims(lab::FaceLabeling)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.num_tags-Tuple{Gridap.Geometry.FaceLabeling}","page":"Gridap.Geometry","title":"Gridap.Geometry.num_tags","text":"num_tags(lab::FaceLabeling)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.num_entities-Tuple{Gridap.Geometry.FaceLabeling}","page":"Gridap.Geometry","title":"Gridap.Geometry.num_entities","text":"num_entities(lab::FaceLabeling)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.ReferenceFEs.num_faces-Tuple{Gridap.Geometry.FaceLabeling,Integer}","page":"Gridap.Geometry","title":"Gridap.ReferenceFEs.num_faces","text":"num_faces(lab::FaceLabeling,d::Integer)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.ReferenceFEs.num_faces-Tuple{Gridap.Geometry.FaceLabeling}","page":"Gridap.Geometry","title":"Gridap.ReferenceFEs.num_faces","text":"num_faces(lab::FaceLabeling)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.ReferenceFEs.num_vertices-Tuple{Gridap.Geometry.FaceLabeling}","page":"Gridap.Geometry","title":"Gridap.ReferenceFEs.num_vertices","text":"num_vertices(lab::FaceLabeling)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.ReferenceFEs.num_edges-Tuple{Gridap.Geometry.FaceLabeling}","page":"Gridap.Geometry","title":"Gridap.ReferenceFEs.num_edges","text":"num_edges(lab::FaceLabeling)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.ReferenceFEs.num_facets-Tuple{Gridap.Geometry.FaceLabeling}","page":"Gridap.Geometry","title":"Gridap.ReferenceFEs.num_facets","text":"num_facets(lab::FaceLabeling)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.num_cells-Tuple{Gridap.Geometry.FaceLabeling}","page":"Gridap.Geometry","title":"Gridap.Geometry.num_cells","text":"num_cells(lab::FaceLabeling)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.get_face_entity-Tuple{Gridap.Geometry.FaceLabeling,Integer}","page":"Gridap.Geometry","title":"Gridap.Geometry.get_face_entity","text":"get_face_entity(lab::FaceLabeling,d::Integer)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.get_face_entity-Tuple{Gridap.Geometry.FaceLabeling}","page":"Gridap.Geometry","title":"Gridap.Geometry.get_face_entity","text":"get_face_entity(lab::FaceLabeling)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.get_cell_entity-Tuple{Gridap.Geometry.FaceLabeling}","page":"Gridap.Geometry","title":"Gridap.Geometry.get_cell_entity","text":"\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.get_tag_entities-Tuple{Gridap.Geometry.FaceLabeling,Integer}","page":"Gridap.Geometry","title":"Gridap.Geometry.get_tag_entities","text":"get_tag_entities(lab::FaceLabeling,tag::Integer)\nget_tag_entities(lab::FaceLabeling,tag::String)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.get_tag_entities-Tuple{Gridap.Geometry.FaceLabeling}","page":"Gridap.Geometry","title":"Gridap.Geometry.get_tag_entities","text":"get_tag_entities(lab::FaceLabeling)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.get_tag_name-Tuple{Gridap.Geometry.FaceLabeling,Integer}","page":"Gridap.Geometry","title":"Gridap.Geometry.get_tag_name","text":"get_tag_name(lab::FaceLabeling,tag::Integer)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.get_tag_name-Tuple{Gridap.Geometry.FaceLabeling}","page":"Gridap.Geometry","title":"Gridap.Geometry.get_tag_name","text":"get_tag_name(lab::FaceLabeling)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.get_tag_from_name-Tuple{Gridap.Geometry.FaceLabeling,String}","page":"Gridap.Geometry","title":"Gridap.Geometry.get_tag_from_name","text":"get_tag_from_name(lab::FaceLabeling,name::String)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.get_tag_from_name-Tuple{Gridap.Geometry.FaceLabeling}","page":"Gridap.Geometry","title":"Gridap.Geometry.get_tag_from_name","text":"get_tag_from_name(lab::FaceLabeling)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.get_tags_from_names-Tuple{Gridap.Geometry.FaceLabeling,Array{String,1}}","page":"Gridap.Geometry","title":"Gridap.Geometry.get_tags_from_names","text":"get_tags_from_names(lab::FaceLabeling,names::Vector{String})\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.get_face_mask-Tuple{Gridap.Geometry.FaceLabeling,Array{Int64,1},Integer}","page":"Gridap.Geometry","title":"Gridap.Geometry.get_face_mask","text":"get_face_mask(labeling::FaceLabeling,tags::Vector{Int},d::Integer)\nget_face_mask(labeling::FaceLabeling,tags::Vector{String},d::Integer)\nget_face_mask(labeling::FaceLabeling,tag::Int,d::Integer)\nget_face_mask(labeling::FaceLabeling,tag::String,d::Integer)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.add_tag!-Tuple{Gridap.Geometry.FaceLabeling,String,Array{var\"#s18\",1} where var\"#s18\"<:Integer}","page":"Gridap.Geometry","title":"Gridap.Geometry.add_tag!","text":"add_tag!(lab::FaceLabeling,name::String,entities::Vector{<:Integer})\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.add_tag_from_tags!-Tuple{Gridap.Geometry.FaceLabeling,String,Array{Int64,1}}","page":"Gridap.Geometry","title":"Gridap.Geometry.add_tag_from_tags!","text":"add_tag_from_tags!(lab::FaceLabeling, name::String, tags::Vector{Int})\nadd_tag_from_tags!(lab::FaceLabeling, name::String, tags::Vector{String})\nadd_tag_from_tags!(lab::FaceLabeling, name::String, tag::Int)\nadd_tag_from_tags!(lab::FaceLabeling, name::String, tag::String)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.get_face_tag-Tuple{Gridap.Geometry.FaceLabeling,Any,Integer}","page":"Gridap.Geometry","title":"Gridap.Geometry.get_face_tag","text":"get_face_tag(labeling::FaceLabeling,tags::Vector{Int},d::Integer)\nget_face_tag(labeling::FaceLabeling,tags::Vector{String},d::Integer)\nget_face_tag(labeling::FaceLabeling,tag::Int,d::Integer)\nget_face_tag(labeling::FaceLabeling,tag::String,d::Integer)\nget_face_tag(labeling::FaceLabeling,d::Integer)\n\nThe first of the given tags appearing in the face is taken. If there is no tag on a face, this face will have a value equal to UNSET. If not tag or tags are provided, all the tags in the model are considered\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.get_face_tag_index-Tuple{Gridap.Geometry.FaceLabeling,Any,Integer}","page":"Gridap.Geometry","title":"Gridap.Geometry.get_face_tag_index","text":"get_face_tag_index(labeling::FaceLabeling,tags::Vector{Int},d::Integer)\nget_face_tag_index(labeling::FaceLabeling,tags::Vector{String},d::Integer)\nget_face_tag_index(labeling::FaceLabeling,tag::Int,d::Integer)\nget_face_tag_index(labeling::FaceLabeling,tag::String,d::Integer)\n\nLike get_face_tag by provides the index into the array tags instead of the tag stored in tags.\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#GridTopology-1","page":"Gridap.Geometry","title":"GridTopology","text":"","category":"section"},{"location":"Geometry/#Interface-4","page":"Gridap.Geometry","title":"Interface","text":"","category":"section"},{"location":"Geometry/#","page":"Gridap.Geometry","title":"Gridap.Geometry","text":"GridTopology\nOrientationStyle(a::GridTopology)\nRegularityStyle(a::GridTopology)\nget_faces(g::GridTopology,dimfrom::Integer,dimto::Integer)\nget_polytopes(g::GridTopology)\nget_cell_type(g::GridTopology)\nget_vertex_coordinates(g::GridTopology)\ntest_grid_topology(top::GridTopology{Dc,Dp}) where {Dc,Dp}\nnum_cell_dims(::GridTopology{Dc,Dp}) where {Dc,Dp}\nnum_point_dims(::GridTopology{Dc,Dp}) where {Dc,Dp}\nnum_dims(g::GridTopology{Dc}) where Dc\nnum_faces(g::GridTopology,d::Integer)\nnum_cells(g::GridTopology)\nnum_facets(g::GridTopology)\nnum_edges(g::GridTopology)\nnum_vertices(g::GridTopology)\nget_dimranges(g::GridTopology)\nget_dimrange(g::GridTopology,d::Integer)\nget_offsets(g::GridTopology)\nget_offset(g::GridTopology,d::Integer)\nget_facedims(g::GridTopology)\nget_cell_faces(g::GridTopology)\ncompute_cell_faces(g::GridTopology)\nget_face_vertices(g::GridTopology,d::Integer)\nget_face_vertices(g::GridTopology)\ncompute_face_vertices(g::GridTopology)\nget_cell_vertices(g::GridTopology)\nis_simplex(p::GridTopology)\nis_n_cube(p::GridTopology)\nis_oriented(a::GridTopology)\nis_regular(a::GridTopology)\nget_reffaces(::Type{Polytope{d}}, g::GridTopology) where d\nget_face_type(g::GridTopology,d::Integer)\ncompute_reffaces(::Type{Polytope{d}}, g::GridTopology) where d\nget_reffaces(topo::GridTopology)\nget_face_type(topo::GridTopology)\nget_reffaces_offsets(topo::GridTopology)\ncompute_reffaces(g::GridTopology)\nget_isboundary_face(g::GridTopology)\nget_isboundary_face(g::GridTopology,d::Integer)\ncompute_isboundary_face(g::GridTopology)\ncompute_isboundary_face(g::GridTopology,d::Integer)\nget_cell_permutations(top::GridTopology)\nget_cell_permutations(top::GridTopology,d::Integer)\ncompute_cell_permutations(top::GridTopology)\ncompute_cell_permutations(top::GridTopology,d::Integer)","category":"page"},{"location":"Geometry/#Gridap.Geometry.GridTopology","page":"Gridap.Geometry","title":"Gridap.Geometry.GridTopology","text":"abstract type GridTopology{Dc,Dp}\n\nAbstract type representing the topological information associated with a grid.\n\nThe GridTopology interface is defined by overloading the methods:\n\nget_faces(g::GridTopology,dimfrom::Integer,dimto::Integer)\nget_polytopes(g::GridTopology)\nget_cell_type(g::GridTopology)\nget_vertex_coordinates(g::GridTopology)\n\nThe GridTopology interface has the following traits\n\nOrientationStyle(::Type{<:GridTopology})\nRegularityStyle(::Type{<:GridTopology})\n\nand tested with this function:\n\ntest_grid_topology\n\n\n\n\n\n","category":"type"},{"location":"Geometry/#Gridap.Geometry.OrientationStyle-Tuple{Gridap.Geometry.GridTopology}","page":"Gridap.Geometry","title":"Gridap.Geometry.OrientationStyle","text":"OrientationStyle(::Type{<:GridTopology}) -> Val{Bool}\nOrientationStyle(::GridTopology) -> Val{Bool}\n\nVal{true}() if has oriented faces, Val{false}() otherwise (default).\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.RegularityStyle-Tuple{Gridap.Geometry.GridTopology}","page":"Gridap.Geometry","title":"Gridap.Geometry.RegularityStyle","text":"RegularityStyle(::Type{<:GridTopology}) -> Val{Bool}\nRegularityStyle(::GridTopology) -> Val{Bool}\n\nVal{true}() if no hanging-faces (refault), Val{false}() otherwise.\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.ReferenceFEs.get_faces-Tuple{Gridap.Geometry.GridTopology,Integer,Integer}","page":"Gridap.Geometry","title":"Gridap.ReferenceFEs.get_faces","text":"get_faces(g::GridTopology,dimfrom::Integer,dimto::Integer)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.get_polytopes-Tuple{Gridap.Geometry.GridTopology}","page":"Gridap.Geometry","title":"Gridap.Geometry.get_polytopes","text":"get_polytopes(g::GridTopology)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.get_cell_type-Tuple{Gridap.Geometry.GridTopology}","page":"Gridap.Geometry","title":"Gridap.Geometry.get_cell_type","text":"get_cell_type(g::GridTopology)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.ReferenceFEs.get_vertex_coordinates-Tuple{Gridap.Geometry.GridTopology}","page":"Gridap.Geometry","title":"Gridap.ReferenceFEs.get_vertex_coordinates","text":"get_vertex_coordinates(g::GridTopology)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.test_grid_topology-Union{Tuple{Gridap.Geometry.GridTopology{Dc,Dp}}, Tuple{Dp}, Tuple{Dc}} where Dp where Dc","page":"Gridap.Geometry","title":"Gridap.Geometry.test_grid_topology","text":"test_grid_topology(top::GridTopology)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.ReferenceFEs.num_cell_dims-Union{Tuple{Gridap.Geometry.GridTopology{Dc,Dp}}, Tuple{Dp}, Tuple{Dc}} where Dp where Dc","page":"Gridap.Geometry","title":"Gridap.ReferenceFEs.num_cell_dims","text":"num_cell_dims(::GridTopology) -> Int\nnum_cell_dims(::Type{<:GridTopology}) -> Int\n\n\n\n\n\nnum_cell_dims(::Triangulation) -> Int\nnum_cell_dims(::Type{<:Triangulation}) -> Int\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Integration.num_point_dims-Union{Tuple{Gridap.Geometry.GridTopology{Dc,Dp}}, Tuple{Dp}, Tuple{Dc}} where Dp where Dc","page":"Gridap.Geometry","title":"Gridap.Integration.num_point_dims","text":"num_point_dims(::GridTopology) -> Int\nnum_point_dims(::Type{<:GridTopology}) -> Int\n\n\n\n\n\nnum_point_dims(::Triangulation) -> Int\nnum_point_dims(::Type{<:Triangulation}) -> Int\n\n\n\n\n\nnum_point_dims(::Quadrature{D}) where D\nnum_point_dims(::Type{<:Quadrature{D}}) where D\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Integration.num_dims-Union{Tuple{Gridap.Geometry.GridTopology{Dc,Dp} where Dp}, Tuple{Dc}} where Dc","page":"Gridap.Geometry","title":"Gridap.Integration.num_dims","text":"num_dims(::GridTopology) -> Int\nnum_dims(::Type{<:GridTopology}) -> Int\n\nEquivalent to num_cell_dims.\n\n\n\n\n\nnum_dims(::Triangulation) -> Int\nnum_dims(::Type{<:Triangulation}) -> Int\n\nEquivalent to num_cell_dims.\n\n\n\n\n\nnum_dims(::Quadrature{D}) where D where D\nnum_dims(::Type{<:Quadrature{D}}) where D\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.ReferenceFEs.num_faces-Tuple{Gridap.Geometry.GridTopology,Integer}","page":"Gridap.Geometry","title":"Gridap.ReferenceFEs.num_faces","text":"num_faces(g::GridTopology,d::Integer)\nnum_faces(g::GridTopology)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.num_cells-Tuple{Gridap.Geometry.GridTopology}","page":"Gridap.Geometry","title":"Gridap.Geometry.num_cells","text":"num_cells(g::GridTopology)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.ReferenceFEs.num_facets-Tuple{Gridap.Geometry.GridTopology}","page":"Gridap.Geometry","title":"Gridap.ReferenceFEs.num_facets","text":"num_facets(g::GridTopology)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.ReferenceFEs.num_edges-Tuple{Gridap.Geometry.GridTopology}","page":"Gridap.Geometry","title":"Gridap.ReferenceFEs.num_edges","text":"num_edges(g::GridTopology)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.ReferenceFEs.num_vertices-Tuple{Gridap.Geometry.GridTopology}","page":"Gridap.Geometry","title":"Gridap.ReferenceFEs.num_vertices","text":"num_vertices(g::GridTopology)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.ReferenceFEs.get_dimranges-Tuple{Gridap.Geometry.GridTopology}","page":"Gridap.Geometry","title":"Gridap.ReferenceFEs.get_dimranges","text":"get_dimranges(g::GridTopology)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.ReferenceFEs.get_dimrange-Tuple{Gridap.Geometry.GridTopology,Integer}","page":"Gridap.Geometry","title":"Gridap.ReferenceFEs.get_dimrange","text":"get_dimrange(g::GridTopology,d::Integer)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.ReferenceFEs.get_offsets-Tuple{Gridap.Geometry.GridTopology}","page":"Gridap.Geometry","title":"Gridap.ReferenceFEs.get_offsets","text":"get_offsets(g::GridTopology)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.ReferenceFEs.get_offset-Tuple{Gridap.Geometry.GridTopology,Integer}","page":"Gridap.Geometry","title":"Gridap.ReferenceFEs.get_offset","text":"get_offset(g::GridTopology,d::Integer)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.ReferenceFEs.get_facedims-Tuple{Gridap.Geometry.GridTopology}","page":"Gridap.Geometry","title":"Gridap.ReferenceFEs.get_facedims","text":"get_facedims(g::GridTopology)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.get_cell_faces-Tuple{Gridap.Geometry.GridTopology}","page":"Gridap.Geometry","title":"Gridap.Geometry.get_cell_faces","text":"get_cell_faces(g::GridTopology)\n\nDefaults to\n\ncompute_cell_faces(g)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.compute_cell_faces-Tuple{Gridap.Geometry.GridTopology}","page":"Gridap.Geometry","title":"Gridap.Geometry.compute_cell_faces","text":"compute_cell_faces(g::GridTopology)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.ReferenceFEs.get_face_vertices-Tuple{Gridap.Geometry.GridTopology,Integer}","page":"Gridap.Geometry","title":"Gridap.ReferenceFEs.get_face_vertices","text":"get_face_vertices(g::GridTopology,d::Integer)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.ReferenceFEs.get_face_vertices-Tuple{Gridap.Geometry.GridTopology}","page":"Gridap.Geometry","title":"Gridap.ReferenceFEs.get_face_vertices","text":"get_face_vertices(g::GridTopology)\n\nDefaults to\n\ncompute_face_vertices(g)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.compute_face_vertices-Tuple{Gridap.Geometry.GridTopology}","page":"Gridap.Geometry","title":"Gridap.Geometry.compute_face_vertices","text":"compute_face_vertices(g::GridTopology)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.get_cell_vertices-Tuple{Gridap.Geometry.GridTopology}","page":"Gridap.Geometry","title":"Gridap.Geometry.get_cell_vertices","text":"get_cell_vertices(g::GridTopology)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.ReferenceFEs.is_simplex-Tuple{Gridap.Geometry.GridTopology}","page":"Gridap.Geometry","title":"Gridap.ReferenceFEs.is_simplex","text":"is_simplex(p::GridTopology) -> Bool\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.ReferenceFEs.is_n_cube-Tuple{Gridap.Geometry.GridTopology}","page":"Gridap.Geometry","title":"Gridap.ReferenceFEs.is_n_cube","text":"is_n_cube(p::GridTopology) -> Bool\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.is_oriented-Tuple{Gridap.Geometry.GridTopology}","page":"Gridap.Geometry","title":"Gridap.Geometry.is_oriented","text":"is_oriented(::Type{<:GridTopology}) -> Bool\nis_oriented(a::GridTopology) -> Bool\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.is_regular-Tuple{Gridap.Geometry.GridTopology}","page":"Gridap.Geometry","title":"Gridap.Geometry.is_regular","text":"is_regular(::Type{<:GridTopology}) -> Bool\nis_regular(a::GridTopology) -> Bool\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.ReferenceFEs.get_reffaces-Union{Tuple{d}, Tuple{Type{Polytope{d}},Gridap.Geometry.GridTopology}} where d","page":"Gridap.Geometry","title":"Gridap.ReferenceFEs.get_reffaces","text":"get_reffaces(::Type{Polytope{d}}, g::GridTopology) where d\n\nBy default, it calls to compute_reffaces.\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.ReferenceFEs.get_face_type-Tuple{Gridap.Geometry.GridTopology,Integer}","page":"Gridap.Geometry","title":"Gridap.ReferenceFEs.get_face_type","text":"get_face_type(g::GridTopology,d::Integer)\n\nBy default, it calls to compute_reffaces.\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.compute_reffaces-Union{Tuple{d}, Tuple{Type{Polytope{d}},Gridap.Geometry.GridTopology}} where d","page":"Gridap.Geometry","title":"Gridap.Geometry.compute_reffaces","text":"compute_reffaces(::Type{Polytope{d}}, g::GridTopology) where d\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.ReferenceFEs.get_reffaces-Tuple{Gridap.Geometry.GridTopology}","page":"Gridap.Geometry","title":"Gridap.ReferenceFEs.get_reffaces","text":"get_reffaces(topo::GridTopology)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.ReferenceFEs.get_face_type-Tuple{Gridap.Geometry.GridTopology}","page":"Gridap.Geometry","title":"Gridap.ReferenceFEs.get_face_type","text":"get_face_type(topo::GridTopology)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.get_reffaces_offsets-Tuple{Gridap.Geometry.GridTopology}","page":"Gridap.Geometry","title":"Gridap.Geometry.get_reffaces_offsets","text":"get_reffaces_offsets(topo::GridTopology)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.compute_reffaces-Tuple{Gridap.Geometry.GridTopology}","page":"Gridap.Geometry","title":"Gridap.Geometry.compute_reffaces","text":"compute_reffaces(g::GridTopology)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.get_isboundary_face-Tuple{Gridap.Geometry.GridTopology}","page":"Gridap.Geometry","title":"Gridap.Geometry.get_isboundary_face","text":"get_isboundary_face(g::GridTopology)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.get_isboundary_face-Tuple{Gridap.Geometry.GridTopology,Integer}","page":"Gridap.Geometry","title":"Gridap.Geometry.get_isboundary_face","text":"get_isboundary_face(g::GridTopology,d::Integer)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.compute_isboundary_face-Tuple{Gridap.Geometry.GridTopology}","page":"Gridap.Geometry","title":"Gridap.Geometry.compute_isboundary_face","text":"compute_isboundary_face(g::GridTopology)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.compute_isboundary_face-Tuple{Gridap.Geometry.GridTopology,Integer}","page":"Gridap.Geometry","title":"Gridap.Geometry.compute_isboundary_face","text":"compute_isboundary_face(g::GridTopology,d::Integer)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.get_cell_permutations-Tuple{Gridap.Geometry.GridTopology}","page":"Gridap.Geometry","title":"Gridap.Geometry.get_cell_permutations","text":"get_cell_permutations(top::GridTopology)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.get_cell_permutations-Tuple{Gridap.Geometry.GridTopology,Integer}","page":"Gridap.Geometry","title":"Gridap.Geometry.get_cell_permutations","text":"get_cell_permutations(top::GridTopology,d::Integer)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.compute_cell_permutations-Tuple{Gridap.Geometry.GridTopology}","page":"Gridap.Geometry","title":"Gridap.Geometry.compute_cell_permutations","text":"compute_cell_permutations(top::GridTopology)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.compute_cell_permutations-Tuple{Gridap.Geometry.GridTopology,Integer}","page":"Gridap.Geometry","title":"Gridap.Geometry.compute_cell_permutations","text":"compute_cell_permutations(top::GridTopology,d::Integer)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#UnstructuredGridTopology-1","page":"Gridap.Geometry","title":"UnstructuredGridTopology","text":"","category":"section"},{"location":"Geometry/#","page":"Gridap.Geometry","title":"Gridap.Geometry","text":"UnstructuredGridTopology\nUnstructuredGridTopology(\n  vertex_coordinates::Vector{<:Point},\n  cell_vertices::Table,\n  cell_type::Vector{<:Integer},\n  polytopes::Vector{<:Polytope},\n  orientation::Val{O}=Val{false}()) where O\nUnstructuredGridTopology(\n  vertex_coordinates::Vector{<:Point},\n  d_to_dface_vertices::Vector{<:Table},\n  cell_type::Vector{<:Integer},\n  polytopes::Vector{<:Polytope},\n  orientation::Val{O}=Val{false}()) where O","category":"page"},{"location":"Geometry/#Gridap.Geometry.UnstructuredGridTopology","page":"Gridap.Geometry","title":"Gridap.Geometry.UnstructuredGridTopology","text":"struct UnstructuredGridTopology{Dc,Dp,T,O} <: GridTopology{Dc,Dp}\n  # private fields\nend\n\n\n\n\n\n","category":"type"},{"location":"Geometry/#Gridap.Geometry.UnstructuredGridTopology-Union{Tuple{O}, Tuple{Array{var\"#s18\",1} where var\"#s18\"<:(VectorValue{D,T} where T where D),Gridap.Arrays.Table,Array{var\"#s17\",1} where var\"#s17\"<:Integer,Array{var\"#s16\",1} where var\"#s16\"<:Polytope}, Tuple{Array{var\"#s15\",1} where var\"#s15\"<:(VectorValue{D,T} where T where D),Gridap.Arrays.Table,Array{var\"#s14\",1} where var\"#s14\"<:Integer,Array{var\"#s13\",1} where var\"#s13\"<:Polytope,Val{O}}} where O","page":"Gridap.Geometry","title":"Gridap.Geometry.UnstructuredGridTopology","text":"UnstructuredGridTopology(\n  vertex_coordinates::Vector{<:Point},\n  cell_vertices::Table,\n  cell_type::Vector{<:Integer},\n  polytopes::Vector{<:Polytope},\n  orientation::Val{O}=Val{false}()) where O\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.UnstructuredGridTopology-Union{Tuple{O}, Tuple{Array{var\"#s18\",1} where var\"#s18\"<:(VectorValue{D,T} where T where D),Array{var\"#s17\",1} where var\"#s17\"<:Gridap.Arrays.Table,Array{var\"#s16\",1} where var\"#s16\"<:Integer,Array{var\"#s15\",1} where var\"#s15\"<:Polytope}, Tuple{Array{var\"#s14\",1} where var\"#s14\"<:(VectorValue{D,T} where T where D),Array{var\"#s13\",1} where var\"#s13\"<:Gridap.Arrays.Table,Array{var\"#s12\",1} where var\"#s12\"<:Integer,Array{var\"#s11\",1} where var\"#s11\"<:Polytope,Val{O}}} where O","page":"Gridap.Geometry","title":"Gridap.Geometry.UnstructuredGridTopology","text":"UnstructuredGridTopology(\n  vertex_coordinates::Vector{<:Point},\n  d_to_dface_vertices::Vector{<:Table},\n  cell_type::Vector{<:Integer},\n  polytopes::Vector{<:Polytope},\n  orientation::Val{O}=Val{false}()) where O\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#DiscreteModels-1","page":"Gridap.Geometry","title":"DiscreteModels","text":"","category":"section"},{"location":"Geometry/#Interface-5","page":"Gridap.Geometry","title":"Interface","text":"","category":"section"},{"location":"Geometry/#","page":"Gridap.Geometry","title":"Gridap.Geometry","text":"DiscreteModel\nget_grid(model::DiscreteModel)\nget_grid_topology(model::DiscreteModel)\nget_face_labeling(g::DiscreteModel)\ntest_discrete_model(model::DiscreteModel{Dc,Dp}) where {Dc,Dp}\nnum_dims(model::DiscreteModel)\nnum_cell_dims(model::DiscreteModel)\nnum_point_dims(model::DiscreteModel)\nnum_faces(g::DiscreteModel,d::Integer)\nnum_cells(g::DiscreteModel)\nnum_facets(g::DiscreteModel)\nnum_edges(g::DiscreteModel)\nnum_vertices(g::DiscreteModel)\nnum_nodes(g::DiscreteModel)\nget_face_nodes(g::DiscreteModel,d::Integer)\nget_face_nodes(g::DiscreteModel)\ncompute_face_nodes(model::DiscreteModel,d::Integer)\ncompute_face_nodes(model::DiscreteModel)\nget_face_own_nodes(g::DiscreteModel,d::Integer)\nget_face_own_nodes(g::DiscreteModel)\ncompute_face_own_nodes(model::DiscreteModel,d::Integer)\ncompute_face_own_nodes(model::DiscreteModel)\nget_vertex_node(g::DiscreteModel)\ncompute_vertex_node(g::DiscreteModel)\nget_node_face_owner(g::DiscreteModel)\ncompute_node_face_owner(g::DiscreteModel)\nget_reffaces(::Type{ReferenceFE{d}},model::DiscreteModel) where d\nget_face_type(g::DiscreteModel,d::Integer)\ncompute_reffaces(::Type{ReferenceFE{d}}, g::DiscreteModel) where d\nget_reffaces(model::DiscreteModel)\nget_face_type(model::DiscreteModel)\nget_reffaces_offsets(model::DiscreteModel)\ncompute_reffaces(g::DiscreteModel)\nGrid(::Type{ReferenceFE{d}},model::DiscreteModel) where d\nTriangulation(::Type{ReferenceFE{d}},model::DiscreteModel) where d\nget_triangulation(model::DiscreteModel)\nget_polytopes(model::DiscreteModel)\nsimplexify(model::DiscreteModel)","category":"page"},{"location":"Geometry/#Gridap.Geometry.DiscreteModel","page":"Gridap.Geometry","title":"Gridap.Geometry.DiscreteModel","text":"abstract type DiscreteModel{Dc,Dp} <: GridapType\n\nAbstract type holding information about a physical grid,  the underlying grid topology, and a labeling of the grid faces. This is the information that typically provides a mesh generator, and it is what one needs to perform a simulation.\n\nThe DiscreteModel interface is defined by overloading the methods:\n\nget_grid(model::DiscreteModel)\nget_grid_topology(model::DiscreteModel)\nget_face_labeling(g::DiscreteModel)\n\nThe interface is tested with this function:\n\ntest_discrete_model\n\n\n\n\n\n","category":"type"},{"location":"Geometry/#Gridap.Geometry.get_grid-Tuple{DiscreteModel}","page":"Gridap.Geometry","title":"Gridap.Geometry.get_grid","text":"get_grid(model::DiscreteModel)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.get_grid_topology-Tuple{DiscreteModel}","page":"Gridap.Geometry","title":"Gridap.Geometry.get_grid_topology","text":"get_grid_topology(model::DiscreteModel)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.get_face_labeling-Tuple{DiscreteModel}","page":"Gridap.Geometry","title":"Gridap.Geometry.get_face_labeling","text":"get_face_labeling(g::DiscreteModel)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.test_discrete_model-Union{Tuple{DiscreteModel{Dc,Dp}}, Tuple{Dp}, Tuple{Dc}} where Dp where Dc","page":"Gridap.Geometry","title":"Gridap.Geometry.test_discrete_model","text":"test_discrete_model(model::DiscreteModel)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Integration.num_dims-Tuple{DiscreteModel}","page":"Gridap.Geometry","title":"Gridap.Integration.num_dims","text":"num_dims(model::DiscreteModel)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.ReferenceFEs.num_cell_dims-Tuple{DiscreteModel}","page":"Gridap.Geometry","title":"Gridap.ReferenceFEs.num_cell_dims","text":"num_cell_dims(model::DiscreteModel)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Integration.num_point_dims-Tuple{DiscreteModel}","page":"Gridap.Geometry","title":"Gridap.Integration.num_point_dims","text":"num_point_dims(model::DiscreteModel)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.ReferenceFEs.num_faces-Tuple{DiscreteModel,Integer}","page":"Gridap.Geometry","title":"Gridap.ReferenceFEs.num_faces","text":"num_faces(g::DiscreteModel,d::Integer)\nnum_faces(g::DiscreteModel)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.num_cells-Tuple{DiscreteModel}","page":"Gridap.Geometry","title":"Gridap.Geometry.num_cells","text":"num_cells(g::DiscreteModel)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.ReferenceFEs.num_facets-Tuple{DiscreteModel}","page":"Gridap.Geometry","title":"Gridap.ReferenceFEs.num_facets","text":"num_facets(g::DiscreteModel)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.ReferenceFEs.num_edges-Tuple{DiscreteModel}","page":"Gridap.Geometry","title":"Gridap.ReferenceFEs.num_edges","text":"num_edges(g::DiscreteModel)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.ReferenceFEs.num_vertices-Tuple{DiscreteModel}","page":"Gridap.Geometry","title":"Gridap.ReferenceFEs.num_vertices","text":"num_vertices(g::DiscreteModel)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.ReferenceFEs.num_nodes-Tuple{DiscreteModel}","page":"Gridap.Geometry","title":"Gridap.ReferenceFEs.num_nodes","text":"num_nodes(g::DiscreteModel)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.ReferenceFEs.get_face_nodes-Tuple{DiscreteModel,Integer}","page":"Gridap.Geometry","title":"Gridap.ReferenceFEs.get_face_nodes","text":"get_face_nodes(g::DiscreteModel,d::Integer)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.ReferenceFEs.get_face_nodes-Tuple{DiscreteModel}","page":"Gridap.Geometry","title":"Gridap.ReferenceFEs.get_face_nodes","text":"get_face_nodes(g::DiscreteModel)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.compute_face_nodes-Tuple{DiscreteModel,Integer}","page":"Gridap.Geometry","title":"Gridap.Geometry.compute_face_nodes","text":"compute_face_nodes(model::DiscreteModel,d::Integer)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.compute_face_nodes-Tuple{DiscreteModel}","page":"Gridap.Geometry","title":"Gridap.Geometry.compute_face_nodes","text":"compute_face_nodes(model::DiscreteModel)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.ReferenceFEs.get_face_own_nodes-Tuple{DiscreteModel,Integer}","page":"Gridap.Geometry","title":"Gridap.ReferenceFEs.get_face_own_nodes","text":"get_face_own_nodes(g::DiscreteModel,d::Integer)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.ReferenceFEs.get_face_own_nodes-Tuple{DiscreteModel}","page":"Gridap.Geometry","title":"Gridap.ReferenceFEs.get_face_own_nodes","text":"get_face_own_nodes(g::DiscreteModel)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.compute_face_own_nodes-Tuple{DiscreteModel,Integer}","page":"Gridap.Geometry","title":"Gridap.Geometry.compute_face_own_nodes","text":"compute_face_own_nodes(model::DiscreteModel,d::Integer)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.compute_face_own_nodes-Tuple{DiscreteModel}","page":"Gridap.Geometry","title":"Gridap.Geometry.compute_face_own_nodes","text":"compute_face_own_nodes(model::DiscreteModel)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.ReferenceFEs.get_vertex_node-Tuple{DiscreteModel}","page":"Gridap.Geometry","title":"Gridap.ReferenceFEs.get_vertex_node","text":"get_vertex_node(g::DiscreteModel)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.compute_vertex_node-Tuple{DiscreteModel}","page":"Gridap.Geometry","title":"Gridap.Geometry.compute_vertex_node","text":"compute_vertex_node(g::DiscreteModel)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.get_node_face_owner-Tuple{DiscreteModel}","page":"Gridap.Geometry","title":"Gridap.Geometry.get_node_face_owner","text":"get_node_face_owner(g::DiscreteModel)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.compute_node_face_owner-Tuple{DiscreteModel}","page":"Gridap.Geometry","title":"Gridap.Geometry.compute_node_face_owner","text":"compute_node_face_owner(g::DiscreteModel)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.ReferenceFEs.get_reffaces-Union{Tuple{d}, Tuple{Type{Gridap.ReferenceFEs.ReferenceFE{d}},DiscreteModel}} where d","page":"Gridap.Geometry","title":"Gridap.ReferenceFEs.get_reffaces","text":"get_reffaces(::Type{ReferenceFE{d}},model::DiscreteModel) where d\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.ReferenceFEs.get_face_type-Tuple{DiscreteModel,Integer}","page":"Gridap.Geometry","title":"Gridap.ReferenceFEs.get_face_type","text":"get_face_type(g::DiscreteModel,d::Integer)\n\nIndex to the vector get_reffaces(ReferenceFE{d},g)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.compute_reffaces-Union{Tuple{d}, Tuple{Type{Gridap.ReferenceFEs.ReferenceFE{d}},DiscreteModel}} where d","page":"Gridap.Geometry","title":"Gridap.Geometry.compute_reffaces","text":"compute_reffaces(::Type{ReferenceFE{d}}, g::DiscreteModel) where d\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.ReferenceFEs.get_reffaces-Tuple{DiscreteModel}","page":"Gridap.Geometry","title":"Gridap.ReferenceFEs.get_reffaces","text":"get_reffaces(model::DiscreteModel)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.ReferenceFEs.get_face_type-Tuple{DiscreteModel}","page":"Gridap.Geometry","title":"Gridap.ReferenceFEs.get_face_type","text":"get_face_type(model::DiscreteModel)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.get_reffaces_offsets-Tuple{DiscreteModel}","page":"Gridap.Geometry","title":"Gridap.Geometry.get_reffaces_offsets","text":"get_reffaces_offsets(model::DiscreteModel)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.compute_reffaces-Tuple{DiscreteModel}","page":"Gridap.Geometry","title":"Gridap.Geometry.compute_reffaces","text":"compute_reffaces(g::DiscreteModel)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.Grid-Union{Tuple{d}, Tuple{Type{Gridap.ReferenceFEs.ReferenceFE{d}},DiscreteModel}} where d","page":"Gridap.Geometry","title":"Gridap.Geometry.Grid","text":"Grid(::Type{ReferenceFE{d}},model::DiscreteModel) where d\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.Triangulation-Union{Tuple{d}, Tuple{Type{Gridap.ReferenceFEs.ReferenceFE{d}},DiscreteModel}} where d","page":"Gridap.Geometry","title":"Gridap.Geometry.Triangulation","text":"Triangulation(::Type{ReferenceFE{d}},model::DiscreteModel) where d\nTriangulation(model::DiscreteModel)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.get_triangulation-Tuple{DiscreteModel}","page":"Gridap.Geometry","title":"Gridap.Geometry.get_triangulation","text":"get_triangulation(model::DiscreteModel)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.get_polytopes-Tuple{DiscreteModel}","page":"Gridap.Geometry","title":"Gridap.Geometry.get_polytopes","text":"get_polytopes(model::DiscreteModel)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.ReferenceFEs.simplexify-Tuple{DiscreteModel}","page":"Gridap.Geometry","title":"Gridap.ReferenceFEs.simplexify","text":"simplexify(model::DiscreteModel)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#DiscreteModelFromFile-1","page":"Gridap.Geometry","title":"DiscreteModelFromFile","text":"","category":"section"},{"location":"Geometry/#","page":"Gridap.Geometry","title":"Gridap.Geometry","text":"DiscreteModelFromFile(filename::AbstractString)","category":"page"},{"location":"Geometry/#Gridap.Geometry.DiscreteModelFromFile-Tuple{AbstractString}","page":"Gridap.Geometry","title":"Gridap.Geometry.DiscreteModelFromFile","text":"DiscreteModelFromFile(filename::AbstractString)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#UnstructuredDiscreteModels-1","page":"Gridap.Geometry","title":"UnstructuredDiscreteModels","text":"","category":"section"},{"location":"Geometry/#","page":"Gridap.Geometry","title":"Gridap.Geometry","text":"UnstructuredDiscreteModel\nUnstructuredDiscreteModel(trian::Grid)","category":"page"},{"location":"Geometry/#Gridap.Geometry.UnstructuredDiscreteModel","page":"Gridap.Geometry","title":"Gridap.Geometry.UnstructuredDiscreteModel","text":"struct UnstructuredDiscreteModel{Dc,Dp,Tp,B} <: DiscreteModel{Dc,Dp}\n  grid::UnstructuredGrid{Dc,Dp,Tp,B}\n  grid_topology::UnstructuredGridTopology{Dc,Dp,Tp,B}\n  face_labeling::FaceLabeling\nend\n\n\n\n\n\n","category":"type"},{"location":"Geometry/#Gridap.Geometry.UnstructuredDiscreteModel-Tuple{Gridap.Geometry.Grid}","page":"Gridap.Geometry","title":"Gridap.Geometry.UnstructuredDiscreteModel","text":"UnstructuredDiscreteModel(grid::Grid)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#CartesianDiscreteModels-1","page":"Gridap.Geometry","title":"CartesianDiscreteModels","text":"","category":"section"},{"location":"Geometry/#","page":"Gridap.Geometry","title":"Gridap.Geometry","text":"CartesianDiscreteModel\nCartesianDiscreteModel(desc::CartesianDescriptor{D,T,F}) where {D,T,F}\nCartesianDiscreteModel(args...)\nget_cartesian_descriptor(a::CartesianDiscreteModel)","category":"page"},{"location":"Geometry/#Gridap.Geometry.CartesianDiscreteModel","page":"Gridap.Geometry","title":"Gridap.Geometry.CartesianDiscreteModel","text":"struct CartesianDiscreteModel{D,T,F} <: DiscreteModel{D,D}\n  # Private Fields\nend\n\n\n\n\n\n","category":"type"},{"location":"Geometry/#Gridap.Geometry.CartesianDiscreteModel-Union{Tuple{Gridap.Geometry.CartesianDescriptor{D,T,F}}, Tuple{F}, Tuple{T}, Tuple{D}} where F where T where D","page":"Gridap.Geometry","title":"Gridap.Geometry.CartesianDiscreteModel","text":"CartesianDiscreteModel(desc::CartesianDescriptor)\n\nInner constructor\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.CartesianDiscreteModel-Tuple","page":"Gridap.Geometry","title":"Gridap.Geometry.CartesianDiscreteModel","text":"CartesianDiscreteModel(args...)\n\nSame args needed to construct a CartesianDescriptor\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.get_cartesian_descriptor-Tuple{CartesianDiscreteModel}","page":"Gridap.Geometry","title":"Gridap.Geometry.get_cartesian_descriptor","text":"get_cartesian_descriptor(model::CartesianDiscreteModel)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#DiscreteModelPortion-1","page":"Gridap.Geometry","title":"DiscreteModelPortion","text":"","category":"section"},{"location":"Geometry/#","page":"Gridap.Geometry","title":"Gridap.Geometry","text":"DiscreteModelPortion","category":"page"},{"location":"Geometry/#Gridap.Geometry.DiscreteModelPortion","page":"Gridap.Geometry","title":"Gridap.Geometry.DiscreteModelPortion","text":"\n\n\n\n","category":"type"},{"location":"Geometry/#RestrictedDiscreteModel-1","page":"Gridap.Geometry","title":"RestrictedDiscreteModel","text":"","category":"section"},{"location":"Geometry/#","page":"Gridap.Geometry","title":"Gridap.Geometry","text":"RestrictedDiscreteModel","category":"page"},{"location":"Geometry/#Gridap.Geometry.RestrictedDiscreteModel","page":"Gridap.Geometry","title":"Gridap.Geometry.RestrictedDiscreteModel","text":"\n\n\n\n","category":"type"},{"location":"Geometry/#CellFields-1","page":"Gridap.Geometry","title":"CellFields","text":"","category":"section"},{"location":"Geometry/#CellField-interface-1","page":"Gridap.Geometry","title":"CellField interface","text":"","category":"section"},{"location":"Geometry/#","page":"Gridap.Geometry","title":"Gridap.Geometry","text":"CellField\ntest_cell_field\nconvert_to_cell_field(object::CellField,cell_map)\nrestrict(cf::CellField,trian::Triangulation)","category":"page"},{"location":"Geometry/#Gridap.CellData.CellField","page":"Gridap.Geometry","title":"Gridap.CellData.CellField","text":"abstract type CellField <: GridapType end\n\nThis is a plain array of fields plus some metadata. It is interpreted as a Field object on each cell of a computational mesh.\n\n\n\n\n\n","category":"type"},{"location":"Geometry/#Gridap.CellData.test_cell_field","page":"Gridap.Geometry","title":"Gridap.CellData.test_cell_field","text":"test_cell_field(\n  cf::CellField,\n  x::AbstractArray,\n  b::AbstractArray,\n  pred=(==);\n  grad=nothing)\n\n\n\n\n\n","category":"function"},{"location":"Geometry/#Gridap.Geometry.restrict-Tuple{CellField,Triangulation}","page":"Gridap.Geometry","title":"Gridap.Geometry.restrict","text":"restrict(cf::CellField,trian::Triangulation)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Concrete-implementations-1","page":"Gridap.Geometry","title":"Concrete implementations","text":"","category":"section"},{"location":"Geometry/#","page":"Gridap.Geometry","title":"Gridap.Geometry","text":"GenericCellField\nSkeletonCellField\nQPointCellField(value::Number,trian::Triangulation,quad::CellQuadrature)\nCellField(value::Number,trian::Triangulation,quad::CellQuadrature)\nget_cell_map(a::SkeletonCellField)\njump(sf::SkeletonCellField)\nmean(sf::SkeletonCellField)","category":"page"},{"location":"Geometry/#Gridap.CellData.GenericCellField","page":"Gridap.Geometry","title":"Gridap.CellData.GenericCellField","text":"struct GenericCellField{R,S} <: CellField\n\nPrivate fields\n\nend\n\n\n\n\n\n","category":"type"},{"location":"Geometry/#Gridap.CellData.SkeletonCellField","page":"Gridap.Geometry","title":"Gridap.CellData.SkeletonCellField","text":"struct SkeletonCellField <: GridapType\n  left::CellField\n  right::CellField\nend\n\nSupports the same differential and algebraic operations than CellField\n\n\n\n\n\n","category":"type"},{"location":"Geometry/#Gridap.CellData.get_cell_map-Tuple{Gridap.CellData.SkeletonCellField}","page":"Gridap.Geometry","title":"Gridap.CellData.get_cell_map","text":"get_cell_map(a::SkeletonCellField)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.CellData.jump-Tuple{Gridap.CellData.SkeletonCellField}","page":"Gridap.Geometry","title":"Gridap.CellData.jump","text":"jump(sf::SkeletonCellField)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.CellData.mean-Tuple{Gridap.CellData.SkeletonCellField}","page":"Gridap.Geometry","title":"Gridap.CellData.mean","text":"mean(sf::SkeletonCellField)\n\n\n\n\n\n","category":"method"}]
}
