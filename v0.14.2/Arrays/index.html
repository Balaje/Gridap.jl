<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Gridap.Arrays · Gridap.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="Gridap.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit">Gridap.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../getting-started/">Getting Started</a></li><li><a class="tocitem" href="../Gridap/">Gridap</a></li><li><a class="tocitem" href="../Helpers/">Gridap.Helpers</a></li><li><a class="tocitem" href="../Inference/">Gridap.Inference</a></li><li><a class="tocitem" href="../Algebra/">Gridap.Algebra</a></li><li><a class="tocitem" href="../Io/">Gridap.Io</a></li><li><a class="tocitem" href="../TensorValues/">Gridap.TensorValues</a></li><li class="is-active"><a class="tocitem" href>Gridap.Arrays</a><ul class="internal"><li><a class="tocitem" href="#Extended-AbstractArray-interface-1"><span>Extended AbstractArray interface</span></a></li><li><a class="tocitem" href="#Working-with-several-arrays-at-once-1"><span>Working with several arrays at once</span></a></li><li><a class="tocitem" href="#Creating-lazy-operation-trees-1"><span>Creating lazy operation trees</span></a></li><li><a class="tocitem" href="#Helper-functions-1"><span>Helper functions</span></a></li><li><a class="tocitem" href="#Concrete-array-implementations-1"><span>Concrete array implementations</span></a></li></ul></li><li><a class="tocitem" href="../Fields/">Gridap.Fields</a></li><li><a class="tocitem" href="../Polynomials/">Gridap.Polynomials</a></li><li><a class="tocitem" href="../Integration/">Gridap.Integration</a></li><li><a class="tocitem" href="../ReferenceFEs/">Gridap.ReferenceFEs</a></li><li><a class="tocitem" href="../Geometry/">Gridap.Geometry</a></li><li><a class="tocitem" href="../FESpaces/">Gridap.FESpaces</a></li><li><a class="tocitem" href="../MultiField/">Gridap.MultiField</a></li><li><a class="tocitem" href="../Visualization/">Gridap.Visualization</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Gridap.Arrays</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Gridap.Arrays</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/gridap/Gridap.jl/blob/master/docs/src/Arrays.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Gridap.Arrays-1"><a class="docs-heading-anchor" href="#Gridap.Arrays-1">Gridap.Arrays</a><a class="docs-heading-anchor-permalink" href="#Gridap.Arrays-1" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="Gridap.Arrays" href="#Gridap.Arrays"><code>Gridap.Arrays</code></a> — <span class="docstring-category">Module</span></header><section><div><p>This module provides:</p><ul><li>An extension of the <code>AbstractArray</code> interface in order to properly deal with mutable caches.</li><li>A mechanism to generate lazy arrays resulting from operations between arrays.</li><li>A collection of concrete implementations of <code>AbstractArray</code>.</li></ul><p>The exported names in this module are:</p><ul><li><a href="@ref"><code>AppendedArray</code></a></li><li><a href="@ref"><code>BlockArrayCoo</code></a></li><li><a href="@ref"><code>BlockMatrixCoo</code></a></li><li><a href="@ref"><code>BlockVectorCoo</code></a></li><li><a href="#Gridap.Arrays.CachedArray"><code>CachedArray</code></a></li><li><a href="#Gridap.Arrays.CachedMatrix"><code>CachedMatrix</code></a></li><li><a href="#Gridap.Arrays.CachedVector"><code>CachedVector</code></a></li><li><a href="#Gridap.Arrays.CompressedArray"><code>CompressedArray</code></a></li><li><a href="@ref"><code>FilterKernel</code></a></li><li><a href="@ref"><code>FilteredCellArray</code></a></li><li><a href="#Gridap.Arrays.Kernel"><code>Kernel</code></a></li><li><a href="#Gridap.Arrays.LocalToGlobalArray"><code>LocalToGlobalArray</code></a></li><li><a href="#Gridap.Arrays.LocalToGlobalPosNegArray"><code>LocalToGlobalPosNegArray</code></a></li><li><a href="@ref"><code>MulAddKernel</code></a></li><li><a href="@ref"><code>MulKernel</code></a></li><li><a href="#Gridap.Arrays.SubVector"><code>SubVector</code></a></li><li><a href="#Gridap.Arrays.Table"><code>Table</code></a></li><li><a href="@ref"><code>TwoLevelBlockedUnitRange</code></a></li><li><a href="#Gridap.Arrays.UNSET"><code>UNSET</code></a></li><li><a href="@ref"><code>VectorOfBlockArrayCoo</code></a></li><li><a href="@ref"><code>VectorOfBlockMatrixCoo</code></a></li><li><a href="@ref"><code>VectorOfBlockVectorCoo</code></a></li><li><a href="@ref"><code>VectorWithEntryInserted</code></a></li><li><a href="@ref"><code>VectorWithEntryRemoved</code></a></li><li><a href="#Gridap.Arrays.add_to_array!-Union{Tuple{N}, Tuple{Tb}, Tuple{Ta}, Tuple{AbstractArray{Ta,N},AbstractArray{Tb,N}}, Tuple{AbstractArray{Ta,N},AbstractArray{Tb,N},Any}} where N where Tb where Ta"><code>add_to_array!</code></a></li><li><a href="#Gridap.Arrays.append_ptrs-Union{Tuple{T}, Tuple{AbstractArray{T,1},AbstractArray{T,1}}} where T"><code>append_ptrs</code></a></li><li><a href="#Gridap.Arrays.append_ptrs!-Union{Tuple{T}, Tuple{AbstractArray{T,1},AbstractArray{T,1}}} where T"><code>append_ptrs!</code></a></li><li><a href="@ref"><code>append_tables_globally</code></a></li><li><a href="#Gridap.Arrays.append_tables_locally-Tuple{Tuple{Vararg{T,N}} where T where N,Tuple{Vararg{T,N}} where T where N}"><code>append_tables_locally</code></a></li><li><a href="#Gridap.Arrays.apply-Tuple{Any,Vararg{AbstractArray,N} where N}"><code>apply</code></a></li><li><a href="#Gridap.Arrays.apply_all"><code>apply_all</code></a></li><li><a href="#Gridap.Arrays.apply_kernel"><code>apply_kernel</code></a></li><li><a href="#Gridap.Arrays.apply_kernel!-Tuple{Any,Any,Vararg{Any,N} where N}"><code>apply_kernel!</code></a></li><li><a href="#Gridap.Arrays.apply_kernels!"><code>apply_kernels!</code></a></li><li><a href="#Gridap.Arrays.array_cache-Tuple{AbstractArray}"><code>array_cache</code></a></li><li><a href="#Gridap.Arrays.array_caches"><code>array_caches</code></a></li><li><a href="@ref"><code>autodiff_array_gradient</code></a></li><li><a href="@ref"><code>autodiff_array_hessian</code></a></li><li><a href="@ref"><code>autodiff_array_jacobian</code></a></li><li><a href="#Gridap.Arrays.bcast"><code>bcast</code></a></li><li><a href="#Gridap.Arrays.collect1d"><code>collect1d</code></a></li><li><a href="#Gridap.Arrays.contract"><code>contract</code></a></li><li><a href="@ref"><code>eachblockindex</code></a></li><li><a href="#Gridap.Arrays.elem"><code>elem</code></a></li><li><a href="#Gridap.Arrays.empty_table-Union{Tuple{P}, Tuple{T}, Tuple{Type{T},Type{P},Integer}} where P where T"><code>empty_table</code></a></li><li><a href="@ref"><code>enumerateblocks</code></a></li><li><a href="#Gridap.Arrays.find_inverse_index_map-Tuple{Any,Any}"><code>find_inverse_index_map</code></a></li><li><a href="#Gridap.Arrays.find_inverse_index_map!-Tuple{Any,Any}"><code>find_inverse_index_map!</code></a></li><li><a href="#Gridap.Arrays.find_local_index-Tuple{Any,Any}"><code>find_local_index</code></a></li><li><a href="#Gridap.Arrays.flatten_partition-Tuple{Gridap.Arrays.Table,Integer}"><code>flatten_partition</code></a></li><li><a href="#Gridap.Arrays.generate_data_and_ptrs-Union{Tuple{AbstractArray{var&quot;#s18&quot;,1} where var&quot;#s18&quot;&lt;:AbstractArray{T,1}}, Tuple{T}} where T"><code>generate_data_and_ptrs</code></a></li><li><a href="#Gridap.Arrays.get_array-Tuple{AbstractArray}"><code>get_array</code></a></li><li><a href="#Gridap.Arrays.get_arrays-Tuple{Any,Vararg{Any,N} where N}"><code>get_arrays</code></a></li><li><a href="#Gridap.Arrays.get_data_eltype-Union{Tuple{Gridap.Arrays.Table{T,P,Vp} where Vp&lt;:(AbstractArray{T,1} where T)}, Tuple{P}, Tuple{T}} where P where T"><code>get_data_eltype</code></a></li><li><a href="#Gridap.Arrays.get_local_item-Tuple{Any,Integer}"><code>get_local_item</code></a></li><li><a href="#Gridap.Arrays.get_ptrs_eltype-Union{Tuple{Gridap.Arrays.Table{T,P,Vp} where Vp&lt;:(AbstractArray{T,1} where T)}, Tuple{P}, Tuple{T}} where P where T"><code>get_ptrs_eltype</code></a></li><li><a href="#Gridap.Arrays.getindex!-Tuple{Any,AbstractArray,Vararg{Any,N} where N}"><code>getindex!</code></a></li><li><a href="#Gridap.Arrays.getitems-Tuple{Tuple{Vararg{AbstractArray,N} where N},Vararg{Any,N} where N}"><code>getitems</code></a></li><li><a href="#Gridap.Arrays.getitems!"><code>getitems!</code></a></li><li><a href="#Gridap.Arrays.identity_table-Union{Tuple{P}, Tuple{T}, Tuple{Type{T},Type{P},Integer}} where P where T"><code>identity_table</code></a></li><li><a href="#Gridap.Arrays.identity_vector-Tuple{Integer}"><code>identity_vector</code></a></li><li><a href="@ref"><code>is_nonzero_block</code></a></li><li><a href="@ref"><code>is_zero_block</code></a></li><li><a href="#Gridap.Arrays.kernel_cache-Tuple{Any,Vararg{Any,N} where N}"><code>kernel_cache</code></a></li><li><a href="#Gridap.Arrays.kernel_caches"><code>kernel_caches</code></a></li><li><a href="#Gridap.Arrays.kernel_return_type-Tuple{Any,Vararg{Any,N} where N}"><code>kernel_return_type</code></a></li><li><a href="#Gridap.Arrays.kernel_return_types"><code>kernel_return_types</code></a></li><li><a href="@ref"><code>kernel_testitem</code></a></li><li><a href="@ref"><code>lazy_append</code></a></li><li><a href="@ref"><code>lazy_split</code></a></li><li><a href="#Gridap.Arrays.length_to_ptrs!-Tuple{AbstractArray{var&quot;#s18&quot;,N} where N where var&quot;#s18&quot;&lt;:Integer}"><code>length_to_ptrs!</code></a></li><li><a href="#Gridap.Arrays.pair_arrays-Tuple{AbstractArray,AbstractArray}"><code>pair_arrays</code></a></li><li><a href="#Gridap.Arrays.reindex-Tuple{AbstractArray,AbstractArray}"><code>reindex</code></a></li><li><a href="#Gridap.Arrays.rewind_ptrs!-Tuple{AbstractArray{var&quot;#s18&quot;,1} where var&quot;#s18&quot;&lt;:Integer}"><code>rewind_ptrs!</code></a></li><li><a href="@ref"><code>setaxes!</code></a></li><li><a href="#Gridap.Arrays.setsize!"><code>setsize!</code></a></li><li><a href="#Gridap.Arrays.test_array"><code>test_array</code></a></li><li><a href="#Gridap.Arrays.test_kernel"><code>test_kernel</code></a></li><li><a href="#Gridap.Arrays.testitem-Tuple{AbstractArray}"><code>testitem</code></a></li><li><a href="#Gridap.Arrays.testitems"><code>testitems</code></a></li><li><a href="#Gridap.Arrays.unpair_arrays-Tuple{AbstractArray{var&quot;#s18&quot;,N} where N where var&quot;#s18&quot;&lt;:Tuple}"><code>unpair_arrays</code></a></li><li><a href="#Gridap.Arrays.uses_hash-Tuple{Type{var&quot;#s18&quot;} where var&quot;#s18&quot;&lt;:AbstractArray}"><code>uses_hash</code></a></li><li><a href="@ref"><code>zeros_like</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/765b01a5ca7ca108548e8e99556de776348a9c3b/src/Arrays/Arrays.jl#L1-L10">source</a></section></article><h2 id="Extended-AbstractArray-interface-1"><a class="docs-heading-anchor" href="#Extended-AbstractArray-interface-1">Extended AbstractArray interface</a><a class="docs-heading-anchor-permalink" href="#Extended-AbstractArray-interface-1" title="Permalink"></a></h2><p>When implementing new array types, it can be needed some scratch data (e.g., allocating the output), when recovering an item from an array (typically if the array elements are non-isbits objects). To circumvent this, the user could provide the scratch data needed when getting an item. However, the Julia array interface does not support this approach. When calling <code>a[i]</code>, in order to get the element with index <code>i</code> in array <code>a</code>, there is no extra argument for the scratch data. In order to solve this problem, we add new methods to the <code>AbstractArray</code> interface of Julia. We provide default implementations to the new methods, so that any <code>AbstractArray</code> can be used with the extended interface. New array implementations can overload these default implementations to improve performance. The most important among the new methods is <a href="#Gridap.Arrays.getindex!-Tuple{Any,AbstractArray,Vararg{Any,N} where N}"><code>getindex!</code></a>, which allows to recover an item in the array by passing some scratch data.</p><p>The new methods are:</p><ul><li><a href="#Gridap.Arrays.getindex!-Tuple{Any,AbstractArray,Vararg{Any,N} where N}"><code>getindex!(cache,a::AbstractArray,i...)</code></a></li><li><a href="#Gridap.Arrays.array_cache-Tuple{AbstractArray}"><code>array_cache(a::AbstractArray)</code></a></li><li><a href="#Gridap.Arrays.uses_hash-Tuple{Type{var&quot;#s18&quot;} where var&quot;#s18&quot;&lt;:AbstractArray}"><code>uses_hash(::Type{&lt;:AbstractArray})</code></a></li><li><a href="#Gridap.Arrays.testitem-Tuple{AbstractArray}"><code>testitem(a::AbstractArray)</code></a></li></ul><p>These methods can be stressed with the following function</p><ul><li><a href="#Gridap.Arrays.test_array"><code>test_array</code></a></li></ul><article class="docstring"><header><a class="docstring-binding" id="Gridap.Arrays.getindex!-Tuple{Any,AbstractArray,Vararg{Any,N} where N}" href="#Gridap.Arrays.getindex!-Tuple{Any,AbstractArray,Vararg{Any,N} where N}"><code>Gridap.Arrays.getindex!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">getindex!(cache,a::AbstractArray,i...)</code></pre><p>Returns the item of the array <code>a</code> associated with index <code>i</code> by (possibly) using the scratch data passed in the <code>cache</code> object.</p><p>It defaults to</p><pre><code class="language-none">getindex!(cache,a::AbstractArray,i...) = a[i...]</code></pre><p><strong>Examples</strong></p><p>Iterating over an array using the <code>getindex!</code> function</p><pre><code class="language-julia">using Gridap.Arrays

a = collect(10:15)

cache = array_cache(a)
for i in eachindex(a)
  ai = getindex!(cache,a,i)
  println(&quot;$i -&gt; $ai&quot;)
end

# output
1 -&gt; 10
2 -&gt; 11
3 -&gt; 12
4 -&gt; 13
5 -&gt; 14
6 -&gt; 15</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/765b01a5ca7ca108548e8e99556de776348a9c3b/src/Arrays/Interface.jl#L1-L35">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gridap.Arrays.array_cache-Tuple{AbstractArray}" href="#Gridap.Arrays.array_cache-Tuple{AbstractArray}"><code>Gridap.Arrays.array_cache</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">array_cache(a::AbstractArray)</code></pre><p>Returns a cache object to be used in the <a href="#Gridap.Arrays.getindex!-Tuple{Any,AbstractArray,Vararg{Any,N} where N}"><code>getindex!</code></a> function. It defaults to</p><pre><code class="language-none">array_cache(a::T) where T = nothing</code></pre><p>for types <code>T</code> such that <code>uses_hash(T) == Val(false)</code>, and</p><pre><code class="language-none">function array_cache(a::T) where T
  hash = Dict{UInt,Any}()
  array_cache(hash,a)
end</code></pre><p>for types <code>T</code> such that <code>uses_hash(T) == Val(true)</code>, see the <a href="#Gridap.Arrays.uses_hash-Tuple{Type{var&quot;#s18&quot;} where var&quot;#s18&quot;&lt;:AbstractArray}"><code>uses_hash</code></a> function. In the later case, the type <code>T</code> should implement the following signature:</p><pre><code class="language-none">array_cache(hash::Dict,a::AbstractArray)</code></pre><p>where we pass a dictionary (i.e., a hash table) in the first argument. This hash table can be used to test if the object <code>a</code> has already built a cache and re-use it as follows</p><pre><code class="language-none">id = objectid(a)
if haskey(hash,id)
  cache = hash[id] # Reuse cache
else
  cache = ... # Build a new cache depending on your needs
  hash[id] = cache # Register the cache in the hash table
end</code></pre><p>This mechanism is needed, e.g., to re-use intermediate results in complex lazy operation trees. In multi-threading computations, a different hash table per thread has to be used in order to avoid race conditions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/765b01a5ca7ca108548e8e99556de776348a9c3b/src/Arrays/Interface.jl#L38-L72">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gridap.Arrays.uses_hash-Tuple{Type{var&quot;#s18&quot;} where var&quot;#s18&quot;&lt;:AbstractArray}" href="#Gridap.Arrays.uses_hash-Tuple{Type{var&quot;#s18&quot;} where var&quot;#s18&quot;&lt;:AbstractArray}"><code>Gridap.Arrays.uses_hash</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">uses_hash(::Type{&lt;:AbstractArray})</code></pre><p>This function is used to specify if the type <code>T</code> uses the hash-based mechanism to reuse caches.  It should return either <code>Val(true)</code> or <code>Val(false)</code>. It defaults to</p><pre><code class="language-none">uses_hash(::Type{&lt;:AbstractArray}) = Val(false)</code></pre><p>Once this function is defined for the type <code>T</code> it can also be called on instances of <code>T</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/765b01a5ca7ca108548e8e99556de776348a9c3b/src/Arrays/Interface.jl#L93-L105">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gridap.Arrays.testitem-Tuple{AbstractArray}" href="#Gridap.Arrays.testitem-Tuple{AbstractArray}"><code>Gridap.Arrays.testitem</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">testitem(a::AbstractArray{T,N} where N) -&gt; Any
</code></pre><p>Returns an arbitrary instance of <code>eltype(a)</code>. The default returned value is the first entry in the array if <code>length(a)&gt;0</code> and <code>testvalue(eltype(a))</code> if <code>length(a)==0</code> See the <a href="../Inference/#Gridap.Inference.testvalue"><code>testvalue</code></a> function.</p><p><strong>Examples</strong></p><pre><code class="language-julia">using Gridap.Arrays

a = collect(3:10)
ai = testitem(a)

b = Int[]
bi = testitem(b)

(ai, bi)

# output
(3, 0)
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/765b01a5ca7ca108548e8e99556de776348a9c3b/src/Arrays/Interface.jl#L110">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gridap.Arrays.test_array" href="#Gridap.Arrays.test_array"><code>Gridap.Arrays.test_array</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">test_array(
  a::AbstractArray{T,N}, b::AbstractArray{S,N},cmp=(==)) where {T,S,N}</code></pre><p>Checks if the entries in <code>a</code> and <code>b</code> are equal using the comparison function <code>cmp</code>. It also stresses the new methods added to the <code>AbstractArray</code> interface.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/765b01a5ca7ca108548e8e99556de776348a9c3b/src/Arrays/Interface.jl#L170-L176">source</a></section></article><h2 id="Working-with-several-arrays-at-once-1"><a class="docs-heading-anchor" href="#Working-with-several-arrays-at-once-1">Working with several arrays at once</a><a class="docs-heading-anchor-permalink" href="#Working-with-several-arrays-at-once-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Gridap.Arrays.getitems!" href="#Gridap.Arrays.getitems!"><code>Gridap.Arrays.getitems!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">getitems!(c::Tuple,a::Tuple,i...) -&gt; Tuple</code></pre><p>Extracts the <code>i</code>-th entry of all arrays in the tuple <code>a</code> using the caches in the tuple <code>c</code>. The results is a tuple containing each one of the extracted entries.</p><p><strong>Example</strong></p><p>Iterating over three different arrays simultaneously using <code>getitems!</code></p><pre><code class="language-julia">using Gridap.Arrays

a = collect(0:5)
b = collect(10:15)
c = collect(20:25)

caches = array_caches(a,b,c)
for i in eachindex(a)
   s = getitems!(caches,(a,b,c),i)
   println(&quot;$i -&gt; $s&quot;)
end

# output
1 -&gt; (0, 10, 20)
2 -&gt; (1, 11, 21)
3 -&gt; (2, 12, 22)
4 -&gt; (3, 13, 23)
5 -&gt; (4, 14, 24)
6 -&gt; (5, 15, 25)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/765b01a5ca7ca108548e8e99556de776348a9c3b/src/Arrays/Interface.jl#L262-L294">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gridap.Arrays.getitems-Tuple{Tuple{Vararg{AbstractArray,N} where N},Vararg{Any,N} where N}" href="#Gridap.Arrays.getitems-Tuple{Tuple{Vararg{AbstractArray,N} where N},Vararg{Any,N} where N}"><code>Gridap.Arrays.getitems</code></a> — <span class="docstring-category">Method</span></header><section><div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/765b01a5ca7ca108548e8e99556de776348a9c3b/src/Arrays/Interface.jl#L374">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gridap.Arrays.array_caches" href="#Gridap.Arrays.array_caches"><code>Gridap.Arrays.array_caches</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">array_caches(a::AbstractArray...) -&gt; Tuple</code></pre><p>Returns a tuple with the cache of each array in <code>a</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/765b01a5ca7ca108548e8e99556de776348a9c3b/src/Arrays/Interface.jl#L239-L243">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gridap.Arrays.testitems" href="#Gridap.Arrays.testitems"><code>Gridap.Arrays.testitems</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">testitems(b::AbstractArray...) -&gt; Tuple</code></pre><p>Returns a tuple with the result of <code>testitem</code> applied to each of the arrays in <code>b</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia">using Gridap.Arrays

a = collect(3:10)
b = Int[]
c = Float64[]
d = ones(10)

testitems(a,b,c,d)

# output
(3, 0, 0.0, 1.0)
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/765b01a5ca7ca108548e8e99556de776348a9c3b/src/Arrays/Interface.jl#L205-L227">source</a></section></article><h2 id="Creating-lazy-operation-trees-1"><a class="docs-heading-anchor" href="#Creating-lazy-operation-trees-1">Creating lazy operation trees</a><a class="docs-heading-anchor-permalink" href="#Creating-lazy-operation-trees-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Gridap.Arrays.apply-Tuple{Any,Vararg{AbstractArray,N} where N}" href="#Gridap.Arrays.apply-Tuple{Any,Vararg{AbstractArray,N} where N}"><code>Gridap.Arrays.apply</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">apply(f,a::AbstractArray...) -&gt; AbstractArray</code></pre><p>Applies the kernel <code>f</code> to the entries of the arrays in <code>a</code> (see the definition of <a href="#Gridap.Arrays.Kernel"><code>Kernel</code></a>).</p><p>The resulting array <code>r</code> is such that <code>r[i]</code> equals to <code>apply_kernel(f,ai...)</code> where <code>ai</code> is the tuple containing the <code>i</code>-th entry of the arrays in <code>a</code> (see function <a href="#Gridap.Arrays.apply_kernel"><code>apply_kernel</code></a> for more details). In other words, the resulting array is numerically equivalent to:</p><pre><code class="language-none">map( (x...)-&gt;apply_kernel(f,x...), a...)</code></pre><p>See the <a href="#Gridap.Arrays.apply_kernel"><code>apply_kernel</code></a> function for details.</p><p><strong>Examples</strong></p><p>Using a function as kernel</p><pre><code class="language-julia">using Gridap.Arrays

a = collect(0:5)
b = collect(10:15)

c = apply(+,a,b)

println(c)

# output
[10, 12, 14, 16, 18, 20]</code></pre><p>Using a user-defined kernel</p><pre><code class="language-julia">using Gridap.Arrays
import Gridap.Arrays: apply_kernel!

a = collect(0:5)
b = collect(10:15)

struct MySum &lt;: Kernel end

apply_kernel!(cache,::MySum,x,y) = x + y

k = MySum()

c = apply(k,a,b)

println(c)

# output
[10, 12, 14, 16, 18, 20]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/765b01a5ca7ca108548e8e99556de776348a9c3b/src/Arrays/Apply.jl#L2-L58">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gridap.Arrays.apply-Union{Tuple{T}, Tuple{Type{T},Any,Vararg{AbstractArray,N} where N}} where T" href="#Gridap.Arrays.apply-Union{Tuple{T}, Tuple{Type{T},Any,Vararg{AbstractArray,N} where N}} where T"><code>Gridap.Arrays.apply</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">apply(::Type{T},f,a::AbstractArray...) where T</code></pre><p>Like <a href="#Gridap.Arrays.apply-Tuple{Any,Vararg{AbstractArray,N} where N}"><code>apply(f,a::AbstractArray...)</code></a>, but the user provides the element type of the resulting array in order to circumvent type inference.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/765b01a5ca7ca108548e8e99556de776348a9c3b/src/Arrays/Apply.jl#L64-L69">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gridap.Arrays.apply-Tuple{AbstractArray,Vararg{AbstractArray,N} where N}" href="#Gridap.Arrays.apply-Tuple{AbstractArray,Vararg{AbstractArray,N} where N}"><code>Gridap.Arrays.apply</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">apply(f::AbstractArray,a::AbstractArray...) -&gt; AbstractArray</code></pre><p>Applies the kernels in the array of kernels <code>f</code> to the entries in the arrays in <code>a</code>.</p><p>The resulting array has the same entries as the one obtained with:</p><pre><code class="language-none">map( apply_kernel, f, a...)</code></pre><p>See the <a href="#Gridap.Arrays.apply_kernel"><code>apply_kernel</code></a> function for details.</p><p><strong>Example</strong></p><p>&quot;Evaluating&quot; an array of functions</p><pre><code class="language-julia">using Gridap.Arrays

f = [+,-,max,min]
a = [1,2,3,4]
b = [4,3,2,1]

c = apply(f,a,b)

println(c)

# output
[5, -1, 3, 1]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/765b01a5ca7ca108548e8e99556de776348a9c3b/src/Arrays/Apply.jl#L75-L103">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gridap.Arrays.apply-Union{Tuple{T}, Tuple{Type{T},AbstractArray,Vararg{AbstractArray,N} where N}} where T" href="#Gridap.Arrays.apply-Union{Tuple{T}, Tuple{Type{T},AbstractArray,Vararg{AbstractArray,N} where N}} where T"><code>Gridap.Arrays.apply</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">apply(::Type{T},f::AbstractArray,a::AbstractArray...) where T</code></pre><p>Like <a href="#Gridap.Arrays.apply-Tuple{AbstractArray,Vararg{AbstractArray,N} where N}"><code>apply(f::AbstractArray,a::AbstractArray...)</code></a>, but the user provides the element type of the resulting array in order to circumvent type inference.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/765b01a5ca7ca108548e8e99556de776348a9c3b/src/Arrays/Apply.jl#L108-L113">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gridap.Arrays.apply_all" href="#Gridap.Arrays.apply_all"><code>Gridap.Arrays.apply_all</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">apply_all(f::Tuple,a::AbstractArray...) -&gt; Tuple</code></pre><p>Numerically equivalent to</p><pre><code class="language-none">tuple( ( apply(fi, a...) for fi in f)... )</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia">using Gridap.Arrays

a = [1,2,3,4]
b = [4,3,2,1]

c = apply_all( (+,-), a, b)

# Equivalent to
# c = ( apply(+,a,b), apply(-,a,b) )

println(c)

# output
([5, 5, 5, 5], [-3, -1, 1, 3])
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/765b01a5ca7ca108548e8e99556de776348a9c3b/src/Arrays/Apply.jl#L118-L144">source</a></section></article><h3 id="Operation-kernels-1"><a class="docs-heading-anchor" href="#Operation-kernels-1">Operation kernels</a><a class="docs-heading-anchor-permalink" href="#Operation-kernels-1" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="Gridap.Arrays.Kernel" href="#Gridap.Arrays.Kernel"><code>Gridap.Arrays.Kernel</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Abstract type representing the operations to be used in the <a href="#Gridap.Arrays.apply-Tuple{Any,Vararg{AbstractArray,N} where N}"><code>apply</code></a> function.</p><p>Derived types must implement the following method:</p><ul><li><a href="#Gridap.Arrays.apply_kernel!-Tuple{Any,Any,Vararg{Any,N} where N}"><code>apply_kernel!(cache,k,x...)</code></a></li></ul><p>and optionally these ones:</p><ul><li><a href="#Gridap.Arrays.kernel_cache-Tuple{Any,Vararg{Any,N} where N}"><code>kernel_cache(k,x...)</code></a></li><li><a href="#Gridap.Arrays.kernel_return_type-Tuple{Any,Vararg{Any,N} where N}"><code>kernel_return_type(k,x...)</code></a></li></ul><p>The kernel interface can be tested with the <a href="#Gridap.Arrays.test_kernel"><code>test_kernel</code></a> function.</p><p>Note that most of the functionality implemented in terms of this interface relies in duck typing. That is, it is not strictly needed to work with types that inherit from <code>Kernel</code>. This is specially useful in order to accommodate existing types into this framework without the need to implement a wrapper type that inherits from <code>Kernel</code>. For instance, a default implementation is available for <code>Function</code> objects.  However, we recommend that new types inherit from <code>Kernel</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/765b01a5ca7ca108548e8e99556de776348a9c3b/src/Arrays/Kernels.jl#L3-L24">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gridap.Arrays.apply_kernel!-Tuple{Any,Any,Vararg{Any,N} where N}" href="#Gridap.Arrays.apply_kernel!-Tuple{Any,Any,Vararg{Any,N} where N}"><code>Gridap.Arrays.apply_kernel!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">apply_kernel!(cache,f,x...)</code></pre><p>Applies the kernel <code>f</code> at the arguments <code>x...</code> using the scratch data provided in the given <code>cache</code> object. The <code>cache</code> object is built with the <a href="#Gridap.Arrays.kernel_cache-Tuple{Any,Vararg{Any,N} where N}"><code>kernel_cache</code></a> function using arguments of the same type as in <code>x</code>. In general, the returned value <code>y</code> can share some part of its state with the <code>cache</code> object. If the result of two or more invocations of this function need to be accessed simultaneously (e.g., in multi-threading), create and use various <code>cache</code> objects (e.g., one cache per thread).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/765b01a5ca7ca108548e8e99556de776348a9c3b/src/Arrays/Kernels.jl#L48-L58">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gridap.Arrays.kernel_cache-Tuple{Any,Vararg{Any,N} where N}" href="#Gridap.Arrays.kernel_cache-Tuple{Any,Vararg{Any,N} where N}"><code>Gridap.Arrays.kernel_cache</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">kernel_cache(f,x...)</code></pre><p>Returns the <code>cache</code> needed to apply kernel <code>f</code> with arguments of the same type as the objects in <code>x</code>. This function returns <code>nothing</code> by default.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/765b01a5ca7ca108548e8e99556de776348a9c3b/src/Arrays/Kernels.jl#L39-L45">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gridap.Arrays.kernel_return_type-Tuple{Any,Vararg{Any,N} where N}" href="#Gridap.Arrays.kernel_return_type-Tuple{Any,Vararg{Any,N} where N}"><code>Gridap.Arrays.kernel_return_type</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">kernel_return_type(f,x...)</code></pre><p>Returns the type of the result of calling kernel <code>f</code> with arguments of the types of the objects <code>x</code>.</p><p>It defaults to <code>typeof(kernel_testitem(f,x...))</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/765b01a5ca7ca108548e8e99556de776348a9c3b/src/Arrays/Kernels.jl#L27-L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gridap.Arrays.test_kernel" href="#Gridap.Arrays.test_kernel"><code>Gridap.Arrays.test_kernel</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">test_kernel(f,x::Tuple,y,cmp=(==))</code></pre><p>Function used to test if the kernel <code>f</code> has been implemented correctly. <code>f</code> is a kernel object, <code>x</code> is a tuple containing the arguments of the kernel, and <code>y</code> is the expected result. Function <code>cmp</code> is used to compare the computed result with the expected one. The checks are done with the <code>@test</code> macro.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/765b01a5ca7ca108548e8e99556de776348a9c3b/src/Arrays/Kernels.jl#L65-L73">source</a></section></article><h3 id="Other-functions-using-kernels-1"><a class="docs-heading-anchor" href="#Other-functions-using-kernels-1">Other functions using kernels</a><a class="docs-heading-anchor-permalink" href="#Other-functions-using-kernels-1" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="Gridap.Arrays.apply_kernel" href="#Gridap.Arrays.apply_kernel"><code>Gridap.Arrays.apply_kernel</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">apply_kernel(f,x...)</code></pre><p>apply the kernel <code>f</code> at the arguments in <code>x</code> by creating a temporary cache internally. This functions is equivalent to</p><pre><code class="language-jl">cache = kernel_cache(f,x...)
apply_kernel!(cache,f,x...)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/765b01a5ca7ca108548e8e99556de776348a9c3b/src/Arrays/Kernels.jl#L90-L99">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gridap.Arrays.apply_kernels!" href="#Gridap.Arrays.apply_kernels!"><code>Gridap.Arrays.apply_kernels!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">apply_kernels!(caches::Tuple,fs::Tuple,x...) -&gt; Tuple</code></pre><p>Applies the kernels in the tuple <code>fs</code> at the arguments <code>x...</code> by using the corresponding cache objects in the tuple <code>caches</code>. The result is also a tuple containing the result for each kernel in <code>fs</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/765b01a5ca7ca108548e8e99556de776348a9c3b/src/Arrays/Kernels.jl#L129-L135">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gridap.Arrays.kernel_caches" href="#Gridap.Arrays.kernel_caches"><code>Gridap.Arrays.kernel_caches</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">kernel_caches(fs::Tuple,x...) -&gt; Tuple</code></pre><p>Returns a tuple with the cache corresponding to each kernel in <code>fs</code> for the arguments <code>x...</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/765b01a5ca7ca108548e8e99556de776348a9c3b/src/Arrays/Kernels.jl#L108-L113">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gridap.Arrays.kernel_return_types" href="#Gridap.Arrays.kernel_return_types"><code>Gridap.Arrays.kernel_return_types</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">kernel_return_types(f::Tuple,x...) -&gt; Tuple</code></pre><p>Computes the return types of the kernels in <code>f</code> when called with arguments <code>x</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/765b01a5ca7ca108548e8e99556de776348a9c3b/src/Arrays/Kernels.jl#L157-L162">source</a></section></article><h3 id="Built-in-kernels-1"><a class="docs-heading-anchor" href="#Built-in-kernels-1">Built-in kernels</a><a class="docs-heading-anchor-permalink" href="#Built-in-kernels-1" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="Gridap.Arrays.bcast" href="#Gridap.Arrays.bcast"><code>Gridap.Arrays.bcast</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">bcast(f::Function)</code></pre><p>Returns a kernel object that represents the &quot;broadcasted&quot; version of the given function <code>f</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/765b01a5ca7ca108548e8e99556de776348a9c3b/src/Arrays/Kernels.jl#L200-L205">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gridap.Arrays.elem" href="#Gridap.Arrays.elem"><code>Gridap.Arrays.elem</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">elem(f::Function)</code></pre><p>Returns a kernel that represents the element-wise version of the operation <code>f</code> It does not broadcast in singleton axes. Thus, allows some performance optimizations with respect to broadcast.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/765b01a5ca7ca108548e8e99556de776348a9c3b/src/Arrays/Kernels.jl#L274-L281">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gridap.Arrays.contract" href="#Gridap.Arrays.contract"><code>Gridap.Arrays.contract</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">contract(f::Function)</code></pre><p>Like the dot product between to vectors, but using operation <code>f</code> instead of <code>*</code> between components.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>not needed any more, to be deleted</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia">using Gridap.Arrays
k = contract(-)
apply_kernel(k,[1,2],[2,4]) # Equivalent to (1-2) + (2-4)
# output
-3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/765b01a5ca7ca108548e8e99556de776348a9c3b/src/Arrays/Kernels.jl#L425-L443">source</a></section></article><h2 id="Helper-functions-1"><a class="docs-heading-anchor" href="#Helper-functions-1">Helper functions</a><a class="docs-heading-anchor-permalink" href="#Helper-functions-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Gridap.Arrays.collect1d" href="#Gridap.Arrays.collect1d"><code>Gridap.Arrays.collect1d</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">collect1d(a)</code></pre><p>Equivalent to</p><pre><code class="language-none">[a[i] for in 1:length(a)]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/765b01a5ca7ca108548e8e99556de776348a9c3b/src/Arrays/Tables.jl#L327-L333">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gridap.Arrays.reindex-Tuple{AbstractArray,AbstractArray}" href="#Gridap.Arrays.reindex-Tuple{AbstractArray,AbstractArray}"><code>Gridap.Arrays.reindex</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">reindex(i_to_v::AbstractArray, j_to_i::AbstractArray)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/765b01a5ca7ca108548e8e99556de776348a9c3b/src/Arrays/Reindex.jl#L2-L4">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gridap.Arrays.add_to_array!-Union{Tuple{N}, Tuple{Tb}, Tuple{Ta}, Tuple{AbstractArray{Ta,N},AbstractArray{Tb,N}}, Tuple{AbstractArray{Ta,N},AbstractArray{Tb,N},Any}} where N where Tb where Ta" href="#Gridap.Arrays.add_to_array!-Union{Tuple{N}, Tuple{Tb}, Tuple{Ta}, Tuple{AbstractArray{Ta,N},AbstractArray{Tb,N}}, Tuple{AbstractArray{Ta,N},AbstractArray{Tb,N},Any}} where N where Tb where Ta"><code>Gridap.Arrays.add_to_array!</code></a> — <span class="docstring-category">Method</span></header><section><div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/765b01a5ca7ca108548e8e99556de776348a9c3b/src/Arrays/Interface.jl#L391">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gridap.Arrays.get_array-Tuple{AbstractArray}" href="#Gridap.Arrays.get_array-Tuple{AbstractArray}"><code>Gridap.Arrays.get_array</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_array(a::AbstractArray)</code></pre><p>Returns <code>a</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/765b01a5ca7ca108548e8e99556de776348a9c3b/src/Arrays/Interface.jl#L148-L152">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gridap.Arrays.get_arrays-Tuple{Any,Vararg{Any,N} where N}" href="#Gridap.Arrays.get_arrays-Tuple{Any,Vararg{Any,N} where N}"><code>Gridap.Arrays.get_arrays</code></a> — <span class="docstring-category">Method</span></header><section><div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/765b01a5ca7ca108548e8e99556de776348a9c3b/src/Arrays/Interface.jl#L157">source</a></section></article><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>matvec_muladd!(c::AbstractVector,a::AbstractMatrix,b::AbstractVector)</code>. Check Documenter&#39;s build log for details.</p></div></div><article class="docstring"><header><a class="docstring-binding" id="Gridap.Arrays.pair_arrays-Tuple{AbstractArray,AbstractArray}" href="#Gridap.Arrays.pair_arrays-Tuple{AbstractArray,AbstractArray}"><code>Gridap.Arrays.pair_arrays</code></a> — <span class="docstring-category">Method</span></header><section><div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/765b01a5ca7ca108548e8e99556de776348a9c3b/src/Arrays/ArrayPairs.jl#L2">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gridap.Arrays.unpair_arrays-Tuple{AbstractArray{var&quot;#s18&quot;,N} where N where var&quot;#s18&quot;&lt;:Tuple}" href="#Gridap.Arrays.unpair_arrays-Tuple{AbstractArray{var&quot;#s18&quot;,N} where N where var&quot;#s18&quot;&lt;:Tuple}"><code>Gridap.Arrays.unpair_arrays</code></a> — <span class="docstring-category">Method</span></header><section><div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/765b01a5ca7ca108548e8e99556de776348a9c3b/src/Arrays/ArrayPairs.jl#L46">source</a></section></article><h2 id="Concrete-array-implementations-1"><a class="docs-heading-anchor" href="#Concrete-array-implementations-1">Concrete array implementations</a><a class="docs-heading-anchor-permalink" href="#Concrete-array-implementations-1" title="Permalink"></a></h2><h3 id="CachedArray-1"><a class="docs-heading-anchor" href="#CachedArray-1">CachedArray</a><a class="docs-heading-anchor-permalink" href="#CachedArray-1" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="Gridap.Arrays.CachedArray" href="#Gridap.Arrays.CachedArray"><code>Gridap.Arrays.CachedArray</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">mutable struct CachedArray{T, N, A&lt;:AbstractArray{T,N}} &lt;: AbstractArray{T,N}</code></pre><p>Type providing a re-sizable array.</p><p>The size of a <code>CachedArray</code> is changed via the <a href="#Gridap.Arrays.setsize!"><code>setsize!</code></a> function.</p><p>A <code>CachedArray</code> can be build with the constructors</p><ul><li><a href="#Gridap.Arrays.CachedArray-Tuple{AbstractArray}"><code>CachedArray(a::AbstractArray)</code></a></li><li><a href="#Gridap.Arrays.CachedArray-Tuple{Any,Any}"><code>CachedArray(T,N)</code></a></li></ul><pre><code class="language-julia">using Gridap.Arrays
# Create an empty CachedArray
a = CachedArray(Float64,2)
# Resize to new shape (2,3)
setsize!(a,(2,3))
size(a)
# output
(2, 3)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/765b01a5ca7ca108548e8e99556de776348a9c3b/src/Arrays/CachedArrays.jl#L2">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gridap.Arrays.CachedArray-Tuple{AbstractArray}" href="#Gridap.Arrays.CachedArray-Tuple{AbstractArray}"><code>Gridap.Arrays.CachedArray</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">CachedArray(a::AbstractArray)</code></pre><p>Constructs a <code>CachedArray</code> from a given array.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/765b01a5ca7ca108548e8e99556de776348a9c3b/src/Arrays/CachedArrays.jl#L28-L32">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gridap.Arrays.CachedArray-Tuple{Any,Any}" href="#Gridap.Arrays.CachedArray-Tuple{Any,Any}"><code>Gridap.Arrays.CachedArray</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">CachedArray(T,N)</code></pre><p>Constructs an empty <code>CachedArray</code> of element type <code>T</code> and <code>N</code> dimensions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/765b01a5ca7ca108548e8e99556de776348a9c3b/src/Arrays/CachedArrays.jl#L61-L65">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gridap.Arrays.setsize!" href="#Gridap.Arrays.setsize!"><code>Gridap.Arrays.setsize!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">setsize!(a, s)
</code></pre><p>Changes the size of the <code>CachedArray</code> <code>a</code> to the size described the the tuple <code>s</code>. After calling <code>setsize!</code>, the array can store uninitialized values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/765b01a5ca7ca108548e8e99556de776348a9c3b/src/Arrays/CachedArrays.jl#L88">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gridap.Arrays.CachedMatrix" href="#Gridap.Arrays.CachedMatrix"><code>Gridap.Arrays.CachedMatrix</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">const CachedMatrix{T,A} = CachedArray{T,2,A}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/765b01a5ca7ca108548e8e99556de776348a9c3b/src/Arrays/CachedArrays.jl#L40-L42">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gridap.Arrays.CachedVector" href="#Gridap.Arrays.CachedVector"><code>Gridap.Arrays.CachedVector</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">const CachedVector{T,A} = CachedArray{T,1,A}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/765b01a5ca7ca108548e8e99556de776348a9c3b/src/Arrays/CachedArrays.jl#L45-L47">source</a></section></article><h3 id="CompressedArray-1"><a class="docs-heading-anchor" href="#CompressedArray-1">CompressedArray</a><a class="docs-heading-anchor-permalink" href="#CompressedArray-1" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="Gridap.Arrays.CompressedArray" href="#Gridap.Arrays.CompressedArray"><code>Gridap.Arrays.CompressedArray</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct CompressedArray{T,N,A,P} &lt;: AbstractArray{T,N}
  values::A
  ptrs::P
end</code></pre><p>Type representing an array with a reduced set of values. The array is represented by a short array of values, namely the field <code>values</code>, and a large array of indices, namely the field <code>ptrs</code>. The <code>i</code>-th component of the resulting array is defined as <code>values[ptrs[i]]</code>. The type parameters <code>A</code>, and <code>P</code> are restricted to be array types by the inner constructor of this <code>struct</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/765b01a5ca7ca108548e8e99556de776348a9c3b/src/Arrays/CompressedArrays.jl#L2-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gridap.Arrays.CompressedArray-Tuple{AbstractArray,AbstractArray}" href="#Gridap.Arrays.CompressedArray-Tuple{AbstractArray,AbstractArray}"><code>Gridap.Arrays.CompressedArray</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">CompressedArray(values::AbstractArray,ptrs::AbstractArray)</code></pre><p>Creates a <code>CompressedArray</code> object by the given arrays of <code>values</code> and  <code>ptrs</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/765b01a5ca7ca108548e8e99556de776348a9c3b/src/Arrays/CompressedArrays.jl#L17-L22">source</a></section></article><h3 id="Table-1"><a class="docs-heading-anchor" href="#Table-1">Table</a><a class="docs-heading-anchor-permalink" href="#Table-1" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="Gridap.Arrays.Table" href="#Gridap.Arrays.Table"><code>Gridap.Arrays.Table</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia"> struct Table{T,Vd&lt;:AbstractVector{T},Vp&lt;:AbstractVector} &lt;: AbstractVector{Vector{T}}
    data::Vd
    ptrs::Vp
 end</code></pre><p>Type representing a list of lists (i.e., a table) in compressed format.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/765b01a5ca7ca108548e8e99556de776348a9c3b/src/Arrays/Tables.jl#L3-L11">source</a></section></article><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>Table(data::AbstractVector,ptrs::AbstractVector)</code>. Check Documenter&#39;s build log for details.</p></div></div><article class="docstring"><header><a class="docstring-binding" id="Gridap.Arrays.Table-Tuple{AbstractArray{var&quot;#s18&quot;,1} where var&quot;#s18&quot;&lt;:(AbstractArray{T,1} where T)}" href="#Gridap.Arrays.Table-Tuple{AbstractArray{var&quot;#s18&quot;,1} where var&quot;#s18&quot;&lt;:(AbstractArray{T,1} where T)}"><code>Gridap.Arrays.Table</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Table(a::AbstractArray{&lt;:AbstractArray})</code></pre><p>Build a table from a vector of vectors. If the inputs are multidimensional arrays instead of vectors, they are flattened.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/765b01a5ca7ca108548e8e99556de776348a9c3b/src/Arrays/Tables.jl#L20-L25">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gridap.Arrays.identity_table-Union{Tuple{P}, Tuple{T}, Tuple{Type{T},Type{P},Integer}} where P where T" href="#Gridap.Arrays.identity_table-Union{Tuple{P}, Tuple{T}, Tuple{Type{T},Type{P},Integer}} where P where T"><code>Gridap.Arrays.identity_table</code></a> — <span class="docstring-category">Method</span></header><section><div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/765b01a5ca7ca108548e8e99556de776348a9c3b/src/Arrays/Tables.jl#L45">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gridap.Arrays.empty_table-Union{Tuple{P}, Tuple{T}, Tuple{Type{T},Type{P},Integer}} where P where T" href="#Gridap.Arrays.empty_table-Union{Tuple{P}, Tuple{T}, Tuple{Type{T},Type{P},Integer}} where P where T"><code>Gridap.Arrays.empty_table</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">empty_table(::Type{T},::Type{P}, l::Integer) where {T,P}
empty_table(l::Integer)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/765b01a5ca7ca108548e8e99556de776348a9c3b/src/Arrays/Tables.jl#L53-L56">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gridap.Arrays.get_ptrs_eltype-Union{Tuple{Gridap.Arrays.Table{T,P,Vp} where Vp&lt;:(AbstractArray{T,1} where T)}, Tuple{P}, Tuple{T}} where P where T" href="#Gridap.Arrays.get_ptrs_eltype-Union{Tuple{Gridap.Arrays.Table{T,P,Vp} where Vp&lt;:(AbstractArray{T,1} where T)}, Tuple{P}, Tuple{T}} where P where T"><code>Gridap.Arrays.get_ptrs_eltype</code></a> — <span class="docstring-category">Method</span></header><section><div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/765b01a5ca7ca108548e8e99556de776348a9c3b/src/Arrays/Tables.jl#L253">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gridap.Arrays.get_data_eltype-Union{Tuple{Gridap.Arrays.Table{T,P,Vp} where Vp&lt;:(AbstractArray{T,1} where T)}, Tuple{P}, Tuple{T}} where P where T" href="#Gridap.Arrays.get_data_eltype-Union{Tuple{Gridap.Arrays.Table{T,P,Vp} where Vp&lt;:(AbstractArray{T,1} where T)}, Tuple{P}, Tuple{T}} where P where T"><code>Gridap.Arrays.get_data_eltype</code></a> — <span class="docstring-category">Method</span></header><section><div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/765b01a5ca7ca108548e8e99556de776348a9c3b/src/Arrays/Tables.jl#L258">source</a></section></article><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>append_tables_globally(tables::Table{T,P}...) where {T,P}</code>. Check Documenter&#39;s build log for details.</p></div></div><article class="docstring"><header><a class="docstring-binding" id="Gridap.Arrays.append_tables_locally-Tuple{Tuple{Vararg{T,N}} where T where N,Tuple{Vararg{T,N}} where T where N}" href="#Gridap.Arrays.append_tables_locally-Tuple{Tuple{Vararg{T,N}} where T where N,Tuple{Vararg{T,N}} where T where N}"><code>Gridap.Arrays.append_tables_locally</code></a> — <span class="docstring-category">Method</span></header><section><div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/765b01a5ca7ca108548e8e99556de776348a9c3b/src/Arrays/Tables.jl#L272">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gridap.Arrays.append_tables_locally-Tuple{Vararg{Gridap.Arrays.Table,N} where N}" href="#Gridap.Arrays.append_tables_locally-Tuple{Vararg{Gridap.Arrays.Table,N} where N}"><code>Gridap.Arrays.append_tables_locally</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">append_tables_locally(tables::Table...)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/765b01a5ca7ca108548e8e99556de776348a9c3b/src/Arrays/Tables.jl#L263-L265">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gridap.Arrays.rewind_ptrs!-Tuple{AbstractArray{var&quot;#s18&quot;,1} where var&quot;#s18&quot;&lt;:Integer}" href="#Gridap.Arrays.rewind_ptrs!-Tuple{AbstractArray{var&quot;#s18&quot;,1} where var&quot;#s18&quot;&lt;:Integer}"><code>Gridap.Arrays.rewind_ptrs!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">rewind_ptrs!(ptrs)</code></pre><p>Rewind the given vector of pointers.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/765b01a5ca7ca108548e8e99556de776348a9c3b/src/Arrays/Tables.jl#L113-L117">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gridap.Arrays.generate_data_and_ptrs-Union{Tuple{AbstractArray{var&quot;#s18&quot;,1} where var&quot;#s18&quot;&lt;:AbstractArray{T,1}}, Tuple{T}} where T" href="#Gridap.Arrays.generate_data_and_ptrs-Union{Tuple{AbstractArray{var&quot;#s18&quot;,1} where var&quot;#s18&quot;&lt;:AbstractArray{T,1}}, Tuple{T}} where T"><code>Gridap.Arrays.generate_data_and_ptrs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">data, ptrs = generate_data_and_ptrs(vv)</code></pre><p>Given a vector of vectors, compress it and return the corresponding data and and ptrs</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/765b01a5ca7ca108548e8e99556de776348a9c3b/src/Arrays/Tables.jl#L137-L141">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gridap.Arrays.length_to_ptrs!-Tuple{AbstractArray{var&quot;#s18&quot;,N} where N where var&quot;#s18&quot;&lt;:Integer}" href="#Gridap.Arrays.length_to_ptrs!-Tuple{AbstractArray{var&quot;#s18&quot;,N} where N where var&quot;#s18&quot;&lt;:Integer}"><code>Gridap.Arrays.length_to_ptrs!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">length_to_ptrs!(ptrs)</code></pre><p>Given a vector of integers, mutate it from length state to pointer state.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/765b01a5ca7ca108548e8e99556de776348a9c3b/src/Arrays/Tables.jl#L125-L129">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gridap.Arrays.append_ptrs-Union{Tuple{T}, Tuple{AbstractArray{T,1},AbstractArray{T,1}}} where T" href="#Gridap.Arrays.append_ptrs-Union{Tuple{T}, Tuple{AbstractArray{T,1},AbstractArray{T,1}}} where T"><code>Gridap.Arrays.append_ptrs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">append_ptrs(pa,pb)</code></pre><p>Append two vectors of pointers.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/765b01a5ca7ca108548e8e99556de776348a9c3b/src/Arrays/Tables.jl#L174-L178">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gridap.Arrays.append_ptrs!-Union{Tuple{T}, Tuple{AbstractArray{T,1},AbstractArray{T,1}}} where T" href="#Gridap.Arrays.append_ptrs!-Union{Tuple{T}, Tuple{AbstractArray{T,1},AbstractArray{T,1}}} where T"><code>Gridap.Arrays.append_ptrs!</code></a> — <span class="docstring-category">Method</span></header><section><div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/765b01a5ca7ca108548e8e99556de776348a9c3b/src/Arrays/Tables.jl#L184">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gridap.Arrays.find_inverse_index_map-Tuple{Any,Any}" href="#Gridap.Arrays.find_inverse_index_map-Tuple{Any,Any}"><code>Gridap.Arrays.find_inverse_index_map</code></a> — <span class="docstring-category">Method</span></header><section><div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/765b01a5ca7ca108548e8e99556de776348a9c3b/src/Arrays/Tables.jl#L215">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gridap.Arrays.find_inverse_index_map!-Tuple{Any,Any}" href="#Gridap.Arrays.find_inverse_index_map!-Tuple{Any,Any}"><code>Gridap.Arrays.find_inverse_index_map!</code></a> — <span class="docstring-category">Method</span></header><section><div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/765b01a5ca7ca108548e8e99556de776348a9c3b/src/Arrays/Tables.jl#L224">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gridap.Arrays.flatten_partition-Tuple{Gridap.Arrays.Table,Integer}" href="#Gridap.Arrays.flatten_partition-Tuple{Gridap.Arrays.Table,Integer}"><code>Gridap.Arrays.flatten_partition</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">flatten_partition(a_to_bs::Table,nb::Integer)
flatten_partition(a_to_bs::Table)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/765b01a5ca7ca108548e8e99556de776348a9c3b/src/Arrays/Tables.jl#L401-L404">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gridap.Arrays.find_local_index-Tuple{Any,Any}" href="#Gridap.Arrays.find_local_index-Tuple{Any,Any}"><code>Gridap.Arrays.find_local_index</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">find_local_index(a_to_b, b_to_la_to_a)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/765b01a5ca7ca108548e8e99556de776348a9c3b/src/Arrays/Tables.jl#L367-L369">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gridap.Arrays.get_local_item-Tuple{Any,Integer}" href="#Gridap.Arrays.get_local_item-Tuple{Any,Integer}"><code>Gridap.Arrays.get_local_item</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_local_item(a_to_lb_to_b, lb::Integer)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/765b01a5ca7ca108548e8e99556de776348a9c3b/src/Arrays/Tables.jl#L336-L338">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gridap.Arrays.UNSET" href="#Gridap.Arrays.UNSET"><code>Gridap.Arrays.UNSET</code></a> — <span class="docstring-category">Constant</span></header><section><div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/765b01a5ca7ca108548e8e99556de776348a9c3b/src/Arrays/Tables.jl#L211">source</a></section></article><h3 id="LocalToGlobalArray-1"><a class="docs-heading-anchor" href="#LocalToGlobalArray-1">LocalToGlobalArray</a><a class="docs-heading-anchor-permalink" href="#LocalToGlobalArray-1" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="Gridap.Arrays.LocalToGlobalArray" href="#Gridap.Arrays.LocalToGlobalArray"><code>Gridap.Arrays.LocalToGlobalArray</code></a> — <span class="docstring-category">Type</span></header><section><div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/765b01a5ca7ca108548e8e99556de776348a9c3b/src/Arrays/LocalToGlobalArrays.jl#L3">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gridap.Arrays.LocalToGlobalArray-Tuple{AbstractArray{var&quot;#s18&quot;,N} where N where var&quot;#s18&quot;&lt;:AbstractArray,AbstractArray}" href="#Gridap.Arrays.LocalToGlobalArray-Tuple{AbstractArray{var&quot;#s18&quot;,N} where N where var&quot;#s18&quot;&lt;:AbstractArray,AbstractArray}"><code>Gridap.Arrays.LocalToGlobalArray</code></a> — <span class="docstring-category">Method</span></header><section><div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/765b01a5ca7ca108548e8e99556de776348a9c3b/src/Arrays/LocalToGlobalArrays.jl#L9">source</a></section></article><h3 id="LocalToGlobalPosNegArray-1"><a class="docs-heading-anchor" href="#LocalToGlobalPosNegArray-1">LocalToGlobalPosNegArray</a><a class="docs-heading-anchor-permalink" href="#LocalToGlobalPosNegArray-1" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="Gridap.Arrays.LocalToGlobalPosNegArray" href="#Gridap.Arrays.LocalToGlobalPosNegArray"><code>Gridap.Arrays.LocalToGlobalPosNegArray</code></a> — <span class="docstring-category">Type</span></header><section><div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/765b01a5ca7ca108548e8e99556de776348a9c3b/src/Arrays/LocalToGlobalPosNegArrays.jl#L2">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gridap.Arrays.LocalToGlobalPosNegArray-Tuple{AbstractArray{var&quot;#s18&quot;,N} where N where var&quot;#s18&quot;&lt;:AbstractArray,AbstractArray,AbstractArray}" href="#Gridap.Arrays.LocalToGlobalPosNegArray-Tuple{AbstractArray{var&quot;#s18&quot;,N} where N where var&quot;#s18&quot;&lt;:AbstractArray,AbstractArray,AbstractArray}"><code>Gridap.Arrays.LocalToGlobalPosNegArray</code></a> — <span class="docstring-category">Method</span></header><section><div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/765b01a5ca7ca108548e8e99556de776348a9c3b/src/Arrays/LocalToGlobalPosNegArrays.jl#L9">source</a></section></article><h3 id="SubVector-1"><a class="docs-heading-anchor" href="#SubVector-1">SubVector</a><a class="docs-heading-anchor-permalink" href="#SubVector-1" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="Gridap.Arrays.SubVector" href="#Gridap.Arrays.SubVector"><code>Gridap.Arrays.SubVector</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct SubVector{T,A&lt;:AbstractVector{T}} &lt;: AbstractVector{T}
  vector::A
  pini::Int
  pend::Int
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/765b01a5ca7ca108548e8e99556de776348a9c3b/src/Arrays/SubVectors.jl#L2-L8">source</a></section></article><h3 id="Helpers-1"><a class="docs-heading-anchor" href="#Helpers-1">Helpers</a><a class="docs-heading-anchor-permalink" href="#Helpers-1" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="Gridap.Arrays.identity_vector-Tuple{Integer}" href="#Gridap.Arrays.identity_vector-Tuple{Integer}"><code>Gridap.Arrays.identity_vector</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">identity_vector(l::Integer)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/765b01a5ca7ca108548e8e99556de776348a9c3b/src/Arrays/IdentityVectors.jl#L2-L4">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../TensorValues/">« Gridap.TensorValues</a><a class="docs-footer-nextpage" href="../Fields/">Gridap.Fields »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Tuesday 24 November 2020 12:33">Tuesday 24 November 2020</span>. Using Julia version 1.5.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
